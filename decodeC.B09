PROCEDURE decode(* Version 1.3.00 *)(* Declarations *)(* Variable Record *)(* Array *)TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGERDIM varRec(400):VREC(* File Record *)TYPE VFP1=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGERTYPE VFP2=vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGERTYPE VFP3=mTyp,vLnk,fNum:BYTE; pRec,pFld:BOOLEANTYPE VFRC= vp1:VFP1; vp2:VFP2; vp3:VFP3DIM varFRec,defFRec:VFRC(* Line Reference Record *)(* Array *)TYPE LNREF=hLTyp:BYTE; hLOff:INTEGERDIM linRefs(300):LNREF(* File Record *)TYPE LNREC=lnRecNum,lnRefCnt:INTEGER; lnTyp:BYTE; lnOff:INTEGER; lnNum:STRING[5]DIM linRec:LNREC(* DSAT Map Record *)TYPE DSMP=dsOf,dsDm,dsMSz,dsSz:INTEGERDIM DSMap(100):DSMP(* Colors *)TYPE COLR=white,blue,black,green,red,yellow,magenta,cyan,white2,blue2,black2,green2,red2,yellow2,magenta2,cyan2:BYTEDIM color:COLR(* Registers *)TYPE REG=cc,a,b,dp:BYTE; x,y,u:INTEGERDIM regs:REG(* Counters and Input Variables *)DIM token(256),tokenCode,tokenVal,byteVal,linkVal,packet(32),callCode:BYTEDIM loopCnt,nextRef,recCount,delay:INTEGERDIM filCnt,modCnt,intVal,tmpTyp,intOrReal:INTEGERDIM realVal:REAL(* Flag Variables *)DIM found,nextVar,forVar,namVar,creop,isOn,isRestore,renum,potRec,isField,extRef,displays,hasRecords:BOOLEAN(* Instruction Counters *)DIM tInstr,t3e,t3f:INTEGER(* Variable Reference Counters *)DIM varRefs,varCount,tmpRefCnt,i00,i01,r02,r03,cvas,t46,s47:INTEGERDIM b80,i81,r82,l83,s84,c85,v86,t87,m88,f89,fv8a:INTEGERDIM ft8b,fm8c,sf2,vf3,tf4,mf5,ff6,fvf7,ftf8,fmf9:INTEGER(* External Reference Counters *)DIM r23,k24,c29,o2a,c30,r31,d32,c33,s34:INTEGER(* Line Reference Counters *)DIM lineRefs,linCount,lrCnt,rsCnt,lnCnt:INTEGERDIM el11,ew16,el1a,gt20,gs22,lr3b,ig55:INTEGERDIM lits,bLits,iLits,hLits,rLits,sLits:INTEGERDIM lastOff:INTEGER; lastNum:STRING[5](* Column,Row *)DIM col,col1,row:BYTE(* Program Options *)DIM options(26),alertNum,defFcol,defBcol:BYTE(* File Paths *)DIM path,vPath,lnPath,dPath,oPath:BYTE(* File,Overlay Open Status *)DIM pOpen,vOpen,lnOpen,dOpen,oOpen,wOpen:BOOLEAN(* Error and Module Data *)DIM er,er1,which,modSiz,dataSiz,execOff,dsatOff,vdtOff,mnLen,tpVars,dataStAdd,cntr:INTEGER(* File names *)DIM version:STRING[8]; vFile,lnFile,dFile,oFile:STRING[29]DIM chainMod:STRING[177](* Strings *)DIM key:STRING[1]; tokenName:STRING[29]; screenLn:STRING[79](* Format Strings *)DIM fmt3,fmt4:STRING[17]; fmt5:STRING[24]; fmt1:STRING[26]; fmt2:STRING[47](* String Constants *)DIM cPrompt:STRING[25](* Time Stamp *)DIM monthName:STRING[9]; dateTime:STRING[17]DIM month,day,year,hour,minute,second,number:INTEGERDIM sHour,sMinute,sSecond:INTEGERDIM eHour,eMinute,eSecond,tHour,tMinute,tSecond:INTEGERDIM iHour,iMinute,iSecond:INTEGER(* PARAMs passed to defVars *)DIM proc,proc1:STRING[80]; modName,dataDir:STRING[29](* I-Code File Pathname *)PARAM file:STRING[80](* Preliminary Assignments *)BASE 0(* Get Pause and Page *)callCode:=$8D \(* Get Window Packet *)regs.a:=2regs.b:=$00regs.x:=ADDR(packet)RUN SysCall(callCode,regs)er:=0pOpen:=FALSE \vOpen:=FALSE \lnOpen:=FALSE \dOpen:=FALSE \wOpen:=FALSEON ERROR GOTO 500 \REM goto error trapdataDir:="/DD/DATA/"dFile:=dataDir+"initDB"(* For options definitions, see setOpts.B09 *)GOSUB 400  \REM get options packetalertNum:=1(* The use of a comma in the parameter string for displaying options at startup  *)(* is due to the fact that shellplus sees a space as a field separator. There-   *)(* fore I need some other delimiter for allowing options to be the first part    *)(* of the parameter string passed to decode. In actuality, decode ignores this   *)(* character when parsing the string, so it can really be any valid ascii char-  *)(* acter includable in a string. As for why? Because this is the only way to get *)(* an option before the pathlist when passing parameters from the SHELL to RunB  *)(* or Basic09. If you use two parameters (with the first being an option string  *)(* of two bytes) and leave out the option, the shell will make the option string *)(* your filespec string and the filespec parameter will be a null string.        *)(* Set Program Options *)proc1:=fileIF proc1="-V" OR proc1="-v" THEN   PRINT #2,"decode v."; version  END ENDIF IF proc1="-?" OR proc1="-H" OR proc1="-h" THEN  PRINT #2, "Usage:"  PRINT #2, "  decode -?[ or -H or -h]        : this usage help"  PRINT #2,"  decode -V or -v                : current version"  PRINT #2, "  decode [-O (or -o),]<filespec> : display options at startup and"  PRINT #2, "  decode <filespec>              : decode the file specified by filespec"  PRINT #2  PRINT #2, "  filespec: filename or pathname"  PRINT #2, "  ex: myProg, myDir/myProg, /dd/myDir/myProg"  ENDENDIF10 IF LEFT$(proc1,2)="-O" OR LEFT$(proc1,2)="-o" OR options(0)=1 THEN  IF (LEFT$(proc1,2)="-O" OR LEFT$(proc1,2)="-o") AND LEN(proc1)>3 THEN    proc1:=RIGHT$(proc1,LEN(proc1)-3)  ELSE IF (LEFT$(proc1,2)="-O" OR LEFT$(proc1,2)="-o") AND LEN(proc1)<4 THEN    RUN Alert(alertNum,options,proc1,color) \REM Alert dialog: no filespec parameter    IF alertNum=0 THEN 500  ENDIF  \ ENDIF  SHELL "ex RUNB setOpts"  GOSUB 400  \REM get options packetENDIF(* Initialize and Display Screen *)GOSUB 135GOSUB 116 \REM turn cursor offRUN GFX2("CURHOME")OPEN #dPath,dFile:READdOpen:=TRUESEEK #dPath,SIZE(version)+SIZE(options)+2+SIZE(token)+SIZE(color)GET #dPath,defFRecSEEK #dPath,SIZE(version)+SIZE(options)+2+SIZE(token)+SIZE(color)+SIZE(varFRec)+SIZE(DSMap)RUN GFX2("COLOR",options(1),options(2))GOSUB 136GOSUB 135FOR cntr:=1 TO 18  GET #dPath,screenLn \REM display screen text line  PRINT #2, screenLn \REM smaller code doing it this wayNEXT cntrCLOSE #dPathdOpen:=FALSEcol:=0 \row:=23 \ GOSUB 110 \REM set cursor positionPRINT #2,"Initializing...";(* Flags *)oOpen:=FALSE \creop:=FALSE \isOn:=FALSEisRestore:=FALSE \nextVar:=FALSE \found:=FALSE \potRec:=FALSE \extRef:=FALSE(* Counters and Program Variables *)er1:=0 \filCnt:=0 \modCnt:=0 \tmpTyp:=0 \recCount:=0tokenVal:=0 \byteVal:=0 \intVal:=0 \realVal:=0 \which:=0(* Instruction Counters *)tInstr:=0 \t3e:=0 \t3f:=0(* Variable Reference Counters *)varRefs:=0 \varCount:=0 \i00:=0 \i01:=0 \r02:=0 \r03:=0 \cvas:=0t46:=0 \s47:=0 \b80:=0 \i81:=0 \r82:=0 \l83:=0 \s84:=0 \c85:=0v86:=0 \t87:=0 \m88:=0 \f89:=0 \fv8a:=0 \ft8b:=0 \fm8c:=0 \sf2:=0vf3:=0 \tf4:=0 \mf5:=0 \ff6:=0 \fvf7:=0 \ftf8:=0 \fmf9:=0(* External Reference Counters *)r23:=0 \k24:=0 \c29:=0 \o2a:=0 \c30:=0 \r31:=0 \d32:=0 \c33:=0 \s34:=0(* Line Reference Counters *)lineRefs:=0 \lrCnt:=0 \rsCnt:=0 \linCount:=0 \el11:=0ew16:=0 \el1a:=0 \gt20:=0 \gs22:=0 \lr3b:=0 \ig55:=0(* Literal Reference Counters *)lits:=0 \bLits:=0 \iLits:=0 \hLits:=0 \rLits:=0 \sLits:=0(* Module Name *)modName:=""(* String Constants *)cPrompt:="Press [ENTER] To Continue"(* Format Strings *)fmt1:="s12>,i5>,s39>,i5>,s13>,i5>"fmt2:="s12>,i5>,s4,i5>,s4,i5>,s4,i5>,s12>,i5>,s13>,i5>"fmt3:="s56>,i5>,s13>,i5>"fmt4:="s19>,i5>,s35>,i5>"fmt5:="s18>,i5>,s12>,i5>,s4,i5>"GOSUB 450 \REM delay before erasing bottom line(* Open Reference Files *)col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \REM set cursor position and erase to end-of-linePRINT #2, "Opening Reference Files";vFile:=dataDir+"varDefs"lnFile:=dataDir+"linDefs"dFile:=dataDir+"procData"(* Variable Reference *)OPEN #vPath,vFile:UPDATEvOpen:=TRUE(* Line Reference *)OPEN #lnPath,lnFile:UPDATElnOpen:=TRUEIF options(9)=1 THEN  displays:=TRUE \REM display data in overlaysELSE  displays:=FALSEENDIFhasRecords:=FALSE \REM used in defVars and buildSrcGOSUB 450 \REM delay before erasing bottom line(* Start of Program *)(* Display Start Time *)20 proc:=proc1GOSUB 150 \REM get date/time infoGOSUB 110 \ GOSUB 115 \REM set cursor position and erase to end-of-linesHour:=hour \sMinute:=minute \sSecond:=secondcol:=14 \row:=0 \ GOSUB 110 \ GOSUB 115 \REM set cursor position and erase to end-of-linePRINT #2, proc1; \REM Project: path/filename being decodedcol:=14 \row:=1 \ GOSUB 110 \REM set cursor positionPRINT #2, monthName; " "; day; ", "; year; " ";IF hour<10 THEN  PRINT #2, "0"; hour;ELSE  PRINT #2, hour;ENDIFPRINT #2, ":";IF minute<10 THEN  PRINT #2, "0"; minute;ELSE  PRINT #2, minute;ENDIFPRINT #2, ":";IF second<10 THEN  PRINT #2, "0"; second;ELSE  PRINT #2, second;ENDIF(* Open Procedure File *)OPEN #path,proc:READ \REM proc = proc1 = filepOpen:=TRUE(* Header section *)col:=47 \row:=12 \ GOSUB 110 \REM set cursor positionPRINT #2, "Reading Header";(* Sync Bytes *)GET #path,intValcol:=14 \row:=4 \ GOSUB 110 \ PRINT #2 USING "h4",intVal;filCnt:=filCnt+2IF intVal<>$87CD THEN  CLOSE #path \pOpen:=FALSE  alertNum:=2  RUN Alert(alertNum,options,proc1,color) \REM Alert dialog: not an executable file  IF alertNum=0 THEN 500  GOTO 20ENDIF(* Module Size *)GET #path,intValcol:=53 \row:=4 \ GOSUB 110 \ PRINT #2 USING "i6>",intVal;modSiz:=intValfilCnt:=filCnt+2(* Module Name Offset *)GET #path,intValcol:=73 \row:=5 \ GOSUB 110 \ PRINT #2 USING "h4",intVal;filCnt:=filCnt+2(* Type/Language *)GET #path,byteValcol:=14 \row:=5 \ GOSUB 110 \ PRINT #2 USING "h2",byteVal;filCnt:=filCnt+1IF byteVal<>$22 THEN  CLOSE #path \pOpen:=FALSE  alertNum:=3  RUN Alert(alertNum,options,proc1,color) \REM Alert dialog: not an i-code module  IF alertNum=0 THEN 500  GOTO 20ENDIF(* Attributes/Revision *)GET #path,byteValcol:=14 \row:=6 \ GOSUB 110 \ PRINT #2 USING "h2",byteVal;filCnt:=filCnt+1(* Parity *)GET #path,byteValcol:=14 \row:=7 \ GOSUB 110 \ PRINT #2 USING "h2",byteVal;filCnt:=filCnt+1(* Procedure Size *)GET #path,intValcol:=36 \row:=4 \ GOSUB 110 \ PRINT #2 USING "h4",intVal;execOff:=intValfilCnt:=filCnt+2(* Data Size *)GET #path,intValdataSiz:=intValcol:=53 \row:=5 \ GOSUB 110 \ PRINT #2 USING "i6>",intVal;filCnt:=filCnt+2(* VDT (Symbol Table) Address *)GET #path,intValcol:=53 \row:=6 \ GOSUB 110 \ PRINT #2 USING "h4",intVal;vdtOff:=intValfilCnt:=filCnt+2(* DSAT (Definition Area) Address *)GET #path,intValcol:=53 \row:=7 \ GOSUB 110 \ PRINT #2 USING "h4",intVal;dsatOff:=intValfilCnt:=filCnt+2(* Procedure Link Address *)(* called procedure list, data memory offset *)GET #path,intValcol:=36 \row:=7 \ GOSUB 110 \ PRINT #2 USING "h4",intVal;filCnt:=filCnt+2(* 1st Data Statement Address *)GET #path,intValdataStAdd:=intValcol:=36 \row:=5 \ GOSUB 110 \ PRINT #2 USING "h4",intVal;filCnt:=filCnt+2(* 1st Exectable Statement Address *)(* unimplemented *)GET #path,intValcol:=36 \row:=6 \ GOSUB 110 \ PRINT #2 USING "h4",intVal;filCnt:=filCnt+2(* Procedure Status *)GET #path,byteValcol:=73 \row:=4 \ GOSUB 110 \ PRINT #2 USING "h2",byteVal;filCnt:=filCnt+1(* Module Name Length *)GET #path,byteValcol:=73 \row:=6 \ GOSUB 110 \ PRINT #2 USING "i6>",byteVal;mnLen:=byteValfilCnt:=filCnt+1(* Module Name *)FOR loopCnt:=1 TO mnLen  GET #path,byteVal  filCnt:=filCnt+1  modName:=modName+CHR$(LAND(byteVal,127))NEXT loopCntcol:=14 \row:=3 \ GOSUB 110 \REM set cursor positionPRINT #2, modName;oFile:=modName+"Raw.txt"(* Chain Module String *)chainMod:="ex RunB #32K defVars ("""+proc+""","""+modName+""","""+dataDir+""")"(* Module CRC *)SEEK #path,modSiz-3col:=73 \row:=7 \ GOSUB 110 \REM set cursor positionFOR loopCnt:=1 TO 3  GET #path,byteVal  PRINT #2 USING "h2",byteVal;NEXT loopCnt(* Total Program Variables *)(* does not include REAL or STRING variables defined by use. *)SEEK #path,vdtOff-3GET #path,tpVarscol:=73 \row:=8 \ GOSUB 110 \REM set cursor positionPRINT #2 USING "i6>",tpVars;(* Output File *)IF options(21)=1 THEN  col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \REM set cursor position and erase to end-of-line  PRINT #2, "Writing "; oFile; "...";  CREATE #oPath,oFile:WRITE  oOpen:=TRUEENDIF(* This is the main routine. *)(* Decode Instructions *)GOSUB 200(* Close Output File *)IF oOpen THEN  col:=11+LEN(oFile) \row:=23 \ GOSUB 110  PRINT #2, "Done";  CLOSE #oPath  oOpen:=FALSE  GOSUB 450 \REM delay before erasing bottom lineENDIF(* This section will be modified to use the new options format. *)(* Display group counts? *)IF displays AND options(11)=1 THEN  wOpen:=TRUEENDIFIF wOpen THEN  GOSUB 118 \REM Open background overlay  PRINT #2, " References";  GOSUB 120 \REM open middle overlay  PRINT #2, "Total Variable References: "; varRefs  PRINT #2, "    Total Line References: ";lineRefs; "       Total Literal Declarations: ";lits;  GOSUB 125 \REM open foreground overlay  GOSUB 105 \REM turn page pause on  PRINT #2 USING fmt1,"BYTE 80 ",b80,"CVA 0E ",cvas,"BYTE 8D ",bLits  PRINT #2 USING fmt1,"INTEGER 81 ",i81,"RUN 23 ",r23, "INTEGER 8E ",iLits  PRINT #2 USING fmt1,"REAL 82 ",r82,"KILL 24 ",k24, "REAL 8F ",rLits  PRINT #2 USING fmt1,"BOOLEAN 83 ",l83,"CREATE 29 ",c29, "STRING 90 ",sLits  PRINT #2 USING fmt1,"STRING 84 ",s84,"______Field______    OPEN 2A ",o2a ,"HEX 91 ",hLits  PRINT #2 USING fmt2,"RECORD 85 ",c85," F2",sf2," F6",ff6, " 89",f89,"CLOSE 30 ",c30,"ELSE 11 ",el11  PRINT #2 USING fmt2,"VECTOR 86 ",v86," F3",vf3," F7",fvf7," 8A",fv8a,"RESTORE 31 ",r31,"ENDWHILE 16 ",ew16  PRINT #2 USING fmt2,"TABLE 87 ",t87," F4",tf4," F8",ftf8," 8B",ft8b,"DELETE 32 ",d32,"ENDLOOP 1A ",el1a  PRINT #2 USING fmt2,"MATRIX 88 ",m88," F5",mf5," F9",fmf9," 8C",fm8c,"CHAIN 33 ",c33,"GOTO 20 ",gt20  PRINT #2 USING fmt3,"SHELL 34 ",s34,"GOSUB 22 ",gs22  PRINT #2  PRINT #2 USING fmt4,"<ivgt> 55-1 ",ig55-lrCnt,"ON <expr> GOTO/GOSUB <ivgt> 55-2 ",lrCnt  PRINT #2 USING fmt4,"RESTORE/THEN 3B-1 ",lr3b-rsCnt,"ON <expr> GOTO/GOSUB 3B-2 ",rsCnt  PRINT #2  PRINT #2 USING fmt5,"FOR/NEXT   TO 46 ",t46,"INTEGER 00 ",i00," 01 ",i01  PRINT #2 USING fmt5,"STEP 47 ",s47,"REAL 02 ",r02," 03 ",r03  PRINT #2  \ PRINT #2, cPrompt;  GOSUB 140 \REM get keypress  GOSUB 130 \REM close overlay  GOSUB 130 \REM close overlay  GOSUB 130 \REM close overlay  GOSUB 100 \REM turn page pause off  wOpen:=FALSEENDIF(* ============================================================ *)(* Write References Counts *)IF options(21)=1 THEN oFile:=modName+"Refs.txt"CREATE #oPath,oFile:WRITEoOpen:=TRUEPRINT #oPath," References"PRINT #oPath,"Total Variable References: "; varRefsPRINT #oPath,"    Total Line References: "; lineRefs; "       Total Literal Declarations: "; litsPRINT #oPath USING fmt1,"BYTE 80 ",b80,"CVA 0E ",cvas,"BYTE 8D ",bLitsPRINT #oPath USING fmt1,"INTEGER 81 ",i81,"RUN 23 ",r23,"INTEGER 8E ",iLitsPRINT #oPath USING fmt1,"REAL 82 ",r82,"KILL 24 ",k24,"REAL 8F ",rLitsPRINT #oPath USING fmt1,"BOOLEAN 83 ",l83,"CREATE 29 ",c29,"STRING 90 ",sLitsPRINT #oPath USING fmt1,"STRING 84 ",s84,"______Field______    OPEN 2A ",o2a,"HEX 91 ",hLitsPRINT #oPath USING fmt2,"RECORD 85 ",c85," F2",sf2," F6",ff6," 89",f89,"CLOSE 30 ",c30,"ELSE 11 ",el11PRINT #oPath USING fmt2,"VECTOR 86 ",v86," F3",vf3," F7",fvf7," 8A",fv8a,"RESTORE 31 ",r31,"ENDWHILE 16 ",ew16PRINT #oPath USING fmt2,"TABLE 87 ",t87," F4",tf4," F8",ftf8," 8B",ft8b,"DELETE 32 ",d32,"ENDLOOP 1A ",el1aPRINT #oPath USING fmt2,"MATRIX 88 ",m88," F5",mf5," F9",fmf9," 8C",fm8c,"CHAIN 33 ",c33,"GOTO 20 ",gt20PRINT #oPath USING fmt3,"SHELL 34 ",s34,"GOSUB 22 ",gs22PRINT #oPathPRINT #oPath USING fmt4,"<ivgt> 55-1 ",ig55-lrCnt,"ON <expr> GOTO/GOSUB <ivgt> 55-2 ",lrCntPRINT #oPath USING fmt4,"RESTORE/THEN 3B-1 ",lr3b-rsCnt,"ON <expr> GOTO/GOSUB 3B-2 ",rsCntPRINT #oPathPRINT #oPath USING fmt5,"FOR/NEXT   TO 46 ",t46,"INTEGER 00 ",i00," 01 ",i01PRINT #oPath USING fmt5,"STEP 47 ",s47,"REAL 02 ",r02," 03 ",r03CLOSE #oPathoOpen:=FALSEENDIF (* ============================================================ *)(* Line Reference List, Sort, Number *)IF linCount>0 THEN  GOSUB 300ELSE  col:=47 \row:=13 \ GOSUB 110 \REM set cursor position  PRINT #2, "No Line References";ENDIF(* Close Files *)CLOSE #pathpOpen:=FALSECLOSE #vPathvOpen:=FALSECLOSE #lnPathlnOpen:=FALSE(* Save Data *)col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \REM set cursor position and erase to end-of-linePRINT #2, "Saving data...";(* This data is saved so each part has access to the data *)OPEN #dPath,dFile:WRITEdOpen:=TRUEPUT #dPath,displays \ PUT #dPath,hasRecords(* Start Time Variables *)PUT #dPath,sHour \ PUT #dPath,sMinute \ PUT #dPath,sSecond(* Module Offsets and Sizes *)PUT #dPath,modSiz \ PUT #dPath,dataSiz \ PUT #dPath,execOffPUT #dPath,dsatOff \ PUT #dPath,vdtOff \ PUT #dPath,tpVarsPUT #dPath,dataStAdd(* Variables lookup table *)PUT #dPath,varRec(* Instruction Counts *)PUT #dPath,tInstr \ PUT #dPath,t3e \ PUT #dPath,t3f(* Variable Reference Counts *)PUT #dPath,varRefs \ PUT #dPath,varCount(* These are not used, but are saved for summary info *)PUT #dPath,i00 \ PUT #dPath,i01 \ PUT #dPath,r02 \ PUT #dPath,r03PUT #dPath,t46 \ PUT #dPath,s47 \ PUT #dPath,cvasPUT #dPath,b80 \ PUT #dPath,i81 \ PUT #dPath,r82 \ PUT #dPath,l83PUT #dPath,s84 \ PUT #dPath,c85 \ PUT #dPath,v86 \ PUT #dPath,t87PUT #dPath,m88 \ PUT #dPath,f89 \ PUT #dPath,fv8a \ PUT #dPath,ft8bPUT #dPath,fm8c \ PUT #dPath,sf2 \ PUT #dPath,vf3 \ PUT #dPath,tf4PUT #dPath,mf5 \ PUT #dPath,ff6 \ PUT #dPath,fvf7 \ PUT #dPath,ftf8PUT #dPath,fmf9(* External Reference Counts *)PUT #dPath,r23 \ PUT #dPath,k24 \ PUT #dPath,c29 \ PUT #dPath,o2aPUT #dPath,c30 \ PUT #dPath,r31 \ PUT #dPath,d32 \ PUT #dPath,c33PUT #dPath,s34(* Line Reference Counts *)PUT #dPath,lineRefs \ PUT #dPath,lrCnt \ PUT #dPath,rsCntPUT #dPath,linCount \ PUT #dPath,el11 \ PUT #dPath,ew16PUT #dPath,el1a \ PUT #dPath,gt20 \ PUT #dPath,gs22PUT #dPath,lr3b \ PUT #dPath,ig55(* Literal Reference Counts *)PUT #dPath,lits \ PUT #dPath,bLitsPUT #dPath,iLits \ PUT #dPath,hLits \ PUT #dPath,rLitsPUT #dPath,sLits(* Close Data File *)CLOSE #dPathdOpen:=FALSEcol:=14 \row:=23 \ GOSUB 110PRINT #2, "Done";GOSUB 117 \REM turn cursor onGOSUB 450 \REM delay before erasing bottom line(* Chain to defVars *)CHAIN chainMod(* End of Program *)END(* ============= *)(* Subroutines *)(* == Group 1 == *)(* Display and Input *)(* Reset Pause and Page *)100 packet(7):=0 \packet(8):=$18callCode:=$8E \(* Set Window Packet *)regs.a:=2regs.b:=$00regs.x:=ADDR(packet)RUN SysCall(callCode,regs)RETURN(* Set Pause and Page *)105 packet(7):=1 \packet(8):=$12callCode:=$8E \(* Set Window Packet *)regs.a:=2regs.b:=$00regs.x:=ADDR(packet)RUN SysCall(callCode,regs)RETURN110 RUN GFX2("CURXY",col,row) \ RETURN115 RUN GFX2("EREOLINE") \ RETURN116 RUN GFX2("CUROFF") \ RETURN117 RUN GFX2("CURON") \ RETURN118 RUN GFX2("OWSET",1,0,1,80,22,options(3),options(4)) \ RETURN120 RUN GFX2("OWSET",1,0,2,80,21,options(5),options(6)) \ RETURN125 RUN GFX2("OWSET",1,0,4,80,18,options(7),options(8)) \ RETURN130 RUN GFX2("OWEND") \ RETURN135 RUN GFX2("CLEAR") \ RETURN136 RUN GFX2("COLOR",options(1),options(2)) \ RETURN(* ============= *)(* Get Keypress *)140 key:=""REPEAT  RUN Inkey(key)  IF key>="A" AND key<="Z" THEN    key:=CHR$(ASC(key)+$20)  ENDIFUNTIL key="y" OR key="n" OR key=CHR$(13)GOSUB 116 \REM turn cursor offcol:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \REM set cursor position and erase to end-of-lineRETURN(* ============= *)(* Date and Time Stamp *)(* Display completion time *)145 iHour:=hour \iMinute:=minute \iSecond:=secondGOSUB 150 \REM get date/time infoeHour:=hour \eMinute:=minute \eSecond:=secondIF eHour<iHour THEN  tHour:=eHour+12-iHourELSE  tHour:=eHour-iHourENDIFIF eMinute<iMinute THEN  tMinute:=eMinute+60-iMinuteELSE  tMinute:=eMinute-iMinuteENDIFIF eSecond<iSecond THEN  tSecond:=eSecond+60-iSecondELSE  tSecond:=eSecond-iSecondENDIFIF eSecond<iSecond AND tSecond<60 THEN  tMinute:=tMinute-1ENDIFIF eMinute<iMinute AND tMinute<60 THEN  tHour:=tHour-1ENDIFIF tHour<10 THEN  PRINT #2, "0"; tHour; ":";ELSE  PRINT #2, tHour; ":";ENDIFIF tMinute<10 THEN  PRINT #2, "0"; tMinute; ":";ELSE  PRINT #2, tMinute; ":";ENDIFIF tSecond<10 THEN  PRINT #2, "0"; tSecondELSE  PRINT #2, tSecondENDIFRETURN(* ============= *)(* Date Stamp *)150 dateTime:=DATE$month:=VAL(MID$(dateTime,4,2))day:=VAL(MID$(dateTime,7,2))year:=2000+VAL(LEFT$(dateTime,2))hour:=VAL(MID$(dateTime,10,2))minute:=VAL(MID$(dateTime,13,2))second:=VAL(MID$(dateTime,16,2))RESTORE 155 \REM set to beginning of month name dataREPEAT  READ number,monthNameUNTIL number=monthRETURN(* ============= *)(* Month Names *)155 DATA 1,"January",2,"February",3,"March"DATA 4,"April",5,"May",6,"June"DATA 7,"July",8,"August",9,"September"DATA 10,"October",11,"November",12,"December"(* ============= *)(* == Group 2 == *)(* Instruction Decode *)(* Instruction code section, first pass *)(* This section will be modified to use the new options format, *)(*   and all window output is now directed to stderr.           *)(* Display instruction decode? *)200 SEEK #path,execOffIF displays AND options(10)=1 THEN  wOpen:=TRUEENDIFGOSUB 150 \REM get date/time infocol:=47 \row:=12 \ GOSUB 110 \ GOSUB 115 \REM set cursor position and erase to end-of-linePRINT #2, "Decoding";modCnt:=0 \forVar:=FALSE \namVar:=TRUEIF oOpen THEN  PRINT #oPath USING "h4,s1,h4,s1",filCnt," ",modCnt,"|";ENDIFIF wOpen THEN  GOSUB 118 \REM Open background overlay  PRINT #2, " First Pass Decode";  GOSUB 120 \REM open middle overlay  PRINT #2, "  Addr"  PRINT #2, "Mod  Exec Instruction";  col:=0 \row:=20 \ GOSUB 110 \REM set cursor position  PRINT #2, "      {variable ref}       (line ref)       [literal ref]       <token ID>      ";  GOSUB 125 \REM open foreground overlay  PRINT #2 USING "h4,s1,h4,s1",filCnt," ",modCnt,"|";ENDIFREPEAT  extRef:=FALSE  REPEAT    GET #path,tokenVal    modCnt:=modCnt+1 \REM I-Code area offset    filCnt:=filCnt+1 \REM file offset    GOSUB 270 \REM get keyword    (* ON {var} GOTO/GOSUB statement for <ivgt> count *)    IF tokenVal=$1D THEN      isOn:=TRUE  \REM this statement is a ON statement    ENDIF    (* KILL References *)    IF tokenVal=$24 THEN      k24:=k24+1 \REM k[ill] token value $24 these variables are counters for the tokens      extRef:=TRUE \REM external reference (SHELL, CHAIN, etc.)      linkVal:=tokenVal \REM for linking external statements with strings or literals. not uased by decode.    ENDIF    (* OPEN or CREATE statement for file mode *)    IF tokenVal=$29 OR tokenVal=$2A THEN      creop:=TRUE \extRef:=TRUE \linkVal:=tokenVal      (* CREATE References *)      IF tokenVal=$29 THEN        c29:=c29+1      (* OPEN References *)      ELSE        o2a:=o2a+1      ENDIF    ENDIF    (* CLOSE References *)    IF tokenVal=$30 THEN      c30:=c30+1 \extRef:=TRUE \linkVal:=tokenVal    ENDIF    (* RESTORE References *)    IF tokenVal=$31 THEN      r31:=r31+1 \isRestore:=TRUE    ENDIF    (* DELETE References *)    IF tokenVal=$32 THEN      d32:=d32+1 \extRef:=TRUE \linkVal:=tokenVal    ENDIF    (* CHAIN References *)    IF tokenVal=$33 THEN      c33:=c33+1 \extRef:=TRUE \linkVal:=tokenVal    ENDIF    (* SHELL References *)    IF tokenVal=$34 THEN      s34:=s34+1 \extRef:=TRUE \linkVal:=tokenVal    ENDIF    (* Complex Variable Assignments *)    IF tokenVal=$0E THEN      cvas:=cvas+1    ENDIF    (* Variable References *)    IF tokenVal=$13 OR tokenVal=$14 THEN  \REM FOR(13) NEXT(14)      IF tokenVal=$13 THEN        forVar:=TRUE      ELSE        nextVar:=TRUE      ENDIF      IF oOpen THEN        PRINT #oPath USING "s2,h2,s1,s"+STR$(LEN(tokenName))+",s2","[<",tokenVal," ",tokenName,"> ";      ENDIF      IF wOpen THEN        PRINT #2 USING "s2,h2,s1,s"+STR$(LEN(tokenName))+",s2","[<",tokenVal," ",tokenName,"> ";      ENDIF      GET #path,tokenVal      modCnt:=modCnt+1      filCnt:=filCnt+1    ENDIF    IF forVar THEN      IF tokenVal=$81 THEN  \REM INTEGER variable        intOrReal:=1      ELSE        IF tokenVal=$82 THEN  \REM REAL variable          intOrReal:=2        ENDIF      ENDIF      IF tokenVal=$46 OR tokenVal=$47 THEN  \REM TO(46) STEP(47)        namVar:=FALSE        varFRec.vp2.intReal:=intOrReal      ELSE        namVar:=TRUE      ENDIF    ENDIF    (* =============== =============== *)    (* 00 INT no STEP  23 RUN          *)    (* 01 INT w/ STEP  46 TO           *)    (* 02 REAL no STEP 47 STEP         *)    (* 03 REAL w/ STEP                 *)    (* 80-8C/F2-F9 Variable references *)    (* =============== =============== *)    IF nextVar AND (tokenVal>=$00 AND tokenVal<=$03) OR tokenVal=$23 OR tokenVal=$46 OR tokenVal=$47 OR tokenVal>=$80 AND tokenVal<=$8C OR tokenVal>=$F2 AND tokenVal<=$F9 THEN      GET #path,intVal      modCnt:=modCnt+2      filCnt:=filCnt+2      varRefs:=varRefs+1      GOSUB 230 \REM increment counter      GOSUB 210 \REM add variable reference      IF tokenVal=$23 OR tokenVal=$46 OR tokenVal=$47 THEN        IF oOpen THEN          PRINT #oPath USING "s2,h2,s1,s"+STR$(LEN(tokenName))+",s2,h4,s2","{<",tokenVal," ",tokenName,"> ",intVal,"} ";        ENDIF        IF wOpen THEN          PRINT #2 USING "s2,h2,s1,s"+STR$(LEN(tokenName))+",s2,h4,s2","{<",tokenVal," ",tokenName,"> ",intVal,"} ";        ENDIF      ELSE        IF oOpen THEN          PRINT #oPath USING "s1,h2,x1,h4","{",tokenVal,intVal;        ENDIF        IF wOpen THEN          PRINT #2 USING "s1,h2,x1,h4","{",tokenVal,intVal;        ENDIF        IF tokenVal>$03 THEN          IF oOpen THEN            PRINT #oPath, "} ";          ENDIF          IF wOpen THEN            PRINT #2, "} ";          ENDIF        ELSE          IF oOpen THEN            PRINT #oPath, " ";          ENDIF          IF wOpen THEN            PRINT #2, " ";          ENDIF        ENDIF      ENDIF      IF nextVar THEN        FOR nextRef:=1 TO 3          GET #path,intVal          modCnt:=modCnt+2          filCnt:=filCnt+2          IF nextRef=1 THEN            namVar:=FALSE            GOSUB 210 \REM add variable reference            IF oOpen THEN              PRINT #oPath USING "h4,s1",intVal," ";            ENDIF            IF wOpen THEN              PRINT #2 USING "h4,s1",intVal," ";            ENDIF          ELSE            IF nextRef=2 THEN              IF intVal>0 THEN                namVar:=FALSE                GOSUB 210 \REM add variable reference              ENDIF              IF oOpen THEN                PRINT #oPath USING "h4,s2",intVal,"} ";              ENDIF              IF wOpen THEN                PRINT #2 USING "h4,s2",intVal,"} ";              ENDIF            ELSE              IF nextRef=3 THEN                namVar:=TRUE                IF intVal>0 THEN                  IF oOpen THEN                    PRINT #oPath USING "s1,h4,s2","(",intVal,") ";                  ENDIF                  IF wOpen THEN                    PRINT #2 USING "s1,h4,s2","(",intVal,") ";                  ENDIF                ENDIF              ENDIF            ENDIF          ENDIF        NEXT nextRef        nextVar:=FALSE      ENDIF    (* Literals *)    ELSE      IF tokenVal>=$8D AND tokenVal<=$91 AND tokenVal<>$90 THEN        lits:=lits+1        IF oOpen THEN          PRINT #oPath USING "s2,h2,s1,s"+STR$(LEN(tokenName))+",s2","[<",tokenVal," ",tokenName,"> ";        ENDIF        IF wOpen THEN          PRINT #2 USING "s2,h2,s1,s"+STR$(LEN(tokenName))+",s2","[<",tokenVal," ",tokenName,"> ";        ENDIF        (* BYTE Literals *)        IF tokenVal=$8D THEN          GET #path,byteVal          modCnt:=modCnt+1          filCnt:=filCnt+1          bLits:=bLits+1          IF oOpen THEN            PRINT #oPath, byteVal; "] ";          ENDIF          IF wOpen THEN            PRINT #2, byteVal; "] ";          ENDIF        (* REAL Literals *)        ELSE          IF tokenVal=$8F THEN            GET #path,realVal            modCnt:=modCnt+5            filCnt:=filCnt+5            rLits:=rLits+1            IF oOpen THEN              PRINT #oPath, realVal; "] ";            ENDIF            IF wOpen THEN              PRINT #2, realVal; "] ";            ENDIF          (* INTEGER and HEX Literals *)          ELSE            GET #path,intVal            modCnt:=modCnt+2            filCnt:=filCnt+2            IF tokenVal=$91 THEN              hLits:=hLits+1              IF oOpen THEN                PRINT #oPath USING "h4,s2",intVal,"] ";              ENDIF              IF wOpen THEN                PRINT #2 USING "h4,s2",intVal,"] ";              ENDIF            ELSE              iLits:=iLits+1              IF oOpen THEN                PRINT #oPath, intVal; "] ";              ENDIF              IF wOpen THEN                PRINT #2, intVal; "] ";              ENDIF            ENDIF          ENDIF        ENDIF      (* String Literals *)      ELSE        IF tokenVal=$90 THEN          lits:=lits+1          sLits:=sLits+1          IF oOpen THEN            PRINT #oPath USING "s2,h2,s1,s"+STR$(LEN(tokenName))+",s2","[<",tokenVal," ",tokenName,"> ";          ENDIF          IF wOpen THEN            PRINT #2 USING "s2,h2,s1,s"+STR$(LEN(tokenName))+",s2","[<",tokenVal," ",tokenName,"> ";          ENDIF          REPEAT            GET #path,byteVal            modCnt:=modCnt+1            filCnt:=filCnt+1            IF byteVal=$FF THEN              IF oOpen THEN                PRINT #oPath USING "s2,h2,s1,s"+STR$(LEN(tokenName))+",s3"," <",byteVal," ",tokenName,">] ";              ENDIF              IF wOpen THEN                PRINT #2 USING "s2,h2,s1,s"+STR$(LEN(tokenName))+",s3"," <",byteVal," ",tokenName,">] ";              ENDIF            ELSE              IF byteVal>=$20 THEN                IF oOpen THEN                  PRINT #oPath, CHR$(byteVal);                ENDIF                IF wOpen THEN                  PRINT #2, CHR$(byteVal);                ENDIF              ELSE                IF oOpen THEN                  PRINT #oPath USING "x1,h2,x1",byteVal;                ENDIF                IF wOpen THEN                  PRINT #2 USING "x1,h2,x1",byteVal;                ENDIF              ENDIF            ENDIF          UNTIL byteVal=$FF        (* Line References *)        ELSE         (* =============== =============== *)         (* 20 GOTO         16 ENDWHILE     *)         (* 22 GOSUB        1A ENDLOOP      *)         (* 55 ivgt         1C ENDEXIT      *)         (* 11 ELSE         3B blrf         *)         (* =============== =============== *)          IF tokenVal=$20 OR tokenVal=$22 OR tokenVal=$55 OR tokenVal=$11 OR tokenVal=$16 OR tokenVal=$1A OR tokenVal=$1C OR tokenVal=$3B THEN            GET #path,intVal            modCnt:=modCnt+2            filCnt:=filCnt+2            lineRefs:=lineRefs+1            IF isRestore AND tokenVal=$3B THEN              rsCnt:=rsCnt+1            ENDIF            IF isOn THEN              lrCnt:=lrCnt+1              isOn:=FALSE            ENDIF            GOSUB 230 \REM increment counter            IF oOpen THEN              PRINT #oPath USING "s2,h2,s1,s"+STR$(LEN(tokenName))+",s2,h4,s2","(<",tokenVal," ",tokenName,"> ",intVal,") ";            ENDIF            IF wOpen THEN              PRINT #2 USING "s2,h2,s1,s"+STR$(LEN(tokenName))+",s2,h4,s2","(<",tokenVal," ",tokenName,"> ",intVal,") ";            ENDIF            IF tokenVal=$20 OR tokenVal=$22 OR tokenVal=$3B THEN              GOSUB 220 \REM add line number reference            ENDIF          ELSE            IF oOpen THEN              PRINT #oPath USING "s1,h2,s1,s"+STR$(LEN(tokenName))+",s2","<",tokenVal," ",tokenName,"> ";            ENDIF            IF wOpen THEN              PRINT #2 USING "s1,h2,s1,s"+STR$(LEN(tokenName))+",s2","<",tokenVal," ",tokenName,"> ";            ENDIF            IF tokenVal=$46 OR tokenVal=$47 THEN              GET #path,intVal              modCnt:=modCnt+2              filCnt:=filCnt+2              IF oOpen THEN                PRINT #oPath USING "s2,h4,s3","<*",intVal,"*> ";              ENDIF              IF wOpen THEN                PRINT #2 USING "s2,h4,s3","<*",intVal,"*> ";              ENDIF            ENDIF          ENDIF        ENDIF      ENDIF    ENDIF    (* Get File Open/Create Mode *)    IF tokenVal=$4A AND creop THEN      GET #path,byteVal      modCnt:=modCnt+1      filCnt:=filCnt+1      RESTORE 280 \REM set to beginning of file mode data      REPEAT        READ tokenCode,tokenName      UNTIL tokenCode=byteVal OR tokenCode=0      IF oOpen THEN        PRINT #oPath USING "s1,h2,s1,s"+STR$(LEN(tokenName))+",s2","<",tokenVal," ",tokenName,"> ";      ENDIF      IF wOpen THEN        PRINT #2 USING "s1,h2,s1,s"+STR$(LEN(tokenName))+",s2","<",tokenVal," ",tokenName,"> ";      ENDIF      creop:=FALSE    ENDIF  (* End of Instruction Statement *)  UNTIL tokenVal=$3E OR tokenVal=$3F  IF forVar THEN    forVar:=FALSE  ENDIF  IF NOT(namVar) THEN    namVar:=TRUE  ENDIF  IF oOpen THEN    PRINT #oPath  ENDIF  IF wOpen THEN    PRINT #2  ENDIF  IF tokenVal=$3E THEN    t3e:=t3e+1  ENDIF  IF tokenVal=$3F THEN    t3f:=t3f+1  ENDIF  tInstr:=tInstr+1  IF isOn THEN    isOn:=FALSE  ENDIF  IF isRestore THEN    isRestore:=FALSE  ENDIF  IF oOpen THEN    PRINT #oPath USING "h4,s1,h4,s1",filCnt," ",modCnt,"|";  ENDIF  IF wOpen THEN    PRINT #2 USING "h4,s1,h4,s1",filCnt," ",modCnt,"|";  ENDIF  IF NOT(wOpen) THEN    GOSUB 267 \REM display counts  ENDIF(* End of Instruction Code Section *)UNTIL modCnt=dsatOff-execOffIF wOpen THEN  PRINT #2  \ PRINT #2  \ PRINT #2, cPrompt;  GOSUB 140 \REM get keypress  GOSUB 130 \REM close overlay  GOSUB 130 \REM close overlay  GOSUB 130 \REM close overlay  wOpen:=FALSE  GOSUB 267 \REM display countsENDIFcol:=47 \row:=12 \ GOSUB 110 \REM set cursor positionPRINT #2, "Decoded ";(* Display completion time *)col:=69 \row:=12 \ GOSUB 110 \REM set cursor positionGOSUB 145 \REM get date and time infoRETURN(* ============= *)(* Identify Duplicate and Add Variable Record *)(* Is it a field? *)210 IF tokenVal>=$F6 AND tokenVal<=$F9 OR tokenVal>=$89 AND tokenVal<=$8C THEN  isField:=TRUEELSE  isField:=FALSEENDIF(* Is it a potential record? *)(* At this stage whether a reference is a record or not *)(* is not determinable. That happens in defVars. *)IF tokenVal>=$85 AND tokenVal<=$8C OR tokenVal>=$F2 AND tokenVal<=$F9 THEN  potRec:=TRUEELSE  potRec:=FALSEENDIF(* Search Records *)recCount:=0 \found:=FALSEIF varCount>0 THEN  REPEAT    IF tokenVal=varRec(recCount).vTyp THEN      IF intVal=varRec(recCount).vOff THEN        found:=TRUE        SEEK #vPath,recCount*SIZE(varFRec)+2        GET #vPath,varFRec        SEEK #vPath,recCount*SIZE(varFRec)+2      ENDIF    ENDIF    EXITIF found THEN    ENDEXIT    recCount:=recCount+1  UNTIL found OR recCount=varCountENDIF(* Add Record *)IF NOT(found) THEN  varFRec:=defFRec  varRec(varCount).vTyp:=0 \varRec(varCount).nTyp:=0 \varRec(varCount).nVar:=FALSE  varRec(varCount).vOff:=0 \varRec(varCount).vdOff:=0 \varRec(varCount).dsOff:=0  varRec(varCount).dmOff:=0 \varRec(varCount).fOff:=0 \varRec(varCount).pOff:=0  SEEK #vPath,varCount*SIZE(varFRec)+2  varRec(varCount).vTyp:=tokenVal  varRec(varCount).vOff:=intVal  varRec(varCount).nVar:=namVar  varCount:=varCount+1  varFRec.vp2.vRecNum:=varCount  varFRec.vp2.vRefCnt:=1  varFRec.vp3.pRec:=FALSE  varFRec.vp3.vLnk:=0  IF tokenVal>=$80 AND tokenVal<=$83 OR tokenVal>=$00 AND tokenVal<=$03 OR tokenVal=$46 OR tokenVal=$47 THEN    varFRec.vp3.mTyp:=1 \REM atomic type: BYTE, INTEGER, REAL, BOOLEAN  ENDIF  IF tokenVal=$84 THEN    varFRec.vp3.mTyp:=2 \REM atomic type: STRING  ENDIF  IF tokenVal>$84 OR tokenVal=$23 THEN    varFRec.vp3.mTyp:=3 \REM all others point to the VDT  ENDIF  IF extRef THEN    varFRec.vp3.vLnk:=linkVal \REM external link reference - unused  ENDIFENDIF(* Connect Records with Fields *)IF isField THEN  varFRec.vp2.pVar:=tmpTyp  varFRec.vp3.pFld:=TRUEELSE  varFRec.vp2.pVar:=0  varFRec.vp3.pFld:=FALSEENDIFIF potRec THEN  varFRec.vp3.pRec:=TRUE  tmpTyp:=varFRec.vp2.vRecNumELSE  varFRec.vp3.pRec:=FALSEENDIFIF found THEN  varFRec.vp2.vRefCnt:=varFRec.vp2.vRefCnt+1ENDIFPUT #vPath,varFRecIF NOT(found) THEN  SEEK #vPath,0  PUT #vPath,varCountENDIFRETURN(* ============= *)(* Identify Duplicate and Add Line Record *)(* Search Records *)220 recCount:=0 \found:=FALSEIF NOT(isRestore) OR isRestore AND intVal<>dataStAdd THEN  IF linCount>0 THEN    REPEAT      IF tokenVal=linRefs(recCount).hLTyp THEN        IF intVal=linRefs(recCount).hLOff THEN          found:=TRUE          SEEK #lnPath,recCount*SIZE(linRec)+2          GET #lnPath,linRec          linRec.lnRefCnt:=linRec.lnRefCnt+1          SEEK #lnPath,recCount*SIZE(linRec)+2          PUT #lnPath,linRec        ENDIF      ENDIF      recCount:=recCount+1    UNTIL found OR recCount=linCount  ENDIF  (* Add Record *)  IF NOT(found) THEN    SEEK #lnPath,linCount*SIZE(linRec)+2    linRefs(linCount).hLTyp:=tokenVal    linRefs(linCount).hLOff:=intVal    linCount:=linCount+1    linRec.lnRecNum:=linCount    linRec.lnRefCnt:=1    linRec.lnTyp:=tokenVal    linRec.lnOff:=intVal    PUT #lnPath,linRec    SEEK #lnPath,0    PUT #lnPath,linCount  ENDIFENDIFRETURN(* ============= *)(* Count References *)230 ON PEEK(ADDR(token)+tokenVal) GOTO 231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266231 RETURN(* FOR/NEXT integer no STEP232 i00:=i00+1   \ RETURN(* FOR/NEXT integer with STEP233 i01:=i01+1   \ RETURN(* FOR/NEXT real no STEP234 r02:=r02+1   \ RETURN(* FOR/NEXT real with STEP235 r03:=r03+1   \ RETURN(* ELSE 11236 el11:=el11+1 \ RETURN(* ENDWHILE 16237 ew16:=ew16+1 \ RETURN(* ENDLOOP 1A238 el1a:=el1a+1 \ RETURN(* GOTO 20239 gt20:=gt20+1 \ RETURN(* GOSUB 22240 gs22:=gs22+1 \ RETURN(* RUN 23241 r23:=r23+1   \ RETURN(* bound line reference 3B242 lr3b:=lr3b+1 \ RETURN(* TO 46243 t46:=t46+1   \ RETURN(* STEP 47244 s47:=s47+1   \ RETURN(* invisible goto 55245 ig55:=ig55+1 \ RETURN(* BYTE 80246 b80:=b80+1   \ RETURN(* INTEGER 81247 i81:=i81+1   \ RETURN(* REAL 82248 r82:=r82+1   \ RETURN(* BOOLEAN 83249 l83:=l83+1   \ RETURN(* STRING 84250 s84:=s84+1   \ RETURN(* record/any array or atomic type 85251 c85:=c85+1   \ RETURN(* vector array 86252 v86:=v86+1   \ RETURN(* table array 87253 t87:=t87+1   \ RETURN(* matrix array 88254 m88:=m88+1   \ RETURN(* field variable 89255 f89:=f89+1   \ RETURN(* field vector array 8A256 fv8a:=fv8a+1 \ RETURN(* field table array 8B257 ft8b:=ft8b+1 \ RETURN(* field matrix array 8C258 fm8c:=fm8c+1 \ RETURN(* record/any array or atomic type F2259 sf2:=sf2+1   \ RETURN(* vector array F3260 vf3:=vf3+1   \ RETURN(* table array F4261 tf4:=tf4+1   \ RETURN(* matrix array F5262 mf5:=mf5+1   \ RETURN(* field variable F6263 ff6:=ff6+1   \ RETURN(* field vector array F7264 fvf7:=fvf7+1 \ RETURN(* field table array F8265 ftf8:=ftf8+1 \ RETURN(* field matrix array F9266 fmf9:=fmf9+1 \ RETURNRETURN(* ============= *)(* Display Counts *)267 col:=14 \row:=12 \ GOSUB 110 \ PRINT #2 USING "i5>", tInstr;col:=29 \ GOSUB 110 \ PRINT #2 USING "i4>", t3e;col:=35 \ GOSUB 110 \ PRINT #2 USING "i5>", t3f;col:=14 \row:=13 \ GOSUB 110 \ PRINT #2 USING "i5>", lineRefs;col:=22 \ GOSUB 110 \ PRINT #2 USING "i4>", linCount;col:=14 \row:=14 \ GOSUB 110 \ PRINT #2 USING "i5>", varRefs;col:=22 \ GOSUB 110 \ PRINT #2 USING "i4>", varCount;RETURN(* ============= *)(* Read Keyword Tokens *)270 RESTORE 275 \REM set to beginning of keyword dataREPEAT  READ tokenCode,tokenNameUNTIL tokenCode=tokenVal OR tokenCode=0RETURN(* ============= *)(* Keyword/Token Data *)275 DATA $04,"DATA",$05,"STOP",$06,"BYE",$07,"TRON",$08,"TROFF"DATA $09,"PAUSE",$0A,"DEG",$0B,"RAD",$0C,"RETURN",$0D,"LET"DATA $0E,"cva",$0F,"POKE",$10,"IF",$11,"ELSE",$12,"ENDIF"DATA $13,"FOR",$14,"NEXT",$15,"WHILE",$16,"ENDWHILE",$17,"REPEAT"DATA $18,"UNTIL",$19,"LOOP",$1A,"ENDLOOP",$1B,"EXITIF"DATA $1C,"ENDEXIT",$1D,"ON",$1E,"ERROR",$20,"GOTO",$22,"GOSUB"DATA $23,"RUN",$24,"KILL",$25,"INPUT",$26,"PRINT",$27,"CHD"DATA $28,"CHX",$29,"CREATE",$2A,"OPEN",$2B,"SEEK",$2C,"READ"DATA $2D,"WRITE",$2E,"GET",$2F,"PUT",$30,"CLOSE",$31,"RESTORE"DATA $32,"DELETE",$33,"CHAIN",$34,"SHELL",$35,"BASE 0"DATA $36,"BASE 1",$39,"END",$3B,"lref",$3C,"dex",$3E,"\",$3F,"eol"DATA $45,"THEN",$46,"TO",$47,"STEP",$48,"DO",$49,"USING",$4A,":"DATA $4B,",",$4D,"(",$4E,")",$51,";",$52,":=",$53,"=",$54,"#"DATA $55,"ivgt",$8D,"blit",$8E,"ilit",$8F,"rlit",$90,"""",$91,"$"DATA $92,"ADDR()",$93,"addr",$94,"SIZE()",$95,"size",$96,"POS"DATA $97,"ERR",$98,"MOD(,)",$99,"MOD(,)",$9A,"RND()",$9B,"PI"DATA $9C,"SUBSTR(,)",$9D,"SGN()",$9E,"SGN()",$9F,"SIN()",$A0,"COS()"DATA $A1,"TAN()",$A2,"ASN()",$A3,"ACS()",$A4,"ATN()",$A5,"EXP()"DATA $A6,"ABS()",$A7,"ABS()",$A8,"LOG()",$A9,"LOG10()",$AA,"SQRT()"DATA $AC,"INT()",$AD,"INT()",$AE,"FIX()",$AF,"FIX()",$B0,"FLOAT()"DATA $B1,"FLOAT()",$B2,"SQ()",$B3,"SQ()",$B4,"PEEK()",$B5,"LNOT()"DATA $B6,"VAL()",$B7,"LEN()",$B8,"ASC()",$B9,"LAND(,)",$BA,"LOR(,)"DATA $BB,"LXOR(,)",$BC,"TRUE",$BD,"FALSE",$BE,"EOF()",$BF,"TRIM$()"DATA $C0,"MID$(,,)",$C1,"LEFT$(,)",$C2,"RIGHT$(,)",$C3,"CHR$()"DATA $C4,"STR$()",$C5,"STR$()",$C6,"DATE$",$C7,"TAB()",$C8,"fix1"DATA $C9,"fix2",$CA,"fix3",$CB,"flt1",$CC,"flt2",$CD,"NOT()",$CE,"-"DATA $CF,"-",$D0,"AND",$D1,"OR",$D2,"XOR",$D3,">",$D4,">",$D5,">"DATA $D6,"<",$D7,"<",$D8,"<",$D9,"<>",$DA,"<>",$DB,"<>",$DC,"<>"DATA $DD,"=",$DE,"=",$DF,"=",$E0,"=",$E1,">=",$E2,">=",$E3,">="DATA $E4,"<=",$E5,"<=",$E6,"<=",$E7,"+",$E8,"+",$E9,"+",$EA,"-"DATA $EB,"-",$EC,"*",$ED,"*",$EE,"/",$EF,"/",$F0,"^",$F1,"**"DATA $FF,"""",$00,""(* ============= *)(* File Mode Keywords *)280 DATA $01,"READ",$02,"WRITE",$03,"UPDATE",$04,"EXEC"DATA $05,"READ+EXEC",$06,"WRITE+EXEC",$07,"UPDATE+EXEC"DATA $80,"DIR",$81,"READ+DIR",$82,"WRITE+DIR",$83,"UPDATE+DIR"DATA $84,"EXEC+DIR",$85,"READ+EXEC+DIR",$86,"WRITE+EXEC+DIR"DATA $87,"UPDATE+EXEC+DIR",$00,""(* ============= *)(* == Group 3 == *)(* Display line references? *)300 col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \REM set cursor position and erase to end-of-lineIF displays AND options(12)=1 THEN  wOpen:=TRUEENDIFIF wOpen THEN  GOSUB 118 \REM Open background overlay  PRINT #2, " Line References (un-numbered)";  GOSUB 120 \REM open middle overlay  tmpRefCnt:=0  SEEK #lnPath,0  GET #lnPath,linCount  PRINT #2, "Total Line Reference Records: "; linCount  PRINT #2, "Rec#  RfCt Tk Off  Rec#  RfCt Tk Off  Rec#  RfCt Tk Off  Rec#  RfCt Tk Off"  GOSUB 125 \REM open foreground overlay  GOSUB 105 \REM turn page pause on  FOR recCount:=0 TO linCount-1    GET #lnPath,linRec    PRINT #2 USING "i5>,i5>,s1,h2,s1,h4,s1",linRec.lnRecNum,linRec.lnRefCnt," ",linRec.lnTyp," ",linRec.lnOff," ";    IF MOD(recCount+1,4)=0 THEN      PRINT #2    ENDIF    tmpRefCnt:=tmpRefCnt+linRec.lnRefCnt  NEXT recCount  GOSUB 100 \REM turn page pause off  IF MOD(recCount,4)<>0 THEN    PRINT  ENDIF  PRINT "Total Line References: "; tmpRefCnt  PRINT #2  \ PRINT #2, cPrompt;  GOSUB 140 \REM get keypress  GOSUB 130 \REM close overlay  GOSUB 130 \REM close overlay  GOSUB 130 \REM close overlay  wOpen:=FALSEENDIF(* Sort Line References *)IF linCount>0 THEN  GOSUB 150 \REM get date/time infoENDIFIF linCount>1 THEN  col:=47 \row:=13 \ GOSUB 110 \REM set cursor position  PRINT #2, "Sorting";  renum:=TRUE  SEEK #lnPath,0  RUN lSort (er,which,lnPath,0,linCount-1,linRefs)  IF er>0 THEN 500 \REM goto error trap  col:=47 \ GOSUB 110 \REM set cursor position  PRINT #2, "Sorted      ";ELSE  IF linCount=1 THEN    renum:=TRUE  ELSE    renum:=FALSE  ENDIFENDIFIF renum THEN  (* Display Numbering? *)  IF displays AND options(13)=1 THEN    wOpen:=TRUE  ENDIF  (* Write <procedure>Lines.txt file *)  IF options(22)=1 THEN    col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \REM set cursor position and erase to end-of-line    oFile:=modName+"Lines.txt"    PRINT #2, "Writing "; oFile; "...";    CREATE #oPath, oFile:WRITE    oOpen:=TRUE  ENDIF  col:=47 \row:=13 \ GOSUB 110 \REM set cursor position  PRINT #2, "Numbering";  IF oOpen THEN    PRINT #oPath, "Rec#  RfCt Tk Off  Line Number"  ENDIF  IF wOpen THEN    GOSUB 118 \REM Open background overlay    PRINT #2, " Line References (numbered)";    GOSUB 120 \REM open middle overlay    PRINT #2  \ PRINT #2, "Rec#  RfCt Tk Off  Line Number"  ENDIF  SEEK #lnPath,2  recCount:=0 \lnCnt:=0  IF wOpen THEN    GOSUB 125 \REM open foreground overlay    GOSUB 105 \REM turn page pause on  ENDIF  (* Line Number Assignment *)  lastOff:=0 \lastNum:=""  REPEAT    GET #lnPath,linRec    linRec.lnRecNum:=recCount+1    IF lnCnt>0 AND linRec.lnOff=lastOff THEN \REM same reference      linRec.lnNum:=lastNum \REM gets same number    ELSE \REM next number      linRec.lnNum:=STR$((lnCnt+1)*10)      lastOff:=linRec.lnOff      lastNum:=linRec.lnNum      lnCnt:=lnCnt+1    ENDIF    SEEK #lnPath,recCount*SIZE(linRec)+2    PUT #lnPath,linRec    IF oOpen THEN      PRINT #oPath USING "i5>,i5>,s1,h2,s1,h4,s1,s5>",linRec.lnRecNum,linRec.lnRefCnt," ",linRec.lnTyp," ",linRec.lnOff," ",linRec.lnNum    ENDIF    IF wOpen THEN      PRINT #2 USING "i5>,i5>,s1,h2,s1,h4,s1,s5>",linRec.lnRecNum,linRec.lnRefCnt," ",linRec.lnTyp," ",linRec.lnOff," ",linRec.lnNum    ENDIF    recCount:=recCount+1  UNTIL recCount=linCountELSE  IF wOpen THEN    IF linCount=0 THEN      PRINT #2, "No Line References"    ENDIF    IF linCount=1 THEN      PRINT #2, linCount; " Line Reference"    ENDIF  ENDIFENDIFIF wOpen THEN  PRINT #2  \ PRINT #2, cPrompt;  GOSUB 140 \REM get keypress  GOSUB 130 \REM close overlay  GOSUB 130 \REM close overlay  GOSUB 130 \REM close overlay  GOSUB 100 \REM turn page pause off  wOpen:=FALSEENDIFIF oOpen THEN  col:=11+LEN(oFile) \row:=23 \ GOSUB 110  PRINT #2, "Done";  CLOSE #oPath  oOpen:=FALSE  GOSUB 450 \REM delay before erasing bottom lineENDIFcol:=47 \row:=13 \ GOSUB 110 \REM set cursor positionPRINT #2, "Numbered ";IF linCount>0 THEN  (* Display completion time *)  col:=69 \ GOSUB 110 \REM set cursor position  GOSUB 145 \REM get date and time infoENDIFRETURN(* ============= *)(* == Group 4 == *)(* Get Options from initDB *)400OPEN #dPath,dFile:READdOpen:=TRUEGET #dPath,versionGET #dPath,optionsGET #dPath,defFcolGET #dPath,defBcolGET #dPath,token \REM token counter array, used in ON GOSUBGET #dPath,color \REM colors record, used in overlay windowsGET #dPath,varFRec \REM initialized variable file recordGET #dPath,DSMap \REM initialized DSAT Map arrayCLOSE #dPathdOpen:=FALSERETURN450 FOR delay=1 TO 12000 \NEXT delayRETURN(* ============= *)(* == Group 5 == *)(* Error Trap *)500 IF er=0 AND alertNum>0 THEN  er:=ERRENDIFIF er=56 OR er=216 THEN  IF pOpen THEN    CLOSE #path \ pOpen:=FALSE  ENDIF  RUN Alert(alertNum,options,proc1,color) \REM Alert dialog: no filespec parameter, alertNum=1  IF er=216 THEN    er:=0    GOTO 20  ENDIF  er:=0  IF alertNum>0 THEN 10  IF vOpen THEN    CLOSE #vPath    vOpen:=FALSE  ENDIF  IF lnOpen THEN    CLOSE #lnPath    lnOpen:=FALSE  ENDIF  IF dOpen THEN    CLOSE #dPath    dOpen:=FALSE  ENDIF  GOSUB 117 \REM turn cursor on  col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \REM set cursor position and erase to end-of-line  PRINT #2  ENDELSE  IF pOpen THEN    CLOSE #path    pOpen:=FALSE  ENDIF  IF vOpen THEN    CLOSE #vPath    vOpen:=FALSE  ENDIF  IF lnOpen THEN    CLOSE #lnPath    lnOpen:=FALSE  ENDIF  IF dOpen THEN    CLOSE #dPath    dOpen:=FALSE  ENDIF  IF wOpen THEN    GOSUB 130 \GOSUB 130 \GOSUB 130 \REM close overlays  ENDIF  col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \REM set cursor position and erase to end-of-line  ON ERROR GOTO 510  (* For brief error messages, change ,1 to ,0 *)  IF er>0 THEN    SHELL "ex RunB ErrorCodes (""" + STR$(er) + """,""1"")"  ENDIF  GOSUB 117 \REM turn cursor on  ENDENDIF(* ============= *)(* If ErrorCodes is not found *)510 er1:=ERRIF er1=43 THEN  PRINT #2, "Error: "; erENDIFEND(* ============= *)PROCEDURE lSort(* based on quicksort, by T.F. Ritter(* Line Reference Record *)(* Array *)TYPE LNREF=hLTyp:BYTE; hLOff:INTEGERDIM linRef:LNREF(* Record *)TYPE LNREC=lnRecNum,lnRefCnt:INTEGER; lnTyp:BYTE; lnOff:INTEGER; lnNum:STRING[5]DIM linRec,linRecs(2):LNRECPARAM er,which:INTEGER; lnPath:BYTE; bottom,top:INTEGER; linRefs(300):LNREFDIM lower,upper:INTEGER; btemp:BOOLEANON ERROR GOTO 10which:=which+1RUN GFX2("CURXY",55,13) \PRINT #2, which;BASE 0lower:=bottomupper:=topLOOP \REM each element gets the once over  REPEAT \REM this is a postinc instruction    btemp:=linRefs(lower).hLOff<linRefs(top).hLOff    lower:=lower+1  UNTIL NOT(btemp)  lower:=lower-1 \REM point at the tested element  EXITIF lower=upper THEN  ENDEXIT  REPEAT \REM this is a postdec instruction    upper:=upper-1  UNTIL linRefs(upper).hLOff<=linRefs(top).hLOff OR upper=lower  EXITIF lower=upper THEN  ENDEXIT  SEEK #lnPath,lower*SIZE(linRec)+2  GET #lnPath,linRec  linRecs(0):=linRec  SEEK #lnPath,upper*SIZE(linRec)+2  GET #lnPath,linRec  linRecs(1):=linRec  linRef:=linRefs(lower)  linRefs(lower):=linRefs(upper)  linRefs(upper):=linRef  linRec:=linRecs(0)  linRecs(0):=linRecs(1)  linRecs(1):=linRec  SEEK #lnPath,lower*SIZE(linRec)+2  linRec:=linRecs(0)  PUT #lnPath,linRec  SEEK #lnPath,upper*SIZE(linRec)+2  linRec:=linRecs(1)  PUT #lnPath,linRec  lower:=lower+1 \REM prepare for postinc  EXITIF lower=upper THEN  ENDEXITENDLOOPIF lower<>top THEN  IF linRefs(lower).hLOff<>linRefs(top).hLOff THEN    SEEK #lnPath,lower*SIZE(linRec)+2    GET #lnPath,linRec    linRecs(0):=linRec    SEEK #lnPath,top*SIZE(linRec)+2    GET #lnPath,linRec    linRecs(1):=linRec    linRef:=linRefs(lower)    linRefs(lower):=linRefs(top)    linRefs(top):=linRef    linRec:=linRecs(0)    linRecs(0):=linRecs(1)    linRecs(1):=linRec    SEEK #lnPath,lower*SIZE(linRec)+2    linRec:=linRecs(0)    PUT #lnPath,linRec    SEEK #lnPath,top*SIZE(linRec)+2    linRec:=linRecs(1)    PUT #lnPath,linRec  ENDIFENDIFIF bottom<lower-1 THEN  RUN lSort(er,which,lnPath,bottom,lower-1,linRefs)ENDIFIF lower+1<top THEN  RUN lSort(er,which,lnPath,lower+1,top,linRefs)ENDIFEND10 er:=ERRENDPROCEDURE Alert(* Colors *)TYPE COLR=white,blue,black,green,red,yellow,magenta,cyan,white2,blue2,black2,green2,red2,yellow2,magenta2,cyan2:BYTEPARAM alertNum,options(26):BYTE; proc:STRING[80]; color:COLRBASE 0RUN GFX2("OWSET",1,18,5,44,6,options(3),options(4))PRINT #2, " Alert";RUN GFX2("OWSET",1,19,6,42,4,options(6),color.red)IF alertNum=1 THEN  PRINT #2, " No Path/Filename Specified!"ELSE IF alertNum=2 THEN  PRINT #2, " The specified file is not executable!"ELSE IF alertNum=3 THEN  PRINT #2, " This module is not I-Code!"ENDIF \ENDIF \ENDIFPRINT #2, " Enter filename ([ENTER] to exit decode)"PRINT #2, ">";RUN GFX2("OWSET",1,20,8,40,1,options(8),options(7))proc:=""RUN GFX2("CURON")INPUT "",procRUN GFX2("CUROFF")RUN GFX2("OWEND")RUN GFX2("OWEND")RUN GFX2("OWEND")IF proc="" THEN  alertNum:=0ENDIFEND