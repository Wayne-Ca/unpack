PROCEDURE unpack (* Header Type and Variable *) (* sb        = Sync Bytes *) (* ms        = Module Size *) (* mno       = Module Name Offset Address *) (* tl        = Type/Language Code *) (* ar        = Attributes/Revision Code *) (* hp        = Header Parity *) (* eo        = Execution Offset Address *) (* pss       = Permanent Storage Size *) (* sto       = Symbol Table Offset Address *) (* dao       = Description Area Offset Address *) (* pd        = Procedure Data Size *) (* dso       = First Data Statement Offset *) (* xso       = First Exec Statement Offset *) (* ps        = Procedure Status *) (* mnl       = Module Name Length *) (* name      = Procedure Name *) TYPE HEAD=sb,ms,mno:INTEGER; tl,ar,hp:BYTE; eo,pss,sto,dao,pd,dso,eso:INTEGER; ps,mnl:BYTE; name:STRING DIM header:HEAD (* Module Name Length = oeo-ono *) TYPE OHEAD=osb,oms,ono:INTEGER; otl,oar,ohp:BYTE; oeo,opss:INTEGER; oname:STRING DIM oheader:OHEAD (* cc        = Carry Code *) (* a         = A Register *) (* b         = B Register *) (* dp        = Data Pointer *) (* x         = X Register *) (* y         = Y regsister *) (* u         = U Register *) (* Registers Type and Variable *) TYPE REG=cc,a,b,dp:BYTE; x,y,u:INTEGER DIM regs:REG (* filepath  = path number for infile *) (* outpath   = path number for outfile *) (* callcode  = callcode number for SysCalls *) (* char      = value of character read *) (* packet    = status packet for determining pause on/off *) DIM filepath,outpath,callcode,char,packet(32):BYTE (* maxdata   = maximum data space requirements for current module *) (* er        = error number variable *) (* modsiz    = size of current module (INTEGER value) *) (* count     = counter variable *) (* counter   = counter variable *) DIM maxdata,er,modsiz,count,counter,tpVars:INTEGER (* filesize  = size of file *) (* modsize   = size of current module (REAL value) *) (* execoff   = execution offset of current module *) (* dataoff   = offset of first data statement in current module *) DIM filesize,modsize,execoff,dataoff:REAL (* start     = start position of current module *) (* symtabOff = position of the Symbol Table *) (* descOff   = position of the Description Area *) (* pointer   = pointer to current position in module *) DIM start,symtabOff,descOff,pointer:REAL (* nono      = Protected Module Flag *) (* fileopen  = InFile path open flag *) (* outexists = OutFile exists flag *) (* verbose   = print output to StdOut flag *) (* outfile   = suppress output file flag *) (* ppause    = page pause on flag *) (* skipped   = skip module if not I-Code *) DIM nono,fileopen,outexists,verbose,outfile,ppause,skipped:BOOLEAN (* version   = current version number *) DIM version:STRING[10] (* part      = modname for program sections *) DIM part:STRING[11] (* dataDir   = Data Dire4ctory *) DIM dataDir:STRING[16] (* modname   = current module name *) (* outname   = current module's output modname *) DIM filename,modname,outname:STRING[29] (* format    = format string for PRINT USING *) DIM format:STRING[50] (* file      = pathname passed in infile stored in this variable *) DIM file:STRING[80]  (* ********** *) (* Parameters *) (* infile    = pathname passed to DCom *) (* option    = -V(v) for Verbose *) (*             -O(o) for No Output File *) PARAM infile:STRING[80]; option:STRING[2]  (* **************** *) (* Start of Program *) (* Preliminary initialization of variables *) version:=" 01.00.00 " dataDir:="/DD/DATA/UNPACK/" nono:=TRUE fileopen:=FALSE outexists:=FALSE verbose:=FALSE outfile:=TRUE ppause:=FALSE skipped:=FALSE start:=0 er:=0  (* Error Trap to bypass option when not needed *) ON ERROR GOTO 10 (* Check for -V(v) option *) IF SUBSTR(option,"-V-v")>0 THEN   verbose:=TRUE ENDIF (* Check for -O(o) option *) IF SUBSTR(option,"-O-o")>0 THEN   verbose:=TRUE   outfile:=FALSE ENDIF  (* Error Trap to control no parameter *) 10 ON ERROR GOTO 20 (* Check for pathname parameter *) file:=infile IF SUBSTR("/",file)>0 THEN   char:=LEN(file)   REPEAT   char:=char-1   UNTIL MID$(file,char,1)="/"   filename:=RIGHT$(file,LEN(file)-char) ENDIF (* Check for '-' or '?' or ' ' as first character of pathname *) IF SUBSTR("-?",file)>0 THEN 20  (* Main Error Trap *) ON ERROR GOTO 100 (* Establish path to pathname *) OPEN #filepath,file:READ fileopen:=TRUE  (* Check for page pause on *) callcode:=$8D regs.a:=2 regs.b:=$00 regs.x:=ADDR(packet) RUN SysCall(callcode,regs) IF packet(8)=1 THEN   ppause:=TRUE   (* Turn Pause Off *)   GOSUB 40 ENDIF GOSUB 50 \REM turn cursor off  (* Get filesize *) regs.a:=filepath regs.b:=$02 RUN SysCall(callcode,regs) filesize:=regs.x*65536.+regs.u  (* Main Loop *) WHILE NOT(EOF(#filepath)) DO EXITIF start=filesize THEN ENDEXIT   IF start<filesize THEN     SEEK #filepath,start     modname:=""     (* Read Module Header *)     pointer:=start+24     GET #filepath,header     (* Get Module Size *)     modsiz:=header.ms     modsize:=start+modsiz     (* Get Execution Offset *)     execoff:=header.eo     (* Get Permanent Storage Size *)     maxdata:=header.pss     (* Get 1st Data Statement Offset *)     dataoff:=header.dso     (* Check for Executable Module *)     IF header.sb<>$87CD THEN       PRINT #2,filename; " is NOT EXECUTABLE!"       IF ppause THEN         (* Turn Pause On *)         GOSUB 30       ENDIF       END     ENDIF     (* Get Module Name *)     char:=LAND(ASC(MID$(header.name,header.mnl,1)),$7F)     modname:=LEFT$(header.name,header.mnl-1)+CHR$(char)     count:=1     FOR counter:=1 TO LEN(modname)       count:=count+1       IF count=2 THEN         count:=0       ENDIF     NEXT counter !    pointer:=pointer+header.mnl     (* Check for I-Code Module *)     IF header.tl=$00 AND header.hp=$00 THEN       PRINT #2,modname; " is an UNPACKED I-CODE MODULE!"     ELSE       IF header.tl<>$22 THEN         SEEK #filepath,start         GET #filepath,oheader         SEEK #filepath,start+oheader.ono         GET #filepath,oheader.oname         modname:=""         counter:=0         REPEAT           counter:=counter+1           IF ASC(MID$(oheader.oname,counter,1))<$80 THEN             modname:=modname+MID$(oheader.oname,counter,1)           ELSE             modname:=modname+CHR$(LAND(ASC(MID$(oheader.oname,counter,1)),$7F))           ENDIF         UNTIL ASC(MID$(oheader.oname,counter,1))>$7F         modsiz:=oheader.oms         PRINT #2,modname; " is NOT I-CODE!"         PRINT #2,"Skipping"         start:=start+modsiz         skipped:=TRUE       ENDIF     ENDIF     IF NOT(skipped) THEN       (* Get Start of the I-Code Area *)       execoff:=start+header.eo       (* Get Start of the Symbol Table *)       symtabOff:=start+header.sto       (* Get Start of the Description Area *)       descOff:=start+header.dao !      pointer:=pointer+1       (* If new module, create '.B09' outfile *)       outname:=modname+".B09"       IF outfile THEN         CREATE #outpath,outname:WRITE         outexists:=TRUE       ENDIF       (* Set and print PROCEDURE format *)       format:="PROCEDURE "+modname       PRINT format       PRINT "(* ===== UNPACK BASIC09 I-CODE DECODER ===== *)"       IF outfile THEN         PRINT #outpath,format         PRINT #outpath,"(* ===== UNPACK BASIC09 I-CODE DECODER ===== *)"       ENDIF       pointer:=execoff        (* Load part 1 *)       part:="udecode"       RUN part(filepath,er,tpVars,fileopen,verbose,execoff,descOff,symtabOff,dataDir,modname)       KILL part       SHELL "UnLink lSort"       IF er>0 THEN 100        (* Load part 2 *)       part:="udefVars"       RUN part(filePath,er,tpVars,fileopen,verbose,modsize,execoff,descOff,symtabOff,dataDir)       KILL part       SHELL "UnLink vSort"       SHELL "UnLink fSort"       IF er>0 THEN 100        (* Load part 3 *)       part:="ubuildSrc"       RUN part(filepath,outPath,er,maxdata,fileopen,verbose,descOff,symtabOff,dataDir,outname)       KILL part       SHELL "UnLink dsSort"       IF er>0 THEN 100        (* Load part 4 *) !      SHELL "Load uinstruction" !      part:="uinstruction" !      RUN part(filepath,outpath,er,execoff,data1,start,verbose,outfile) !      KILL part !      IF er>0 THEN 100 !      SHELL "UnLink uDRPN" !      SHELL "UnLink uHex"        (* Print End of Module *)       format:="s3<,s"+STR$((41-LEN(modname))/2-3)+"<,s5^,s"+STR$(LEN(modname)+1)+"<,s"+STR$((41-LEN(modname))/2-(3-count))+">,s3>"       IF verbose THEN         PRINT USING format,"(*","==================","END",modname,"==================","*)"       ENDIF       IF outfile THEN         PRINT #outpath USING format,"(*","==================","END",modname,"==================","*)"       ENDIF       pointer:=start+modsize       IF outfile THEN         CLOSE #outpath         outexists:=FALSE       ENDIF       start:=start+modsiz !      start:=pointer     ENDIF     skipped:=FALSE   ENDIF ENDWHILE (* Close Paths *) IF fileopen THEN   CLOSE #filepath ENDIF GOSUB 60 \REM turn cursor on  (* Unlink Existing Modules *) !IF er>0 AND er<>216 AND er<>218 THEN !  IF part="DData1" OR part="DData2" OR part="DComplex" OR part="DVars" THEN !    SHELL "UnLink DData1" !  ENDIF !  IF part="DMatch" OR part="DSort" OR part="DTypes" THEN !    SHELL "UnLink DMatch" !  ENDIF !  IF part="DLNums" OR part="DPrint" THEN !    SHELL "UnLink DLNums" !  ENDIF !  IF part="DInstr" THEN !    SHELL "UnLink DInstr" !  ENDIF !ENDIF  (* If pause was on, turn back on *) IF ppause THEN   GOSUB 30 ENDIF END  (* Help *) 20 PRINT #2 PRINT #2," Unpack - Basic09 I-Code Decoder - Version"; version PRINT #2," Copyright (c) 2025 by Wayne Campbell" PRINT #2," All Rights Reserved" PRINT #2 PRINT #2," Syntax: unpack pathname [options]" PRINT #2,"         unpack -  (Displays This Help" PRINT #2,"         unpack ?  (Displays This Help" PRINT #2,"         unpack -? (Displays This Help" PRINT #2,"         unpack    (Displays This Help" PRINT #2 PRINT #2," Where: options (Optional)" PRINT #2,"        -v = Verbose Mode (Dupe Output to StdOut)" PRINT #2,"        -o = StdOut Mode  (Suppress Output Fie, Output to StdOut Only)" PRINT #2 PRINT #2," And:" PRINT #2,"  pathname = pathlist/filename to be decoded (up to 80 chars)" IF fileopen THEN   CLOSE #filepath ENDIF END  (* Turn Pause On *) 30 packet(8):=1 callcode:=$8E regs.a:=2 regs.b:=$00 regs.x:=ADDR(packet) RUN SysCall(callcode,regs) RETURN  (* Turn Pause Off *) 40 packet(8):=0 callcode:=$8E regs.a:=2 regs.b:=$00 regs.x:=ADDR(packet) RUN SysCall(callcode,regs) RETURN  50 RUN GFX2("CUROFF") \ RETURN 60 RUN GFX2("CURON") \ RETURN  (* Primary Error Trap *) 100 IF er=0 THEN   er:=ERR ENDIF IF er=216 THEN   PRINT #2   PRINT #2," File Not Found!" ENDIF IF er=218 THEN   PRINT #2   PRINT #2,outname; " Already Exists!" ENDIF IF fileopen THEN   CLOSE #filepath ENDIF (* Print error here *) IF er>0 THEN   PRINT #2   PRINT #2,"ERROR #"; er   GOSUB 60 ENDIF END