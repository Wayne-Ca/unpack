PROCEDURE unpack TYPE HEAD=sb,ms,mno:INTEGER; tl,ar,hp:BYTE; eo,pss,sto,dao,pd,dso,eso:INTEGER; ps,mnl:BYTE; name:STRING DIM header:HEAD (* Module Name Length = oeo-ono *) TYPE OHEAD=osb,oms,ono:INTEGER; otl,oar,ohp:BYTE; oeo,opss:INTEGER; oname:STRING DIM oheader:OHEAD (* Registers Type and Variable *) TYPE REG=cc,a,b,dp:BYTE; x,y,u:INTEGER DIM regs:REG (* filePath  = path number for infile *) (* outPath   = path number for outFile *) (* callCode  = callCode number for SysCalls *) (* char      = value of character read *) (* packet    = status packet for determining pause on/off *) DIM filePath,outPath,callCode,char,packet(32):BYTE (* maxData   = maximum data space requirements for current module *) (* er        = error number variable *) (* modSiz    = size of current module (INTEGER value) *) (* count     = counter variable *) (* counter   = counter variable *) DIM maxData,er,modSiz,count,counter,tpVars:INTEGER (* fileSize  = size of file *) (* modSize   = size of current module (REAL value) *) (* execOff   = execution offset of current module *) (* dataOff   = offset of first data statement in current module *) DIM fileSize,modSize,execOff,dataOff:REAL (* start     = start position of current module *) (* symTabOff = position of the Symbol Table *) (* descOff   = position of the Description Area *) (* pointer   = pointer to current position in module *) DIM start,symTabOff,descOff,pointer:REAL (* fileOpen  = InFile path open flag *) (* outExists = OutFile exists flag *) (* verbose   = print output to StdOut flag *) (* outOpen   = suppress output file flag *) (* pPause    = page pause on flag *) (* skipped   = skip module if not I-Code *) DIM fileOpen,outExists,verbose,outOpen,pPause,skipped:BOOLEAN (* version   = current version number *) DIM version:STRING[10] (* part      = modName for program sections *) DIM part:STRING[12] (* dataDir   = Data Dire4ctory *) DIM dataDir:STRING[16] (* modName   = current module name *) (* outFile   = current module's output modName *) DIM fileName,modName,outFile:STRING[29] (* format    = format string for PRINT USING *) DIM format:STRING[50] (* file      = pathname passed in infile stored in this variable *) DIM file:STRING[80]  (* ********** *) (* Parameters *) (* infile    = pathname passed to DCom *) (* option    = -V(v) for Verbose *) (*             -O(o) for No Output File *) PARAM infile:STRING[80]; option:STRING[2]  (* **************** *) (* Start of Program *) (* Preliminary initialization of variables *) version:=" 01.00.00 " dataDir:="/DD/DATA/UNPACK/" part:="" fileOpen:=FALSE outExists:=TRUE verbose:=FALSE outOpen:=FALSE pPause:=FALSE skipped:=FALSE start:=0 er:=0  (* Error Trap to bypass option when not needed *) ON ERROR GOTO 10 (* Check for -V(v) option *) IF SUBSTR(option,"-V-v")>0 THEN   verbose:=TRUE   outExists:=TRUE ENDIF (* Check for -O(o) option *) IF SUBSTR(option,"-O-o")>0 THEN   verbose:=TRUE   outExists:=FALSE ENDIF  (* Error Trap to control no parameter *) 10 ON ERROR GOTO 20 (* Check for pathname parameter *) file:=infile IF SUBSTR("/",file)>0 THEN   char:=LEN(file)   REPEAT   char:=char-1   UNTIL MID$(file,char,1)="/"   fileName:=RIGHT$(file,LEN(file)-char) ENDIF (* Check for '-' or '?' or ' ' as first character of pathname *) IF SUBSTR("-?",file)>0 THEN 20  (* Main Error Trap *) ON ERROR GOTO 100 (* Establish path to pathname *) OPEN #filePath,file:READ fileOpen:=TRUE  (* Check for page pause on *) callCode:=$8D regs.a:=2 regs.b:=$00 regs.x:=ADDR(packet) RUN SysCall(callCode,regs) IF packet(8)=1 THEN   pPause:=TRUE   (* Turn Pause Off *)   GOSUB 40 ENDIF GOSUB 50 \REM turn cursor off  (* Get file size *) regs.a:=filePath regs.b:=$02 RUN SysCall(callCode,regs) fileSize:=regs.x*65536.+regs.u  (* Main Loop *) WHILE NOT(EOF(#filePath)) DO EXITIF start=fileSize THEN ENDEXIT   IF start<fileSize THEN     SEEK #filePath,start     modName:=""     (* Read Module Header *)     pointer:=start+24     GET #filePath,header     (* Get Module Size *)     modSiz:=header.ms     modSize:=start+modSiz     (* Get Execution Offset *)     execOff:=header.eo     (* Get Permanent Storage Size *)     maxData:=header.pss     (* Get 1st Data Statement Offset *)     dataOff:=header.dso     (* Check for Executable Module *)     IF header.sb<>$87CD THEN       PRINT #2,fileName; " is NOT EXECUTABLE!"       IF pPause THEN         (* Turn Pause On *)         GOSUB 30       ENDIF       END     ENDIF     (* Get Module Name *)     char:=LAND(ASC(MID$(header.name,header.mnl,1)),$7F)     modName:=LEFT$(header.name,header.mnl-1)+CHR$(char)     count:=1     FOR counter:=1 TO LEN(modName)       count:=count+1       IF count=2 THEN         count:=0       ENDIF     NEXT counter !    pointer:=pointer+header.mnl     (* Check for I-Code Module *)     IF header.tl=$00 AND header.hp=$00 THEN       PRINT #2,modName; " is an UNPACKED I-CODE MODULE!"     ELSE       IF header.tl<>$22 THEN         SEEK #filePath,start         GET #filePath,oheader         SEEK #filePath,start+oheader.ono         GET #filePath,oheader.oname         modName:=""         counter:=0         REPEAT           counter:=counter+1           IF ASC(MID$(oheader.oname,counter,1))<$80 THEN             modName:=modName+MID$(oheader.oname,counter,1)           ELSE             modName:=modName+CHR$(LAND(ASC(MID$(oheader.oname,counter,1)),$7F))           ENDIF         UNTIL ASC(MID$(oheader.oname,counter,1))>$7F         modSiz:=oheader.oms         PRINT #2,modName; " is NOT I-CODE!"         PRINT #2,"Skipping"         start:=start+modSiz         skipped:=TRUE       ENDIF     ENDIF     IF NOT(skipped) THEN       (* Get Start of the I-Code Area *)       execOff:=start+header.eo       (* Get Start of the Symbol Table *)       symTabOff:=start+header.sto       (* Get Start of the Description Area *)       descOff:=start+header.dao !      pointer:=pointer+1       (* If new module, create '.B09' outFile *)       outFile:=modName+".B09"       IF outExists THEN         CREATE #outPath,outFile:WRITE         outOpen:=TRUE       ENDIF       (* Set and print PROCEDURE format *)       format:="PROCEDURE "+modName       PRINT format       PRINT "(* ===== UNPACK BASIC09 I-CODE DECODER ===== *)"       IF outOpen THEN         PRINT #outPath,format         PRINT #outPath,"(* ===== UNPACK BASIC09 I-CODE DECODER ===== *)"       ENDIF       pointer:=execOff        (* Load part 1 *)       part:="udecode"       RUN part(filePath,er,tpVars,verbose,execOff,descOff,symTabOff,dataOff,dataDir,modName)       KILL part       SHELL "ex UnLink ulSort"       IF er>0 THEN 100        (* Load part 2 *)       part:="udefVars"       RUN part(filePath,er,tpVars,verbose,modSize,execOff,descOff,symTabOff,dataDir)       KILL part       SHELL "ex UnLink uvSort"       IF er>0 THEN 100        (* Load part 3 *)       part:="usymTabVal"       RUN part(filePath,er,verbose,modSize,symTabOff,dataDir)       KILL part       IF er>0 THEN 100        (* Load part 4 *)       part:="ubuildSrc"       RUN part(filePath,outPath,er,maxData,outExists,verbose,descOff,symTabOff,dataDir,outFile)       KILL part       SHELL "ex UnLink udsSort"       IF er>0 THEN 100        (* Load part 5 *)       part:="uinstruction"       RUN part(filePath,outPath,er,outExists,verbose,execOff,descOff,dataOff,dataDir)       KILL part       SHELL "ex UnLink uDRPN"       SHELL "ex UnLink uhex$"       IF er>0 THEN 100        (* Print End of Module *)       format:="s3<,s"+STR$((41-LEN(modName))/2-3)+"<,s5^,s"+STR$(LEN(modName)+1)+"<,s"+STR$((41-LEN(modName))/2-(3-count))+">,s3>"       IF verbose THEN         PRINT USING format,"(*","==================","END",modName,"==================","*)"       ENDIF       IF outOpen THEN         PRINT #outPath USING format,"(*","==================","END",modName,"==================","*)"       ENDIF       pointer:=start+modSize       IF outOpen THEN         CLOSE #outPath         outOpen:=FALSE         outExists:=FALSE       ENDIF       start:=start+modSiz !      start:=pointer     ENDIF     skipped:=FALSE   ENDIF ENDWHILE (* Close Paths *) IF fileOpen THEN   CLOSE #filePath ENDIF GOSUB 60 \REM turn cursor on  (* Unlink Existing Modules *) !IF er>0 AND er<>216 AND er<>218 THEN !  IF part="DData1" OR part="DData2" OR part="DComplex" OR part="DVars" THEN !    SHELL "ex UnLink DData1" !  ENDIF !  IF part="DMatch" OR part="DSort" OR part="DTypes" THEN !    SHELL "ex UnLink DMatch" !  ENDIF !  IF part="DLNums" OR part="DPrint" THEN !    SHELL "ex UnLink DLNums" !  ENDIF !  IF part="DInstr" THEN !    SHELL "ex UnLink DInstr" !  ENDIF !ENDIF  (* If pause was on, turn back on *) IF pPause THEN   GOSUB 30 ENDIF END  (* Help *) 20 PRINT #2 PRINT #2," Unpack - Basic09 I-Code Decoder - Version"; version PRINT #2," Copyright (c) 2025 by Wayne Campbell" PRINT #2," All Rights Reserved" PRINT #2 PRINT #2," Syntax: unpack pathname [options]" PRINT #2,"         unpack -  (Displays This Help" PRINT #2,"         unpack ?  (Displays This Help" PRINT #2,"         unpack -? (Displays This Help" PRINT #2,"         unpack    (Displays This Help" PRINT #2 PRINT #2," Where: options (Optional)" PRINT #2,"        -v = Verbose Mode (Dupe Output to StdOut)" PRINT #2,"        -o = StdOut Mode  (Suppress Output Fie, Output to StdOut Only)" PRINT #2 PRINT #2," And:" PRINT #2,"  pathname = pathlist/fileName to be decoded (up to 80 chars)" IF fileOpen THEN   CLOSE #filePath ENDIF END  (* Turn Pause On *) 30 packet(8):=1 callCode:=$8E regs.a:=2 regs.b:=$00 regs.x:=ADDR(packet) RUN SysCall(callCode,regs) RETURN  (* Turn Pause Off *) 40 packet(8):=0 callCode:=$8E regs.a:=2 regs.b:=$00 regs.x:=ADDR(packet) RUN SysCall(callCode,regs) RETURN  50 RUN GFX2("CUROFF") \ RETURN 60 RUN GFX2("CURON") \ RETURN  (* Primary Error Trap *) 100 IF er=0 THEN   er:=ERR ENDIF IF er=216 THEN   PRINT #2   PRINT #2," File Not Found!" ENDIF IF er=218 THEN   PRINT #2   PRINT #2,outFile; " Already Exists!" ENDIF IF fileOpen THEN   CLOSE #filePath ENDIF (* Print error here *) IF er>0 THEN   PRINT #2, part   PRINT #2   PRINT #2,"ERROR #"; er   GOSUB 60 ENDIF END