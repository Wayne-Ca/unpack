PROCEDURE uinstruction (* Version 01.00.00 *) (* Variable Array Record *) TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGER DIM varRec(400):VREC (* Variable File Record *) TYPE VFP1=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGER TYPE VFP2=vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGER TYPE VFP3=mTyp,vLnk,fNum:BYTE; pRec,pFld:BOOLEAN TYPE VFRC= vp1:VFP1; vp2:VFP2; vp3:VFP3 DIM varFRec:VFRC (* Line Reference Record *) (* Record *) TYPE LNREC=lnRecNum,lnRefCnt:INTEGER; lnTyp:BYTE; lnOff:INTEGER; lnNum:STRING[5] DIM linRec:LNREC (* Booleans *) DIM found,nextVar,forVar,creop,hasRecords,hasLines,isRestore:BOOLEAN (* Various counters *) DIM tokenCode,tokenVal,byteVal:BYTE (* Various variables *) DIM modCnt,intVal,nextRef:INTEGER DIM varCount,varCnt:INTEGER DIM linCount,lrCnt,lnCnt,lastOff:INTEGER DIM filCnt,realVal:REAL (* File Paths *) DIM vPath,lnPath,dPath:BYTE (* File Status *) DIM vOpen,lnOpen,dOpen:BOOLEAN (* File names *) DIM version:STRING[8]; vFile,lnFile,dFile:STRING[29] (* Strings *) DIM hex:STRING[4]; lastNum:STRING[5]; tokenName:STRING[29] DIM source:STRING[512]  (* ********** *) (* Parameters *) PARAM filePath,outPath:BYTE; er:INTEGER; verbose:BOOLEAN; execOff,descOff,dataOff:REAL; dataDir:STRING[16]  (* **************** *) (* Start of Program *) (* Preliminary initialization of variables *) BASE 0 dOpen:=FALSE dFile:=dataDir+"initDB" OPEN #dPath,dFile:READ dOpen:=TRUE GET #dPath,version CLOSE #dPath dOpen:=FALSE vOpen:=FALSE \lnOpen:=FALSE \dOpen:=FALSE ON ERROR GOTO 530 vFile:=dataDir+"varDefs" lnFile:=dataDir+"linDefs" dFile:=dataDir+"procData" (* Open Procedure File *) OPEN #dPath,dFile:READ dOpen:=TRUE GET #dPath,hasRecords (* Variables lookup table *) GET #dPath,varRec CLOSE #dPath dOpen:=FALSE (* Variable Reference *) OPEN #vPath,vFile:UPDATE vOpen:=TRUE GET #vPath,varCount (* Line Reference *) OPEN #lnPath,lnFile:UPDATE lnOpen:=TRUE GET #lnPath,linCount hasLines:=FALSE IF linCount>0 THEN  GET #lnPath,linRec lastOff:=linRec.lnOff lastNum:=linRec.lnNum hasLines:=TRUE ENDIF  (* Output File *) REPEAT  SEEK #outPath,0 READ #outPath,source UNTIL EOF(#outPath) (* Instruction code section, second pass *) (* Output instructions *) IF verbose THEN  PRINT #2, "(* Source Instructions *)" ENDIF  PRINT #outPath,"(* Source Instructions *)" SEEK #filePath,execOff filCnt:=execOff \modCnt:=0 \lnCnt:=0 \forVar:=FALSE \nextVar:=FALSE REPEAT  source:="" (* Insert Line Number Here *) IF hasLines THEN  IF modCnt=lastOff THEN  REM PRINT lastNum; " "; source:=lastNum+" " IF linCount>1 THEN  REPEAT  lnCnt:=lnCnt+1 SEEK #lnPath,lnCnt*SIZE(linRec)+2 GET #lnPath,linRec UNTIL linRec.lnOff>lastOff OR lnCnt=linCount lastOff:=linRec.lnOff lastNum:=linRec.lnNum ENDIF  ENDIF  ENDIF  REPEAT  GET #filePath,tokenVal modCnt:=modCnt+1 filCnt:=filCnt+1 GOSUB 270 IF tokenName<>"" THEN  source:=source+tokenName REM PRINT tokenName; (* OPEN or CREATE statement for file mode *) IF tokenVal=$29 OR tokenVal=$2A THEN  creop:=TRUE ENDIF  (* RESTORE References *) IF tokenVal=$31 THEN  isRestore:=TRUE ENDIF  IF tokenVal=$13 OR tokenVal=$14 THEN  IF tokenVal=$13 THEN  forVar:=TRUE ELSE  nextVar:=TRUE ENDIF  GET #filePath,tokenVal modCnt:=modCnt+1 filCnt:=filCnt+1 ENDIF  IF tokenVal=$46 OR tokenVal=$47 THEN  GET #filePath,intVal modCnt:=modCnt+2 filCnt:=filCnt+2 ENDIF  ENDIF  (* Variable References *) IF tokenVal=$55 OR tokenVal=$11 OR tokenVal=$16 OR tokenVal=$1A OR tokenVal=$1C THEN  GET #filePath,intVal modCnt:=modCnt+2 filCnt:=filCnt+2 ENDIF  IF nextVar THEN  FOR nextRef:=1 TO 4 GET #filePath,intVal modCnt:=modCnt+2 filCnt:=filCnt+2 IF nextRef=1 THEN  GOSUB 210 source:=source+tokenName REM PRINT tokenName; ENDIF  NEXT nextRef nextVar:=FALSE ENDIF  IF tokenVal=$23 OR tokenVal>=$80 AND tokenVal<=$8C OR tokenVal>=$F2 AND tokenVal<=$F9 THEN  GET #filePath,intVal modCnt:=modCnt+2 filCnt:=filCnt+2 GOSUB 210 tokenName:="�"+tokenName source:=source+tokenName REM PRINT tokenName; ELSE  (* Literals *) IF tokenVal>=$8D AND tokenVal<=$91 AND tokenVal<>$90 THEN  (* BYTE Literals *) IF tokenVal=$8D THEN  GET #filePath,byteVal modCnt:=modCnt+1 filCnt:=filCnt+1 source:=source+"�"+STR$(byteVal) REM PRINT #2, "�"; byteVal; ELSE  (* REAL Literals *) IF tokenVal=$8F THEN  GET #filePath,realVal modCnt:=modCnt+5 filCnt:=filCnt+5 source:=source+"�"+STR$(realVal) REM PRINT #2, "�"; realVal; ELSE  (* INTEGER and HEX Literals *) GET #filePath,intVal modCnt:=modCnt+2 filCnt:=filCnt+2 IF tokenVal=$91 THEN  RUN uhex$(intVal,hex) source:=source+hex REM PRINT hex; ELSE  source:=source+"�"+STR$(intVal) REM PRINT #2, "�"; intVal; ENDIF  ENDIF  ENDIF  ELSE  (* String Literals *) IF tokenVal=$90 THEN  REPEAT  GET #filePath,byteVal modCnt:=modCnt+1 filCnt:=filCnt+1 IF byteVal=$FF THEN  tokenVal:=byteVal GOSUB 270 source:=source+tokenName REM PRINT tokenName; ELSE  IF byteVal>=$20 THEN  IF byteVal=$AE THEN  source:=source+"�" \REM $BE ELSE  source:=source+CHR$(byteVal) ENDIF  REM PRINT CHR$(byteVal); ENDIF  ENDIF  UNTIL byteVal=$FF ELSE  (* Line References *) IF tokenVal=$20 OR tokenVal=$22 OR tokenVal=$3B THEN  GET #filePath,intVal modCnt:=modCnt+2 filCnt:=filCnt+2 IF isRestore AND tokenVal=$3B THEN  IF intVal<>dataOff THEN  GOSUB 230 source:=source+linRec.lnNum REM PRINT linRec.lnNum; ENDIF  ELSE  GOSUB 230 source:=source+linRec.lnNum REM PRINT linRec.lnNum; ENDIF  ENDIF  ENDIF  ENDIF  ENDIF  (* Get File Open/Create Mode *) IF tokenVal=$4A AND creop THEN  GET #filePath,byteVal modCnt:=modCnt+1 filCnt:=filCnt+1 RESTORE 280 REPEAT  READ tokenCode,tokenName UNTIL tokenCode=byteVal OR tokenCode=0 source:=source+tokenName REM PRINT tokenName; creop:=FALSE ENDIF  (* End of Instruction Statement *) UNTIL tokenVal=$3E OR tokenVal=$3F  IF forVar THEN  forVar:=FALSE ENDIF  IF isRestore THEN  isRestore:=FALSE ENDIF  RUN uDRPN(source) IF verbose THEN  PRINT #2, source ENDIF  PRINT #outPath,source (* End of Instruction Code Section *) UNTIL modCnt=descOff-execOff (* Close Files *) CLOSE #vPath vOpen:=FALSE CLOSE #lnPath lnOpen:=FALSE (* Display Completion Time *) PRINT #2,"Done!";  (* End of Program *) END   (* Subroutines *) (* Find Variable Reference *) 210 varCnt:=0 \found:=FALSE REPEAT  IF varRec(varCnt).vTyp=tokenVal AND varRec(varCnt).vOff=intVal THEN SEEK #vPath,varCnt*SIZE(varFRec)+2 GET #vPath,varFRec found:=TRUE tokenName:=varFRec.vp2.vName IF SUBSTR(LEFT$(tokenName,1),"birlsc")>0 AND varRec(varCnt).nTyp<3 THEN  tokenName:="."+tokenName ENDIF  ENDIF  varCnt:=varCnt+1 UNTIL found OR varCnt=varCount RETURN (* Find Line Number *)  230 lrCnt:=0 REPEAT  SEEK #lnPath,lrCnt*SIZE(linRec)+2 GET #lnPath,linRec lrCnt:=lrCnt+1 UNTIL linRec.lnOff=intVal OR lrCnt=linCount RETURN   (* Read Keyword Tokens *) 270 RESTORE 275 REPEAT  READ tokenCode,tokenName UNTIL tokenCode=tokenVal OR tokenCode=0 RETURN   (* Keyword/Token Data *) 275 DATA $04,"DATA ",$05,"STOP",$06,"BYE",$07,"TRON",$08,"TROFF",$09,"PAUSE" DATA $0A,"DEG",$0B,"RAD",$0C,"RETURN",$0D,"LET ",$0F,"POKE ",$10,"IF " DATA $11,"ELSE ",$12,"ENDIF",$13,"FOR ",$14,"NEXT ",$15,"WHILE ",$16,"ENDWHILE" DATA $17,"REPEAT",$18,"UNTIL ",$19,"LOOP",$1A,"ENDLOOP",$1B,"EXITIF " DATA $1C,"ENDEXIT",$1D,"ON ",$1E,"ERROR",$20,"� GOTO ",$22,"� GOSUB ",$23,"RUN " DATA $24,"KILL ",$25,"INPUT ",$26,"PRINT #2, ",$27,"CHD ",$28,"CHX ",$29,"CREATE " DATA $2A,"OPEN ",$2B,"SEEK ",$2C,"READ ",$2D,"WRITE ",$2E,"GET ",$2F,"PUT " DATA $30,"CLOSE ",$31,"RESTORE ",$32,"DELETE ",$33,"CHAIN ",$34,"SHELL " DATA $35,"BASE 0",$36,"BASE 1",$39,"END",$3E,"� \",$45,"� THEN ",$46,"� TO " DATA $47,"� STEP ",$48,"� DO",$49,"� USING ",$4A,"�:",$4B,"�,",$4D,"�(",$4E,"�)" DATA $51,"�; ",$52,"�:=",$53,"�.=",$54,"�#",$90,"�""",$91,"�$",$92,"�ADDR()" DATA $94,"�SIZE()",$96,"�POS",$97,"�ERR",$98,"�MOD(,)",$99,"�MOD(,)" DATA $9A,"�RND()",$9B,"�PI",$9C,"�SUBSTR(,)",$9D,"�SGN()",$9E,"�SGN()" DATA $9F,"�SIN()",$A0,"�COS()",$A1,"�TAN()",$A2,"�ASN()",$A3,"�ACS()" DATA $A4,"�ATN()",$A5,"�EXP()",$A6,"�ABS()",$A7,"�ABS()",$A8,"�LOG()" DATA $A9,"�LOG10()",$AA,"�SQRT()",$AC,"�INT()",$AD,"�INT()",$AE,"�FIX()" DATA $AF,"�FIX()",$B0,"�FLOAT()",$B1,"�FLOAT()",$B2,"�SQ()",$B3,"�SQ()" DATA $B4,"�PEEK()",$B5,"�LNOT()",$B6,"�VAL()",$B7,"�LEN()",$B8,"�ASC()" DATA $B9,"�LAND(,)",$BA,"�LOR(,)",$BB,"�LXOR(,)",$BC,"�TRUE",$BD,"�FALSE" DATA $BE,"�EOF()",$BF,"�TRIM$()",$C0,"�MID$(,,)",$C1,"�LEFT$(,)" DATA $C2,"�RIGHT$(,)",$C3,"�CHR$()",$C4,"�STR$()",$C5,"�STR$()",$C6,"�DATE$" DATA $C7,"�TAB()",$CD,"�NOT()",$CE,"� - ",$CF,"� - ",$D0,"� AND ",$D1,"� OR ",$D2,"� XOR " DATA $D3,"�>",$D4,"�>",$D5,"�>",$D6,"�<",$D7,"�<",$D8,"�<",$D9,"�<>",$DA,"�<>",$DB,"�<>" DATA $DC,"�<>",$DD,"�=",$DE,"�=",$DF,"�=",$E0,"�=",$E1,"�>=",$E2,"�>=",$E3,"�>=",$E4,"�<=" DATA $E5,"�<=",$E6,"�<=",$E7,"�+",$E8,"�+",$E9,"�+",$EA,"�-",$EB,"�-",$EC,"�*" DATA $ED,"�*",$EE,"�/",$EF,"�/",$F0,"�^",$F1,"�**",$FF,"""",$00,""  (* File Mode Keywords *) 280 DATA $01,"READ",$02,"WRITE",$03,"UPDATE",$04,"EXEC",$05,"READ+EXEC" DATA $06,"WRITE+EXEC",$07,"UPDATE+EXEC",$80,"DIR",$81,"READ+DIR" DATA $82,"WRITE+DIR",$83,"UPDATE+DIR",$84,"EXEC+DIR" DATA $85,"READ+EXEC+DIR",$86,"WRITE+EXEC+DIR",$87,"UPDATE+EXEC+DIR" DATA $00,""  (* Error Trap *) 530 er:=ERR IF lnOpen THEN  CLOSE #lnPath lnOpen:=FALSE ENDIF  IF dOpen THEN  CLOSE #dPath dOpen:=FALSE ENDIF  PRINT #2,er END PROCEDURE uhex$ (* intVal = integer intVal *) (* hex   = hex string *) PARAM intVal:INTEGER; hex:STRING[4] (* index      = counter *) (* hex_index  = counter for DATA read *) (* bit        = mask integer *) (* bit_result = result of LAND *) (* hex_result = result of nybble *) DIM index,hex_index,bit,bit_result,hex_result:INTEGER (* hex_bit = hex intVal string character *) DIM hex_bit:STRING[1]  ON ERROR GOTO 1 hex:="" bit:=1 hex_result:=0  hex_result=LAND(15,intVal) GOSUB 2 hex_result:=LAND($F0,intVal)/16 GOSUB 2 hex_result:=LAND($0F00,intVal)/256 GOSUB 2 hex_result=LAND($7000,intVal)/$1000 IF intVal<0 THEN  hex_result:=hex_result+8 ENDIF  GOSUB 2 (* If the first two characters are 0's, remove them *) IF LEFT$(hex,2)="00" THEN  hex:=RIGHT$(hex,2) ENDIF  1 END   (* Read hex intVal character *) 2 hex_result:=hex_result+48 IF hex_result>57 THEN  hex_result:=hex_result+7 ENDIF  hex_bit:=CHR$(hex_result) hex:=hex_bit+hex hex_result:=0 RETURN PROCEDURE uDRPN (* templine = work array for line parsing *) DIM templine(10):STRING[400] (* ********** *) (* Parameters *) (* outfilePath = output filePath *) (* er      = error number variable *) (* verbose = BOOLEAN for duped output to stdout *) (* nofile  = BOOLEAN for no output file *) (* inline  = line to be parsed *) REM PARAM outfilePath:BYTE; er:INTEGER; verbose,nofile:BOOLEAN; inline:STRING[512] PARAM inline:STRING[512] (* place  = pointer to current character in inline *) (* length = length of inline *) (* count  = counter variable *) (* cntr   = counter variable *) (* cnt    = counter variable *) DIM place,length,count,cntr,cnt:INTEGER (* parse = BOOLEAN for determining need of parsing *) DIM parse:BOOLEAN (* char = current character of inline *) DIM char:STRING[1] (* outline = output line *) DIM outline:STRING[512] (* **************** *) (* Start of Program *) (* Error Trap *) ON ERROR GOTO 9 (* Preliminary Initialization *) count:=0 REPEAT  count:=count+1 templine(count):="" UNTIL count=10 outline:="" (* Set line length *) length:=LEN(inline) parse:=FALSE (* If no delimiters, just print the line *) IF SUBSTR("�",inline)=0 THEN  GOSUB 8 END  ELSE  (* Check for operators *) IF SUBSTR("�-",inline)>0 OR SUBSTR("+",inline)>0 OR SUBSTR("*",inline)>0 OR SUBSTR("/",inline)>0 THEN  GOSUB 2 ENDIF  IF SUBSTR("()",inline)>0 OR SUBSTR("(,)",inline)>0 OR SUBSTR("(,,)",inline)>0 OR SUBSTR(" - ",inline)>0 THEN  GOSUB 2 ENDIF  IF SUBSTR("**",inline)>0 OR SUBSTR("^",inline)>0 OR SUBSTR("� AND ",inline)>0 OR SUBSTR("� OR ",inline)>0 OR SUBSTR("� XOR ",inline)>0 THEN  GOSUB 2 ENDIF  IF SUBSTR("<",inline)>0 OR SUBSTR(">",inline)>0 OR SUBSTR("<=",inline)>0 THEN  GOSUB 2 ENDIF  IF SUBSTR(">=",inline)>0 OR SUBSTR("�=",inline)>0 OR SUBSTR("<>",inline)>0 THEN  GOSUB 2 ENDIF  (* If no operators, strip the delimiters and print *) IF NOT(parse) THEN  GOSUB 1 ENDIF  ENDIF  END  (* Strip delimiters *) 1 place:=1 REPEAT  char:=MID$(inline,place,1) IF char<>"�" THEN  outline:=outline+char ENDIF  place:=place+1 UNTIL place=LEN(inline)+1 inline:=outline outline:="" GOSUB 8 (* For self-de-compile *) REPEAT  IF SUBSTR("�",inline)>0 THEN  place:=SUBSTR("�",inline) inline:=LEFT$(inline,place-1)+"�"+RIGHT$(inline,LEN(inline)-(place-1)) ENDIF  UNTIL SUBSTR("�",inline)=0 RETURN  (* Parse line *) 2 parse:=TRUE count:=1 (* Fill templine array *) 3 REPEAT  place:=SUBSTR("�",inline) IF place=1 THEN  inline:=RIGHT$(inline,length-1) length:=length-1 ELSE  IF place>0 THEN  templine(count):=LEFT$(inline,place-1) inline:=RIGHT$(inline,length-place) length:=length-place ELSE  templine(count):=inline inline:="" length:=0 ENDIF  count:=count+1 ENDIF  UNTIL count=11 OR length=0 (* Parse according to operator *) cntr:=1 WHILE cntr<=count-1 DO  (* Math Operators *) IF templine(cntr)="+" OR templine(cntr)="-" OR templine(cntr)="*" OR templine(cntr)="/" THEN  templine(cntr-2):="("+templine(cntr-2)+templine(cntr)+templine(cntr-1)+")" templine(cntr-1):="" templine(cntr):="" GOSUB 7 GOSUB 7 count:=count-2 cntr:=cntr-2 ENDIF  (* Powers Operators *) IF templine(cntr)="**" OR templine(cntr)="^" THEN  templine(cntr-2):="("+templine(cntr-2)+templine(cntr)+templine(cntr-1)+")" templine(cntr-1):="" templine(cntr):="" GOSUB 7 GOSUB 7 count:=count-2 cntr:=cntr-2 ENDIF  (* Equality Operators *) IF templine(cntr)=">" OR templine(cntr)="<" OR templine(cntr)="=" THEN  templine(cntr-2):="("+templine(cntr-2)+templine(cntr)+templine(cntr-1)+")" templine(cntr-1):="" templine(cntr):="" GOSUB 7 GOSUB 7 count:=count-2 cntr:=cntr-2 ENDIF  (* Equality Operators *) IF templine(cntr)=">=" OR templine(cntr)="<=" OR templine(cntr)="<>" THEN  templine(cntr-2):="("+templine(cntr-2)+templine(cntr)+templine(cntr-1)+")" templine(cntr-1):="" templine(cntr):="" GOSUB 7 GOSUB 7 count:=count-2 cntr:=cntr-2 ENDIF  (* Negation Operator *) IF templine(cntr)=" - " THEN  templine(cntr-1):="-("+templine(cntr-1)+")" templine(cntr):="" GOSUB 7 count:=count-1 cntr:=cntr-1 ENDIF  (* Logic Operators *) IF templine(cntr)=" OR " OR templine(cntr)=" AND " OR templine(cntr)=" XOR " THEN  templine(cntr-2):="("+templine(cntr-2)+templine(cntr)+templine(cntr-1)+")" templine(cntr-1):="" templine(cntr):="" GOSUB 7 GOSUB 7 count:=count-2 cntr:=cntr-2 ENDIF  (* If complex "sub-variable", and previous complex, add together *) IF cntr>1 THEN  IF LEFT$(templine(cntr-1),1)="C" OR LEFT$(templine(cntr-1),2)="PC" OR LEFT$(templine(cntr-1),2)=".c" THEN  IF LEN(templine(cntr))>1 AND SUBSTR(MID$(templine(cntr),2,1),"birlsc")>0 THEN  templine(cntr-1):=templine(cntr-1)+templine(cntr) templine(cntr):="" GOSUB 7 count:=count-1 cntr:=cntr-1 ENDIF  ENDIF  ENDIF  (* Single Dimensional Arrays *) IF RIGHT$(templine(cntr),2)="()" THEN  (* If 'whole' array, just strip parens *) IF cntr=10 THEN  IF templine(cntr-1)="," OR templine(cntr-1)="(" OR templine(cntr-1)=":=" OR templine(cntr-1)=".=" OR RIGHT$(templine(cntr-1),3)="ON " THEN  templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-2) ELSE  GOTO 4 ENDIF  ELSE  IF cntr>1 THEN  IF templine(cntr-1)="," OR templine(cntr-1)="(" OR templine(cntr-1)=":=" OR templine(cntr-1)=".=" OR RIGHT$(templine(cntr-1),3)="ON " OR templine(cntr-1)="SIZE()" THEN  templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-2) ELSE  GOTO 4 ENDIF  ELSE  IF cntr=1 THEN  templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-2) ELSE  (* If EOF then add # *) 4 IF LEFT$(templine(cntr),3)="EOF" THEN  templine(cntr-1):=LEFT$(templine(cntr),SUBSTR("(",templine(cntr)))+"#"+templine(cntr-1)+")" ELSE  templine(cntr-1):=LEFT$(templine(cntr),SUBSTR("(",templine(cntr)))+templine(cntr-1)+")" ENDIF  templine(cntr):="" GOSUB 7 count:=count-1 cntr:=cntr-1 IF LEFT$(templine(cntr),1)="." THEN  templine(cntr-1):=templine(cntr-1)+templine(cntr) templine(cntr):="" GOSUB 7 count:=count-1 cntr:=cntr-1 ENDIF  ENDIF  ENDIF  ENDIF  ENDIF  (* Two-Dimensional Arrays *) IF RIGHT$(templine(cntr),3)="(,)" THEN  (* If 'whole' array, just strip parens *) IF cntr=10 THEN  IF templine(cntr-1)="," OR templine(cntr-1)="(" OR templine(cntr-1)=":=" OR templine(cntr-1)=".=" OR RIGHT$(templine(cntr-1),3)="ON " THEN  templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-3) ELSE  GOTO 5 ENDIF  ELSE  IF cntr>1 THEN  IF templine(cntr-1)="," OR templine(cntr-1)="(" OR templine(cntr-1)=":=" OR templine(cntr-1)=".=" OR RIGHT$(templine(cntr-1),3)="ON " OR templine(cntr-1)="SIZE()" THEN  templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-3) ELSE  GOTO 5 ENDIF  ELSE  IF cntr=1 THEN  templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-3) ELSE  5 templine(cntr-2):=LEFT$(templine(cntr),SUBSTR("(",templine(cntr)))+templine(cntr-2)+","+templine(cntr-1)+")" templine(cntr-1):="" templine(cntr):="" GOSUB 7 GOSUB 7 count:=count-2 cntr:=cntr-2 IF LEFT$(templine(cntr),1)="." THEN  templine(cntr-1):=templine(cntr-1)+templine(cntr) templine(cntr):="" GOSUB 7 count:=count-1 cntr:=cntr-1 ENDIF  ENDIF  ENDIF  ENDIF  ENDIF  (* Three-Dimensional Arrays *) IF RIGHT$(templine(cntr),4)="(,,)" THEN  (* If 'whole' array, just strip parens *) IF cntr=10 THEN  IF templine(cntr-1)="," OR templine(cntr-1)="(" OR templine(cntr-1)=":=" OR templine(cntr-1)=".=" OR RIGHT$(templine(cntr-1),3)="ON " THEN  templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-4) ELSE  GOTO 6 ENDIF  ELSE  IF cntr>1 THEN  IF templine(cntr-1)="," OR templine(cntr-1)="(" OR templine(cntr-1)=":=" OR templine(cntr-1)=".=" OR RIGHT$(templine(cntr-1),3)="ON " OR templine(cntr-1)="SIZE()" THEN  templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-4) ELSE  GOTO 6 ENDIF  ELSE  IF cntr=1 THEN  templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-4) ELSE  6 templine(cntr-3):=LEFT$(templine(cntr),SUBSTR("(",templine(cntr)))+templine(cntr-3)+","+templine(cntr-2)+","+templine(cntr-1)+")" templine(cntr-2):="" templine(cntr-1):="" templine(cntr):="" GOSUB 7 GOSUB 7 GOSUB 7 count:=count-3 cntr:=cntr-3 IF LEFT$(templine(cntr),1)="." THEN  templine(cntr-1):=templine(cntr-1)+templine(cntr) templine(cntr):="" GOSUB 7 count:=count-1 cntr:=cntr-1 ENDIF  ENDIF  ENDIF  ENDIF  ENDIF  cntr:=cntr+1 ENDWHILE  (* If end of line, add templine array to outline and print *) IF length=0 THEN  cntr:=0 REPEAT  cntr:=cntr+1 outline:=outline+templine(cntr) templine(cntr):="" UNTIL cntr=10 IF LEN(outline)>256 THEN  PRINT #2 PRINT #2, "(* WARNING! Basic09 has problems with lines greater than 229 characters long!" PRINT  ENDIF  inline:=outline outline:="" GOSUB 8 ELSE  (* If not end of line, and templines empty, go get more *) IF count<10 THEN  GOTO 3 ELSE  (* If not end of line, and templines full, add first to *) (* outline, move others up one, and go get another *) IF templine(10)="" THEN 3 outline:=outline+templine(1) cntr:=0 REPEAT  cntr:=cntr+1 templine(cntr):=templine(cntr+1) UNTIL cntr=9 templine(10):="" count:=10 GOTO 3 ENDIF  ENDIF  RETURN  (* Adjust templines for gaps created by parsing *) 7 cnt:=0 REPEAT  cnt:=cnt+1 IF templine(cnt)="" THEN  templine(cnt):=templine(cnt+1) templine(cnt+1)="" ENDIF  UNTIL cnt=9 RETURN  8 IF SUBSTR(".=",inline)>0 THEN  place:=SUBSTR(".=",inline) inline:=LEFT$(inline,place-1)+RIGHT$(inline,LEN(inline)-place) ENDIF  IF LEFT$(inline,1)=" " THEN  inline:=RIGHT$(inline,LEN(inline)-1) ENDIF  IF SUBSTR("  GO",inline)>0 THEN  place:=SUBSTR("  GO",inline) inline:=LEFT$(inline,place)+RIGHT$(inline,LEN(inline)-(place+1))  ENDIF  RETURN  (* Error Trap *) 9 er:=ERR END 