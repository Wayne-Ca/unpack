PROCEDURE buildSrc(* Version 1.3.00 *)(* This version works with getHeader1, all variables DIM'd and used, 1st gap is 4 types *)(* Also works with getHeader2, one TYPE and field record commented out, 1st gap is 3 types *)(* Also works with getHeader3, one field record commented out, 1st gap is 4 types *)(* Has issue where it assignes record variable to wrong type *)(* Also works with getHeader4, field string commented out, all other variables DIM'd and used *)(* Mostly works with getHeader5, record array variable assigned to TYP9 not validating *)(* Changed gaps from gapOff, gapSize and gapValid array variables to gapRec array records *)(* Added typRec record array for TYPE identification *)(* Removed commented code for gap array variables as unneeded *)(* Declarations *)(* Variable Record *)(* Array *)TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGERDIM varRec(400):VREC(* File Record *)TYPE VFP1=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGERTYPE VFP2=vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGERTYPE VFP3=mTyp,vLnk,fNum:BYTE; pRec,pFld:BOOLEANTYPE VFRC=vp1:VFP1; vp2:VFP2; vp3:VFP3DIM varFRec,varFRec2:VFRC(* DSAT Map *)TYPE DSMP=dsOf,dsDm,dsMSz,dsSz:INTEGERDIM DSMap(100):DSMP(* Gaps Map *)TYPE GAPR=gapOff,gapSize:INTEGER; gapValid:BOOLEANDIM tmpGap(20),gapRec(20):GAPR(* TYPE Map *)TYPE TYPR=typNum:INTEGER; typName:STRING[7]; typFld:BYTEDIM typRec(20):TYPR(* Records Map *)TYPE RECS=recID:INTEGER; recName:STRING[7]DIM rec(20):RECS(* Colors *)! TYPE COLR=white,purple,black,green,yellow,pink,cyan,blue,white2,purple2,black2,green2,yellow2,pink2,cyan2,blue2:BYTETYPE COLR=white,blue,black,green,red,yellow,magenta,cyan,white2,blue2,black2,green2,red2,yellow2,magenta2,cyan2:BYTEDIM color:COLR(* Registers *)TYPE REG=cc,a,b,dp:BYTE; x,y,u:INTEGERDIM regs:REG(* Program Options *)DIM options(26),packet(32),callCode:BYTE(* File paths *)DIM path,vPath,dPath,oPath:BYTE(* File,Overlay open status *)DIM pOpen,vOpen,dOpen,wOpen,oOpen:BOOLEAN(* Booleans *)DIM found,validated,displays,endOfType,hasRecords,first,frst,newGap,field,parameter:BOOLEAN(* File names *)DIM version:STRING[8]; vFile,lnFile,ltFile,dFile,oFile:STRING[29]DIM chainMod:STRING[177](* Column,Row *)DIM col,col1,row,tnTyp:BYTE(* Variable Reference Counters *)DIM varRefs,varCount,recCnt:INTEGER(* Error and Module Data *)DIM modSiz,dataSiz,execOff,dsatOff,vdtOff,lastOff,tpVars,dataStOff:INTEGER(* Various counters *)DIM byteVal,posVal,varCntr:BYTEDIM recNum,intVal,er,er1,which:INTEGERDIM mSize,VDCount,delay:INTEGERDIM nextOff,dsatCnt,ucCnt:INTEGER(* Data Containers *)DIM gapInt(2),gapPntr,gapPtr,gapStrt,gapCnt,gapCntr,dsPointer,dataMem,oldMem:INTEGERDIM typCnt,typCntr,dsMCnt,fieldCnt,cntr,cntr2,tRec,tSiz,tVar,tvFlds:INTEGER(* Strings *)DIM key:STRING[1]; tStrLen:STRING[7]DIM tName,tvName:STRING[29]DIM source:STRING[512](* Time Stamp *)DIM monthName:STRING[9]; dateTime:STRING[17]DIM month,day,year,hour,minute,second,number:INTEGERDIM sMonth,sDay,sYear,sHour,sMinute,sSecond:INTEGERDIM eHour,eMinute,eSecond,tHour,tMinute,tSecond:INTEGERDIM iHour,iMinute,iSecond:INTEGER(* Parameters PARAMs also passed to instruction *)PARAM file:STRING[80]; modName,dataDir:STRING[29](* Initializations *)BASE 0typCnt:=0FOR cntr=0 TO 19gapRec(cntr).gapOff:=0gapRec(cntr).gapSize:=0gapRec(cntr).gapValid:=FALSEtypRec(cntr).typNum:=0typRec(cntr).typName:=""typRec(cntr).typFld:=0NEXT cntrtmpGap:=gapRec(* Get Pause and Page *)callCode:=$8D \(* Get Window Packet *)regs.a:=2regs.b:=$00regs.x:=ADDR(packet)RUN SysCall(callCode,regs)er:=0 \er1:=0 \which:=0 \pOpen:=FALSE \vOpen:=FALSE \dOpen:=FALSE \wOpen:=FALSE \oOpen:=FALSEON ERROR GOTO 500 \! goto error trapdOpen:=FALSEdFile:=dataDir+"initDB"OPEN #dPath,dFile:READdOpen:=TRUEGET #dPath,versionGET #dPath,optionsSEEK #dPath,258+SIZE(options) \! skip token counter arrayGET #dPath,color \! colors record, used in overlay windowsSEEK #dPath,258+SIZE(color)+SIZE(varFRec) \! skip to DSMapGET #dPath,DSMap \! initialized DSAT Map arrayCLOSE #dPathdOpen:=FALSEvFile:=dataDir+"varDefs"lnFile:=dataDir+"linDefs"dFile:=dataDir+"procData"(* Get data *)GOSUB 116 \! turn cursor offcol:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \! set cursor position and erase to end-of-linePRINT #2,"Reading Data File..."; OPEN #dPath,dFile:READdOpen:=TRUEGET #dPath,displays \ GET #dPath,hasRecordsGET #dPath,sHour \ GET #dPath,sMinute \ GET #dPath,sSecondGET #dPath,modSiz \ GET #dPath,dataSiz \ GET #dPath,execOffGET #dPath,dsatOff \ GET #dPath,vdtOff \ GET #dPath,tpVarsGET #dPath,dataStOff(* Variables lookup table *)GET #dPath,varRecCLOSE #dPathdOpen:=FALSEPRINT #2,"Done"; GOSUB 450 \! delay before erasing bottom lineGOSUB 110 \ GOSUB 115(* Chain Module String *)chainMod:="ex RunB #32K instruction ("""+file+""","""+modName+""","""+dataDir+""")"(* Open Variable Reference File *)OPEN #vPath,vFile:UPDATEvOpen:=TRUEGET #vPath,varCount(* Open File *)OPEN #path,file:READpOpen:=TRUEIF vdtOff-dsatOff>3 THEN SEEK #path,dsatOffIF displays AND options(18)=1 THEN wOpen:=TRUEENDIF GOSUB 150 \! get date/time info(* Build DSAT Map *)(* ======================================================================================== *)dsMCnt:=0 \! DSAT map counterSEEK #vPath,2col:=47 \row:=16 \ GOSUB 110 \! set cursor positionPRINT #2,"Counting "; IF wOpen THEN GOSUB 105 \! turn page pause onGOSUB 118 \! open background overlayPRINT #2," DSAT Count"; GOSUB 120 \! open middle overlayPRINT #2,"  DSAT"PRINT #2,"Ofst Pntr Size DSSiz"GOSUB 125 \! open foreground overlayENDIF FOR VDCount:=0 TO varCount-1found:=TRUEGET #vPath,varFRecIF varFRec.vp1.dsSiz>0 THEN DSMap(dsMCnt).dsOf:=varRec(VDCount).dsOff \! DSAT offset addressDSMap(dsMCnt).dsDm:=varFRec.vp1.dsPtr \! variable data memory offsetDSMap(dsMCnt).dsMSz:=varFRec.vp1.dsvSiz \! variable sizeDSMap(dsMCnt).dsSz:=varFRec.vp1.dsSiz \! DSAT entry eizeIF dsMCnt>0 THEN IF DSMap(dsMCnt).dsOf=DSMap(dsMCnt-1).dsOf THEN dsMCnt:=dsMCnt-1found:=FALSEENDIF ENDIF IF found THEN IF wOpen THEN PRINT #2 USING "h4,x1,h4,x1,h4,x1,i5>",DSMap(dsMCnt).dsOf,DSMap(dsMCnt).dsDm,DSMap(dsMCnt).dsMSz,DSMap(dsMCnt).dsSzENDIF ENDIF dsMCnt:=dsMCnt+1ENDIF IF NOT(wOpen) THEN col:=56 \row:=16 \ GOSUB 110 \! set cursor positionPRINT #2,dsMCnt;  \! total DSAT entries in vars recordsENDIF NEXT VDCountIF wOpen THEN PRINT #2 \ PRINT #2,"Press [ENTER] To Continue"; GOSUB 100 \! turn page pause offGOSUB 140 \! get keypressGOSUB 130 \! close overlayGOSUB 130 \! close overlayGOSUB 130 \! close overlaywOpen:=FALSEENDIF (* Sort DSAT Map *)col:=47 \row:=16 \ GOSUB 110 \! set cursor positionPRINT #2,"Sorting    "; RUN dsSort(er,which,0,dsMCnt-1,DSMap)IF er>0 THEN 500 \! goto error trapcol:=47 \row:=16 \ GOSUB 110 \! set cursor positionPRINT #2,"Sorted     "; (* Validate DSAT *)IF displays AND options(19)=1 THEN wOpen:=TRUEENDIF GOSUB 150 \! get date/time infocol:=47 \row:=16 \ GOSUB 110 \! set cursor positionPRINT #2,"Validating"; IF options(25)=1 THEN oFile:=modName+"DSAT.txt"col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \! set cursor positionPRINT #2,"Writing "; oFile; "..."; ! IF NOT(oOpen) THENCREATE #oPath,oFile:WRITEoOpen:=TRUE! ENDIFENDIF IF wOpen THEN GOSUB 105 \! turn page pause onGOSUB 118 \! open background overlayPRINT #2," DSAT Validation"; GOSUB 120 \! open middle overlayPRINT #2,"  DSAT"PRINT #2,"Off  Siz"GOSUB 125 \! open foreground overlayENDIF mSize:=vdtOff-3-dsatOff \gapCnt:=0 \gapCntr:=gapCnt \! getHeader4 fixdsatCnt:=0 \dsPointer:=0 \VDCount:=0 \validated:=TRUESEEK #path,dsatOffREPEAT IF VDCount<dsMCnt THEN IF DSMap(VDCount).dsOf>dsPointer THEN  \! found a gapIF wOpen THEN PRINT #2 USING "s26,h4","Unidentified gap found at ",dsPointerENDIF IF oOpen THEN PRINT #oPath USING "s26,h4","Unidentified gap found at ",dsPointerENDIF validated:=FALSEgapRec(gapCnt).gapValid:=FALSEgapRec(gapCnt).gapOff:=dsPointer \gapRec(gapCnt).gapSize:=0FOR nextOff=1 TO DSMap(VDCount).dsOf-dsPointer \! read all bytes in the gapGET #path,byteValdsPointer:=dsPointer+1gapRec(gapCnt).gapSize:=gapRec(gapCnt).gapSize+1NEXT nextOffgapCnt:=gapCnt+1GOSUB 220 \! validate gapsGOSUB 230 \! validate known entryELSE GOSUB 230 \! validate known entryENDIF (* getHeader5 fix attempt *)(* Added this condition to stop over-incrementing *)! IF VDCount<dsMCnt THEN (* Moved here to correct inaccurate increment *)! VDCount:=VDCount+1! dsatCnt:=dsatCnt+1! ENDIF (* Added this else to stop VDCount going past dsMCnt *)! ELSE! GOSUB 230 \! validate known entryENDIF (* Original Position *)VDCount:=VDCount+1dsatCnt:=dsatCnt+1IF NOT(wOpen) THEN GOSUB 268 \! display countsENDIF (* getHeader5 fix attempt *)(* Added these prints to tell me the values *)! PRINT #2 USING "h4,s1,h4,s1,h4,s1,h4,s1,h4",dsPointer," ",DSMap(VDCount-1).dsOf," ",mSize," ",dsMCnt," ",VDCount! PRINT #oPath USING "h4,s1,h4,s1,h4,s1,h4,s1,h4",dsPointer," ",DSMap(VDCount-1).dsOf," ",mSize," ",dsMCnt," ",VDCountUNTIL dsPointer=mSizeIF wOpen THEN PRINT #2 \ PRINT #2,"Found "; gapCnt; " Unidentified Gap(s) in the DSAT"ENDIF IF oOpen THEN PRINT #oPath \ PRINT #oPath,"Found "; gapCnt; " Unidentified Gap(s) in the DSAT"ENDIF FOR nextOff:=0 TO gapCnt-1IF wOpen THEN PRINT #2 USING "s8>,h4,s8>,i4>","Offset: ",gapRec(nextOff).gapOff,"Size: ",gapRec(nextOff).gapSize; IF gapRec(nextOff).gapValid THEN PRINT #2," Validated"ELSE PRINT #2," Not Validated"ENDIF ENDIF IF oOpen THEN PRINT #oPath USING "s8>,h4,s8>,i4>","Offset: ",gapRec(nextOff).gapOff,"Size: ",gapRec(nextOff).gapSize; IF gapRec(nextOff).gapValid THEN PRINT #oPath," Validated"ELSE PRINT #oPath," Not Validated"ENDIF ENDIF NEXT nextOff(* getHeader5 fix attempt *)! GOSUB 300IF wOpen THEN PRINT #2 \ PRINT #2,"Press [ENTER] To Continue"; GOSUB 100 \! turn page pause offGOSUB 140 \! get keypressGOSUB 130 \! close overlayGOSUB 130 \! close overlayGOSUB 130 \! close overlaywOpen:=FALSEGOSUB 268 \! display countsENDIF (* ======================================================================================== *)col:=47 \row:=16 \ GOSUB 110 \! set cursor positionIF NOT(validated) THEN PRINT #2,"Not Validated"; ELSE PRINT #2,"Validated "; ENDIF (* May need to put this back in, or move it if necessary *)! ELSE ! col:=47 \row:=16 \ GOSUB 110 \! set cursor position! PRINT #2,"No DSAT References"; ! ENDIF IF oOpen THEN col:=11+LEN(oFile) \row:=23 \ GOSUB 110PRINT #2,"Done"; CLOSE #oPathoOpen:=FALSEGOSUB 450 \! delay before erasing bottom lineENDIF (* Display completion time *)col:=69 \row:=16 \ GOSUB 110 \! set cursor positionGOSUB 145 \! get date and time infotypCnt:=0 \typCntr:=0 \tName:=""recNum:=0 \recCnt:=0 \source:=""(* Set record ID numbers *)col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \! set cursor positionPRINT #2,"Fixing records..."; tRec:=0FOR recNum=0 TO varCount-1SEEK #vPath,recNum*SIZE(varFRec)+2GET #vPath,varFRecIF varFRec.vp2.pVar>0 AND varFRec.vp2.pVar<>tRec THEN tRec:=varFRec.vp2.pVarcntr:=0REPEAT SEEK #vPath,cntr*SIZE(varFRec2)+2GET #vPath,varFRec2cntr:=cntr+1UNTIL varFRec2.vp2.vRecNum=varFRec.vp2.pVarIF cntr>1 THEN cntr:=cntr-1FOR cntr2:=0 TO 2IF cntr-1>0 THEN cntr:=cntr-1SEEK #vPath,cntr*SIZE(varFRec)+2GET #vPath,varFRecIF varFRec.vp2.vName=varFRec2.vp2.vName THEN varFRec.vp2.vRecNum:=varFRec2.vp2.vRecNumSEEK #vPath,cntr*SIZE(varFRec)+2PUT #vPath,varFRecPRINT #2,","; ENDIF ENDIF NEXT cntr2ENDIF IF cntr<varCount-1 THEN cntr:=cntr+2FOR cntr2:=0 TO 2IF cntr+1<varCount THEN cntr:=cntr+1SEEK #vPath,cntr*SIZE(varFRec)+2GET #vPath,varFRecIF varFRec.vp2.vName=varFRec2.vp2.vName THEN varFRec.vp2.vRecNum:=varFRec2.vp2.vRecNumSEEK #vPath,cntr*SIZE(varFRec)+2PUT #vPath,varFRecPRINT #2,"."; ENDIF ENDIF NEXT cntr2ENDIF ENDIF NEXT recNumPRINT #2,"Done"; GOSUB 450 \! delay before erasing bottom lineELSE col:=47 \row:=16 \ GOSUB 110 \! set cursor positionPRINT #2,"No DSAT References"; ENDIF (* Validate Data Memory Allocation *)GOSUB 150 \! get date/time infocol:=47 \row:=17 \ GOSUB 110 \! set cursor positionPRINT #2,"Validating"; SEEK #vPath,2cntr:=0validated:=TRUEREPEAT GET #vPath,varFRecIF (varRec(cntr).vTyp>=$80 AND varRec(cntr).vTyp<=$88 OR varRec(cntr).vTyp>=$F2 AND varRec(cntr).vTyp<=$F5) AND varRec(cntr).dmOff<>varRec(cntr+1).dmOff THEN IF varRec(cntr+1).dmOff>varRec(cntr).dmOff+varFRec.vp1.dmSiz THENvalidated:=FALSEENDIF ENDIF cntr:=cntr+1GOSUB 269UNTIL varRec(cntr-1).dmOff+varFRec.vp1.dmSiz=dataSiz OR varRec(cntr).dmOff=dataSizcol:=47 \row:=17 \ GOSUB 110 \! set cursor positionIF validated THEN PRINT #2,"Validated "; ELSE PRINT #2,"Not Validated"; ENDIF (* Display completion time *)col:=69 \row:=17 \ GOSUB 110 \! set cursor positionGOSUB 145 \! get date and time infoFOR cntr:=0 TO 19rec(cntr).recID:=0 \! record ID # associated to fieldsrec(cntr).recName:="" \! typName for this record variableNEXT cntrtypCnt:=0 \! # of type statementstypCntr:=0 \! # of type statementstName:="" \! last variable nametStrLen:="" \! last variable string lengthrecNum:=0 \! current variable file record #recCnt:=0 \! count of record variablesucCnt:=0tVar:=0source:="" \! source statement(* nTyp 0-2: BYTE, INTEGER, REAL, BOOLEAN, STRING, record, array(* nTyp = 0: TYPE field variables(* nTyp = 1: DIM variables(* nTyp = 2: PARAM variables(* nTyp = 3: variable type FOR statement 46 (TO) and 47 (STEP), NEXT statement 00, 01, 02, and 03, subroutine name A0(* Output to Screen *)oFile:=modName+".B09"col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \! set cursor position and erase to end-of-linePRINT #2,"Writing source code to "; oFile; "..."; CREATE #oPath,oFile:WRITEoOpen:=TRUEPRINT #oPath,"PROCEDURE "; modNameIF displays AND options(20)=1 THEN wOpen:=TRUEGOSUB 118 \! Open background overlayPRINT #2," Source Output"; GOSUB 120 \! open middle overlayPRINT ENDIF (* Create Dimension Statements *)IF wOpen THEN PRINT "PROCEDURE "; modName; GOSUB 125 \! open foreground overlayENDIF (* ============================= *)(* Start of Dimension Statements *)(* ============================= *)(* Start Dimension Statements *)varCntr:=1REPEAT SEEK #vPath,recNum*SIZE(varFRec)+2GET #vPath,varFRec \! get next record(* Field Variables *)IF varRec(recNum).nTyp=0 THEN  \! TYPE statementsIF varFRec.vp3.pFld THEN  \! if a field variableIF SUBSTR("s",varFRec.vp2.vName)>0 AND tStrLen="" THEN  \! if string variabletStrLen:=varFRec.vp2.vStrLen \! set temp variable to string length modifierENDIF 10 IF source="" THEN  \! if a new statementtypCnt:=typCnt+1 \! increment type counttypCntr:=typCntr+1 \! increment type counttypRec(typCntr).typName:="TYP"+STR$(typCntr) \! assign type name(* not sure if this part is necessary *)cntr:=0 \found:=FALSEREPEAT  \! is this type already defined?IF rec(cntr).recName=typRec(typCntr).typName THEN found:=TRUEENDIF cntr:=cntr+1UNTIL found OR cntr>=recCntIF NOT(found) THEN  \! no, add to recrec(recCnt).recID:=varFRec.vp2.pVar \! pVar = rec# of record variablerec(recCnt).recName:=typRec(typCntr).typNamerecCnt:=recCnt+1source:="TYPE "+typRec(typCntr).typName+"=" \! set beginning of statementENDIF (* ================================== *)ENDIF GOSUB 200 \! check for arrayIF varFRec.vp2.vName<>tName THEN  \! current var name not previous var nameendOfType:=FALSE(* Is same type? *)IF tName<>"" THEN IF SUBSTR("s",tName)>0 AND tStrLen<>varFRec.vp2.vStrLen THEN endOfType:=TRUEELSE IF tRec<>varFRec.vp2.vRecNum AND SUBSTR("c",tName)>0 THEN endOfType:=TRUEELSE IF LEFT$(varFRec.vp2.vName,1)=LEFT$(tName,1) AND varFRec.vp2.pVar=tVar THEN  \! ex: b009, b010, both BYTEsource:=source+"," \! so separate with a commaELSE  \! ex: b010, i011, not same typeendOfType:=TRUE \! so set end of typeENDIF ENDIF ENDIF ENDIF (* End of same type? *)IF endOfType THEN GOSUB 210 \! end of type(* End of statement? *)(* rec(recCnt-1).recID = current type, so if pVar reflects *)(* a diff number, end of statement, if pVar=0, not a field *)(* variable, so end of statement *)IF varFRec.vp2.pVar<>rec(recCnt-1).recID OR varFRec.vp2.pVar=0 THENIF oOpen THEN PRINT #oPath,sourceENDIF IF wOpen THEN PRINT sourceENDIF source:="" \! clear source for next statementtName:=varFRec.vp2.vName \! set last var nametVar:=varFRec.vp2.pVartStrLen:=varFRec.vp2.vStrLentnTyp:=varRec(recNum).nTypIF SUBSTR("c",tName)>0 THEN tRec:=varFRec.vp2.vRecNumtSiz:=varFRec.vp1.dsvSizENDIF GOTO 10 \! go build next TYPE statementELSE source:=source+"; " \! prepare to add next var type to statementENDIF ENDIF (* add current name to statement if not end of statement *)source:=source+varFRec.vp2.vName \! add var name to source statementtName:=varFRec.vp2.vName \! set last var nametVar:=varFRec.vp2.pVarIF SUBSTR("c",tName)>0 THEN tRec:=varFRec.vp2.vRecNumtSiz:=varFRec.vp1.dsvSizENDIF ELSE (* add current name to statement if beginning of statement *)IF RIGHT$(source,1)="=" THEN source:=source+varFRec.vp2.vNameENDIF ENDIF ENDIF ENDIF IF varRec(recNum).nTyp=1 OR varRec(recNum).nTyp=2 THEN  \! DIM/PARAM statements(* Start DIM/PARAM Statements *)IF NOT(hasRecords) AND SUBSTR("S",varFRec.vp2.vName)>0 THEN tStrLen:=varFRec.vp2.vStrLenENDIF (* nTyp separates user named variables from subroutine names and internal *)(* variables associated to TO and STEP values in FOR/NEXT loops *)15 IF source="" THEN IF varRec(recNum).nTyp=1 THEN source:="DIM "+varFRec.vp2.vNameELSE source:="PARAM "+varFRec.vp2.vNameENDIF ENDIF GOSUB 200 \! check for arrayIF varFRec.vp2.vName<>tName THEN IF RIGHT$(source,1)<>" " THEN endOfType:=FALSE(* Is same type? *)IF tName<>"" THEN (* Parameter variables are named Pvnnnn, ex: PR0065 is a REAL type parameter *)(* Program variables are named Vnnnn, ex: L0044 is a BOOLEAN type variable *)IF SUBSTR("S",tName)>0 AND tStrLen<>varFRec.vp2.vStrLen THEN endOfType:=TRUEELSE IF tRec<>varFRec.vp2.vRecNum AND SUBSTR("C",tName)>0 THEN endOfType:=TRUEELSE IF LEFT$(tName,1)<>"P" AND LEFT$(varFRec.vp2.vName,1)<>"P" THEN IF LEFT$(varFRec.vp2.vName,1)=LEFT$(tName,1) THEN IF varCntr=10 THEN varCntr:=1endOfType:=TRUEELSE varCntr:=varCntr+1source:=source+","ENDIF ELSE endOfType:=TRUEvarCntr:=1ENDIF ENDIF IF LEFT$(tName,1)="P" AND LEFT$(varFRec.vp2.vName,1)="P" THEN IF MID$(varFRec.vp2.vName,2,1)=MID$(tName,2,1) THEN IF varCntr=10 THEN varCntr:=1endOfType:=TRUEELSE varCntr:=varCntr+1source:=source+","ENDIF ELSE endOfType:=TRUEvarCntr:=1ENDIF ENDIF IF LEFT$(tName,1)<>"P" AND LEFT$(varFRec.vp2.vName,1)="P" THEN endOfType:=TRUEtName:=varFRec.vp2.vNameENDIF ENDIF ENDIF ENDIF (* End of same type? *)IF endOfType THEN GOSUB 210 \! end of type(* End of statement? *)IF varFRec.vp2.pVar=0 THEN IF oOpen THEN PRINT #oPath,sourceENDIF IF wOpen THEN PRINT sourceENDIF source:=""tName:=varFRec.vp2.vNametStrLen:=varFRec.vp2.vStrLentnTyp:=varRec(recNum).nTypIF SUBSTR("C",tName)>0 THEN tRec:=varFRec.vp2.vRecNumtSiz:=varFRec.vp1.dsvSizENDIF GOTO 15ENDIF ENDIF IF RIGHT$(source,1)=" " OR RIGHT$(source,1)="," THEN source:=source+varFRec.vp2.vNameENDIF tName:=varFRec.vp2.vNametStrLen:=varFRec.vp2.vStrLenIF SUBSTR("C",tName)>0 THEN tRec:=varFRec.vp2.vRecNumtSiz:=varFRec.vp1.dsvSizENDIF ENDIF ENDIF ENDIF (* end of user variables *)IF varRec(recNum).nTyp=3 THEN GOSUB 210 \! end of typeIF wOpen THEN PRINT sourceENDIF IF oOpen THEN PRINT #oPath,sourceENDIF tnTyp:=varRec(recNum).nTypsource:=""recNum:=varCountELSE recNum:=recNum+1ENDIF UNTIL recNum=varCount(* Close Files *)CLOSE #pathpOpen:=FALSECLOSE #vPathvOpen:=FALSEIF oOpen THEN CLOSE #oPathoOpen:=FALSEENDIF (* Chain to Instruction *)CHAIN chainMod(* End of Program *)END (* ============= *)(* Subroutines *)(* == Group 1 == *)(* Display and Input *)(* Reset Pause and Page *)100 packet(7):=0 \packet(8):=$18callCode:=$8Eregs.a:=2regs.b:=$00regs.x:=ADDR(packet)RUN SysCall(callCode,regs)RETURN (* Set Pause and Page *)105 packet(7):=1 \packet(8):=$12callCode:=$8Eregs.a:=2regs.b:=$00regs.x:=ADDR(packet)RUN SysCall(callCode,regs)RETURN 110 RUN GFX2("CURXY",col,row) \ RETURN 114 RUN GFX2("CLEAR") \ RETURN 115 RUN GFX2("EREOLINE") \ RETURN 116 RUN GFX2("CUROFF") \ RETURN 117 RUN GFX2("CURON") \ RETURN 118 RUN GFX2("OWSET",1,0,1,80,22,options(3),options(4)) \ RETURN120 RUN GFX2("OWSET",1,0,2,80,21,options(5),options(6)) \ RETURN125 RUN GFX2("OWSET",1,0,4,80,18,options(7),options(8)) \ RETURN130 RUN GFX2("OWEND") \ RETURN (* ============= *)(* Get Keypress *)140 key:=""REPEAT RUN Inkey(key)IF key>="A" AND key<="Z" THEN key:=CHR$(ASC(key)+$20)ENDIF UNTIL key="y" OR key="n" OR key=CHR$(13)GOSUB 116 \! turn cursor offcol:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \! set cursor position and erase to end-of-lineRETURN (* ============= *)(* Date and Time Stamp *)(* Display completion time *)145 iHour:=hour \iMinute:=minute \iSecond:=secondGOSUB 150 \! get date/time infoeHour:=hour \eMinute:=minute \eSecond:=secondIF eHour<iHour THEN tHour:=eHour+12-iHourELSE tHour:=eHour-iHour \ ENDIF IF eMinute<iMinute THEN tMinute:=eMinute+60-iMinuteELSE tMinute:=eMinute-iMinute \ ENDIF IF eSecond<iSecond THEN tSecond:=eSecond+60-iSecondELSE tSecond:=eSecond-iSecond \ ENDIF IF eSecond<iSecond AND tSecond<60 THEN tMinute:=tMinute-1 \ ENDIFIF eMinute<iMinute AND tMinute<60 THEN tHour:=tHour-1 \ ENDIF IF tHour<10 THEN PRINT "0"; tHour; ":"; ELSE PRINT tHour; ":";  \ ENDIF IF tMinute<10 THEN PRINT "0"; tMinute; ":"; ELSE PRINT tMinute; ":";  \ ENDIF IF tSecond<10 THEN PRINT "0"; tSecondELSE PRINT tSecond \ ENDIF RETURN (* ============= *)(* Date Stamp *)150 dateTime:=DATE$month:=VAL(MID$(dateTime,4,2))day:=VAL(MID$(dateTime,7,2))year:=2000+VAL(LEFT$(dateTime,2))hour:=VAL(MID$(dateTime,10,2))minute:=VAL(MID$(dateTime,13,2))second:=VAL(MID$(dateTime,16,2))RESTORE 155REPEAT READ number,monthNameUNTIL number=monthRETURN (* ============= *)(* Month Names *)155 DATA 1,"January",2,"February",3,"March"DATA 4,"April",5,"May",6,"June"DATA 7,"July",8,"August",9,"September"DATA 10,"October",11,"November",12,"December"(* ============= *)(* == Group 2 == *)(* These make the array variable names reflect the array elements *)(* Ex: ba039() becomes ba039(3) *)200 IF RIGHT$(varFRec.vp2.vName,4)="(,,)" THEN varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,LEN(varFRec.vp2.vName)-4)+varFRec.vp2.vArrayELSE IF RIGHT$(varFRec.vp2.vName,3)="(,)" THEN varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,LEN(varFRec.vp2.vName)-3)+varFRec.vp2.vArrayELSE IF RIGHT$(varFRec.vp2.vName,2)="()" THEN varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,LEN(varFRec.vp2.vName)-2)+varFRec.vp2.vArrayENDIF ENDIF ENDIF RETURN (* ============= *)210 IF LEFT$(tName,1)="P" THEN posVal:=2ELSE posVal:=1ENDIF IF SUBSTR(MID$(tName,posVal,1),"Bb")>0 THEN source:=source+":BYTE"ELSE IF SUBSTR(MID$(tName,posVal,1),"Ii")>0 THEN source:=source+":INTEGER"ELSE IF SUBSTR(MID$(tName,posVal,1),"Rr")>0 THEN source:=source+":REAL"ELSE IF SUBSTR(MID$(tName,posVal,1),"Ll")>0 THEN source:=source+":BOOLEAN"ELSE IF SUBSTR(MID$(tName,posVal,1),"Ss")>0 THEN source:=source+":STRING"IF tStrLen<>"[32]" THEN source:=source+tStrLenENDIF tStrLen:=varFRec.vp2.vStrLenELSE IF SUBSTR(MID$(tName,posVal,1),"Cc")>0 THEN found:=FALSEFOR cntr:=0 TO recCnt-1IF tRec=rec(cntr).recID THEN source:=source+":"+rec(cntr).recNamefound:=TRUEENDIF NEXT cntrIF NOT(found) THEN typCnt:=typCnt+1typCntr:=typCntr+1ucCnt:=ucCnt+1typRec(typCntr).typName:="TYP"+STR$(typCntr)IF wOpen THEN PRINT "TYPE "; typRec(typCntr).typName; "=uC"; ucCnt; "("; tSiz; "):BYTE"ENDIF IF oOpen THEN PRINT #oPath,"TYPE "; typRec(typCntr).typName; "=uC"; ucCnt; "("; tSiz; "):BYTE"ENDIF source:=source+":"+typRec(typCntr).typNameENDIF (* Have to figure this part out *)ENDIF ENDIF ENDIF ENDIF ENDIF ENDIF RETURN (* ============= *)(* Validate Gaps *)! 220 fieldCnt:=0220 found:=FALSE \fieldCnt:=0 \frst:=FALSE \newGap:=FALSEgapPntr:=gapRec(gapCnt-1).gapOff \gapPtr:=gapPntr+gapRec(gapCnt-1).gapSizeIF MOD(gapRec(gapCnt-1).gapSize,2)=1 THEN IF wOpen THEN PRINT #2,"Gap odd number of types, Size: ";PRINT #2, gapRec(gapCnt-1).gapSize; " bytes"ENDIF IF oOpen THEN PRINT #oPath,"Gap odd number of types, Size: ";PRINT #oPath, gapRec(gapCnt-1).gapSize; " bytes"ENDIF ELSE IF wOpen THEN PRINT #2,"Gap even number of types, Size: ";PRINT #2, gapRec(gapCnt-1).gapSize; " bytes"ENDIF IF oOpen THEN PRINT #oPath,"Gap even number of types, Size: ";PRINT #oPath, gapRec(gapCnt-1).gapSize; " bytes"ENDIF ENDIF 225 SEEK #path,dsatOff+gapPntrgapStrt:=gapPntr \! getHeader4 fixGET #path,intVal \! TYPE sizetSiz:=intValgapPntr:=gapPntr+2IF wOpen THEN PRINT #2 USING "h4,s1",intVal," "; ENDIF IF oOpen THEN PRINT #oPath USING "h4,s1",intVal," "; ENDIF GET #path,intVal \! unknowngapPntr:=gapPntr+2IF wOpen THEN PRINT #2 USING "h4,s1",intVal," "; ENDIF IF oOpen THEN PRINT #oPath USING "h4,s1",intVal," "; ENDIF GET #path,byteVal \! first fieldgapPntr:=gapPntr+1fieldCnt:=fieldCnt+1IF wOpen THEN PRINT #2 USING "h2,s1",byteVal," "; ENDIF IF oOpen THEN PRINT #oPath USING "h2,s1",byteVal," "; ENDIF FOR ucCnt=1 TO (gapRec(gapCnt-1).gapSize-5)/2 \! fields 2-nGET #path,gapIntgapPntr:=gapPntr+2fieldCnt:=fieldCnt+1IF wOpen THEN PRINT #2 USING "h4,s1",gapInt(0)," "; ENDIF IF oOpen THEN PRINT #oPath USING "h4,s1",gapInt(0)," "; ENDIF EXITIF gapInt(0)>gapInt(1) THEN SEEK #path,dsatOff+gapPntr \! getHeader1 fix offset to field stringENDEXIT SEEK #path,dsatOff+gapPntrNEXT ucCntGOSUB 240 \! getHeader4 fix to get tvName and tvFlds correct(* getHeader4 fix following added to identify typRecs *)IF NOT(found) THENvalidated:=FALSEgapRec(gapCnt-1).gapValid:=FALSEIF wOpen THEN PRINT #2,"Not Validated"ENDIF IF oOpen THEN PRINT #oPath,"Not Validated"ENDIF (* getHeader5 fix attempt *)(* Added this to try and correct unvalidated program variable id *)(* May be needed in getHeader4, possibly only came into use in getHeader5 *)! IF gapPntr>gapRec(gapCnt-1).gapSize THEN! validated:=FALSE! gapRec(gapCnt-1).gapValid:=FALSE! dsPointer:=gapRec(gapCnt-1).gapOff! IF gapRec(gapCnt-1).gapOff+gapRec(gapCnt-1).gapSize<DSMap(VDCount).dsOf THEN! gapRec(gapCnt-1).gapSize:=DSMap(VDCount).dsOf-gapRec(gapCnt-1).gapOff! ENDIF! RETURN! ENDIF(* ============================================================= *)IF frst THENnewGap:=TRUEtmpGap(gapCntr-1).gapOff:=gapStrttmpGap(gapCntr-1).gapSize:=2tmpGap(gapCntr-1).gapValid:=FALSEfrst:=FALSEELSEIF gapCntr>0 THENtmpGap(gapCntr-1).gapSize:=tmpGap(gapCntr-1).gapSize+2GOSUB 235 \! getHeader4 fix, display new gap variable, won't work with arrays(* Possible getHeader5 fix? *)ELSE! tmpGap(gapCntr).gapSize:=tmpGap(gapCntr).gapSize+2! gapCntr:=gapCntr+1! GOSUB 235 \! getHeader4 fix, display new gap variable, won't work with arrays(* ======================== *)ENDIFENDIF! IF wOpen THEN ! PRINT #2 USING "h4,s1,i3,s1,b5",tmpGap(gapCntr-1).gapOff," ",tmpGap(gapCntr-1).gapSize," ",tmpGap(gapCntr-1).gapValid! ENDIF ! IF oOpen THEN ! PRINT #oPath USING "h4,s1,i3,s1,b5",tmpGap(gapCntr-1).gapOff," ",tmpGap(gapCntr-1).gapSize," ",tmpGap(gapCntr-1).gapValid! ENDIF gapPntr:=gapStrt+2 \! getHeader4 fix(* Debugging prints *)! PRINT #2 USING "s9,h4","gapPntr: ",gapPntr! PRINT #oPath USING "s9,h4","gapPntr: ",gapPntr(* ================ *)ENDIFIF found THEN  \! getHeader4 fixvalidated:=TRUEgapRec(gapCnt-1).gapValid:=TRUEIF wOpen THEN PRINT #2,"Validated"PRINT #2 USING "s17>,i4>","Field Variables: ",fieldCntPRINT #2,tvName; " "; tvFldsPRINT #2,typRec(typCnt-1).typName; " Fields: "; typRec(typCnt-1).typFldENDIF IF oOpen THEN PRINT #oPath,"Validated"PRINT #oPath USING "s17>,i4>","Field Variables: ",fieldCntPRINT #oPath,tvName; " "; tvFldsPRINT #oPath,typRec(typCnt-1).typName; " Fields: "; typRec(typCnt-1).typFldENDIF  \! getHeader4 fixfound:=FALSE \! getHeader4 fixENDIFIF gapPntr<gapRec(gapCnt-1).gapSize THEN validated:=FALSEgapRec(gapCnt-1).gapValid:=FALSEfieldCnt:=0GOTO 225ELSE\! getHeader3 fixIF gapPntr>gapPtr THEN \! getHeader3 fixSEEK #path,dsatOff+(gapPntr-1)\! getHeader3 fixgapPntr:=gapRec(gapCnt).gapOff\! getHeader3 fixENDIF\! getHeader3 fixENDIF IF frst THEN \! getHeader4 fixgapCntr:=gapCntr-1 \! getHeader4 fixfrst:=FALSE \! getHeader4 fixENDIF \! getHeader4 fixRETURN 230 IF dsPointer=DSMap(VDCount).dsOf THEN \! getHeader4 fixFOR nextOff:=1 TO DSMap(VDCount).dsSz/2 \! getHeader4 fixGET #path,intValdsPointer:=dsPointer+2IF wOpen THEN PRINT #2 USING "h4,s1",intVal," "; ENDIF IF oOpen THEN PRINT #oPath USING "h4,s1",intVal," "; ENDIF NEXT nextOffIF wOpen THEN PRINT #2,"Validated"ENDIF IF oOpen THEN PRINT #oPath,"Validated"ENDIF (* Added this for unused variables *)ELSESEEK #path,dsatOff+dsPointerFOR nextOff:=1 to tmpGap(gapCntr-1).gapSize/2GET #path,intValdsPointer:=dsPointer+2IF wOpen THEN PRINT #2 USING "h4,s1",intVal," "; ENDIF IF oOpen THEN PRINT #oPath USING "h4,s1",intVal," "; ENDIF NEXT nextOffIF wOpen THEN PRINT #2,"Not Validated"ENDIF IF oOpen THEN PRINT #oPath,"Not Validated"ENDIF ENDIFRETURN 235 SEEK #path,dsatOff+(gapStrt-2)FOR nextOff:=1 to tmpGap(gapCntr-1).gapSize/2GET #path,intVal! dsPointer:=dsPointer+2IF wOpen THEN PRINT #2 USING "h4,s1",intVal," "; ENDIF IF oOpen THEN PRINT #oPath USING "h4,s1",intVal," "; ENDIF NEXT nextOffIF wOpen THEN PRINT #2,"Not Validated"ENDIF IF oOpen THEN PRINT #oPath,"Not Validated"ENDIF RETURN 240 varCntr:=0 \dataMem:=0 \oldMem:=0 \lastOff:=0first:=TRUE \field:=FALSE \parameter:=FALSESEEK #vPath,varCntr*SIZE(varFRec)+2WHILE varCntr<varCount DO GET #vPath,varFRec! IF ((LEFT$(varFRec.vp2.vName,1)="c" AND varFRec.vp1.fSiz=tSiz) OR (LEFT$(varFRec.vp2.vName,1)="C" AND varFRec.vp1.dmSiz=tSiz) OR (LEFT$(varFRec.vp2.vName,2)="PC" AND varFRec.vp1.pSiz=tSiz)) AND varFRec.vp3.fNum=0 THENIF LEFT$(varFRec.vp2.vName,1)="c" AND varFRec.vp1.fSiz=tSiz AND varFRec.vp3.fNum=0 THEN 250IF LEFT$(varFRec.vp2.vName,1)="C" AND varFRec.vp1.dmSiz=tSiz AND varFRec.vp3.fNum=0 THEN 250IF LEFT$(varFRec.vp2.vName,2)="PC" AND varFRec.vp1.pSiz=tSiz AND varFRec.vp3.fNum=0 THEN 250 IF LEFT$(varFRec.vp2.vName,1)="c" THEN field:=TRUEELSE IF LEFT$(varFRec.vp2.vName,2)="PC" THEN parameter:=TRUEELSE field:=FALSEparameter:=FALSEENDIF ENDIF IF first THEN IF field THEN dataMem:=varRec(varCntr).fOffELSE IF parameter THEN dataMem:=varRec(varCntr).pOffELSE dataMem:=varRec(varCntr).dmOffENDIF ENDIF ENDIF (* The following statement is 462 characters long (464 including '! ', 466 when changed by Basic09 to 'REM '). *)(* Even though commented, Basic09 still reports an error when loading: *)(* Error #255 *)(* then displays a portion of the statement with the error pointer (^) beneath the last 'r' in the last NOT(parameter), followed by: *)(* Error #027 -- Missing Assignment Statement *)(* Open the file in edit mode and quit back to the workspace prompt and the errors go away. *)(* This is evidence of Basic09's issue with long statements *)(* I have broken the statement up into 3 comments to avoid the issue. *)! IF (first AND field AND dataMem=varRec(varCntr).fOff OR NOT(first) AND field AND lastOff=varRec(varCntr).dsOff AND dataMem=varRec(varCntr).fOff)! OR (IF first AND field AND dataMem=varRec(varCntr).fOff OR NOT(first) AND field AND lastOff=varRec(varCntr).dsOff AND dataMem=varRec(varCntr).fOff)! OR (IF first AND NOT(field) AND NOT(parameter) AND dataMem=varRec(varCntr).dmOff OR NOT(first) AND NOT(field) AND NOT(parameter) AND lastOff=varRec(varCntr).dsOff) THEN IF first AND field AND dataMem=varRec(varCntr).fOff OR NOT(first) AND field AND lastOff=varRec(varCntr).dsOff AND dataMem=varRec(varCntr).fOff THEN 260IF first AND parameter AND dataMem=varRec(varCntr).pOff OR NOT(first) AND parameter AND lastOff=varRec(varCntr).dsOff AND dataMem=varRec(varCntr).pOff THEN 260IF first AND NOT(field) AND NOT(parameter) AND dataMem=varRec(varCntr).dmOff OR NOT(first) AND NOT(field) AND NOT(parameter) AND lastOff=varRec(varCntr).dsOff AND dataMem=varRec(varCntr).dmOff THEN 260 found:=TRUE \varFRec.vp3.fNum:=fieldCnt \! getHeader4 fix found or NOT(found)SEEK #vPath,varCntr*SIZE(varFRec)+2PUT #vPath,varFRecIF first THEN first:=FALSEtypRec(typCnt).typNum:=typCnt+1typRec(typCnt).typName:="TYP"+STR$(typCnt+1)typRec(typCnt).typFld:=varFRec.vp3.fNumtypCnt:=typCnt+1tvName:=varFRec.vp2.vNametvFlds:=varFRec.vp3.fNumENDIF oldMem=dataMemlastOff:=varRec(varCntr).dsOff(* getHeader4 fix account for frst gap *)ELSEIF NOT(frst) THENgapCntr:=gapCntr+1frst:=TRUEENDIFENDIF(* ============ *)ELSE oldMem:=0ENDIF varCntr:=varCntr+1field:=FALSEparameter:=FALSEIF oldMem<>dataMem THEN first:=TRUEENDIF ENDWHILE RETURN (* ============= *)(* Display Counts *)268 col:=14 \row:=16 \ GOSUB 110 \! set cursor positionPRINT USING "i5>",dsatCnt; RETURN 269 col:=14 \row:=17 \ GOSUB 110 \! set cursor positionPRINT USING "i5>",cntr; RETURN (* ============= *)(* == Group 3 == *)(* No Group 3 Routines *)(* DSAT 2nd Pass *)! 300 PRINT #2,"DSAT Validation 2nd Pass",gapCnt,gapCntr! PRINT #oPath,"DSAT Validation 2nd Pass",gapCnt,gapCntr! IF wOpen THEN ! FOR cntr2:=0 TO gapCnt-1! PRINT #2 USING "h4,s1,i3,s1,b5",gapRec(cntr2).gapOff," ",gapRec(cntr2).gapSize," ",gapRec(cntr2).gapValid! NEXT cntr2! FOR cntr2:=0 TO gapCntr-1! PRINT #2 USING "h4,s1,i3,s1,b5",tmpGap(cntr2).gapOff," ",tmpGap(cntr2).gapSize," ",tmpGap(cntr2).gapValid! NEXT cntr2! ENDIF ! IF oOpen THEN ! FOR cntr2:=0 TO gapCnt-1! PRINT #oPath USING "h4,s1,i3,s1,b5",gapRec(cntr2).gapOff," ",gapRec(cntr2).gapSize," ",gapRec(cntr2).gapValid! NEXT cntr2! FOR cntr2:=0 TO gapCntr-1! PRINT #oPath USING "h4,s1,i3,s1,b5",tmpGap(cntr2).gapOff," ",tmpGap(cntr2).gapSize," ",tmpGap(cntr2).gapValid! NEXT cntr2! ENDIF ! RETURN(* ============= *)(* == Group 4 == *)(* Delay Loop *)450 FOR delay=1 TO 12000 \NEXT delayRETURN (* ============= *)(* == Group 5 == *)(* Error Trap *)500 IF er=0 THEN er:=ERRENDIF IF wOpen THEN GOSUB 130 \ GOSUB 130 \ GOSUB 130 \! close overlaysENDIF IF pOpen THEN CLOSE #pathpOpen:=FALSEENDIF IF vOpen THEN CLOSE #vPathvOpen:=FALSEENDIF IF dOpen THEN CLOSE #dPathdOpen:=FALSEENDIF GOSUB 117 \! turn cursor oncol:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \! set cursor position and erase to end-of-lineON ERROR GOTO 510(* For brief error messages, change ,1 to ,0 *)SHELL "RunB ErrorCodes ("+STR$(er)+",1)"END (* ============= *)(* If ErrorCodes is not found *)510 er1:=ERRIF er1=43 THEN PRINT #2,"Error: "; erENDIF END (* ============= *)PROCEDURE dsSort(* based on quicksort, by T.F. Ritter(* DSAT Map *)TYPE DSMP=dsOf,dsDm,dsMSz,dsSz:INTEGERDIM DSMap:DSMPPARAM er,which:INTEGER; bottom,top:INTEGER; DSMaps(100):DSMPDIM lower,upper:INTEGER; btemp:BOOLEANON ERROR GOTO 10which:=which+1RUN GFX2("CURXY",55,16) \ PRINT which; BASE 0lower:=bottomupper:=topLOOP  \! each element gets the once overREPEAT  \! this is a postinc instructionbtemp:=DSMaps(lower).dsOf<DSMaps(top).dsOflower:=lower+1UNTIL NOT(btemp)lower:=lower-1 \! point at the tested elementEXITIF lower=upper THEN ENDEXIT REPEAT  \! this is a postdec instructionupper:=upper-1UNTIL DSMaps(upper).dsOf<=DSMaps(top).dsOf OR upper=lowerEXITIF lower=upper THEN ENDEXIT DSMap:=DSMaps(lower)DSMaps(lower):=DSMaps(upper)DSMaps(upper):=DSMaplower:=lower+1 \! prepare for postincEXITIF lower=upper THEN ENDEXIT ENDLOOP IF lower<>top THEN IF DSMaps(lower).dsOf<>DSMaps(top).dsOf THEN DSMap:=DSMaps(lower)DSMaps(lower):=DSMaps(top)DSMaps(top):=DSMapENDIF ENDIF IF bottom<lower-1 THEN RUN dsSort(er,which,bottom,lower-1,DSMaps)ENDIF IF lower+1<top THEN RUN dsSort(er,which,lower+1,top,DSMaps)ENDIF END 10 er:=ERREND 