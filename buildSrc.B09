PROCEDURE buildSrc(* Version 1.2.10 *)(* Declarations *)(* Variable Record *)(* Array *)TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGERDIM varRec(400):VREC(* File Record *)TYPE VFRC=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGER; vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGER; mTyp,vLnk:BYTE; pRec,pFld:BOOLEANDIM varFRec,varFRec2:VFRC(* DSAT Map *)TYPE DSMP=dsOf,dsDm,dsMSz,dsSz:INTEGERDIM DSMap(100):DSMP(* Records Map *)TYPE RECS=recID:INTEGER; recName:STRING[7]DIM rec(20):RECS(* Colors *)(* TYPE COLR=white,purple,black,green,yellow,pink,cyan,blue,white2,purple2,black2,green2,yellow2,pink2,cyan2,blue2:BYTETYPE COLR=white,blue,black,green,red,yellow,magenta,cyan,white2,blue2,black2,green2,red2,yellow2,magenta2,cyan2:BYTEDIM color:COLR(* Registers *)TYPE REG=cc,a,b,dp:BYTE; x,y,u:INTEGERDIM regs:REG(* Program Options *)DIM options(26),packet(32),callCode:BYTE(* File paths *)DIM path,vPath,dPath,oPath:BYTE(* File,Overlay open status *)DIM pOpen,vOpen,dOpen,wOpen,oOpen:BOOLEAN(* Booleans *)DIM found,validated,displays,endOfType,hasRecords:BOOLEAN(* File names *)DIM version:STRING[8]; vFile,lnFile,ltFile,dFile,oFile:STRING[29]DIM chainMod:STRING[177](* Column,Row *)DIM col,col1,row,tnTyp:BYTE(* Variable Reference Counters *)DIM varRefs,varCount,recCnt:INTEGER(* Error and Module Data *)DIM modSiz,dataSiz,execOff,dsatOff,vdtOff,lastOff,tpVars,dataStOff:INTEGER(* Various counters *)DIM byteVal,posVal,varCntr:BYTEDIM recNum,intVal,er,er1,which:INTEGERDIM mSize,VDCount,delay:INTEGERDIM nextOff,dsatCnt,ucCnt:INTEGER(* Data Containers *)DIM dsPointer:INTEGERDIM gapOff(20),gapSize(20),gapCnt,dsMCnt,typCnt,cntr,cntr2,tRec,tSiz,tVar:INTEGER(* Strings *)DIM key:STRING[1]; tStrLen,typName:STRING[7]DIM tName:STRING[29]DIM source:STRING[512](* Time Stamp *)DIM monthName:STRING[9]; dateTime:STRING[17]DIM month,day,year,hour,minute,second,number:INTEGERDIM sMonth,sDay,sYear,sHour,sMinute,sSecond:INTEGERDIM eHour,eMinute,eSecond,tHour,tMinute,tSecond:INTEGERDIM iHour,iMinute,iSecond:INTEGER(* Parameters PARAMs also passed to instruction *)PARAM file:STRING[80]; modName,dataDir:STRING[29](* Initializations *)BASE 0(* Get Pause and Page *)callCode:=$8D \(* Get Window Packet *)regs.a:=2regs.b:=$00regs.x:=ADDR(packet)RUN SysCall(callCode,regs)er:=0 \er1:=0 \which:=0 \pOpen:=FALSE \vOpen:=FALSE \dOpen:=FALSE \wOpen:=FALSE \oOpen:=FALSEON ERROR GOTO 500 \! goto error trapdOpen:=FALSEdFile:=dataDir+"initDB"OPEN #dPath,dFile:READdOpen:=TRUEGET #dPath,versionGET #dPath,optionsSEEK #dPath,258+SIZE(options) \! skip token counter arrayGET #dPath,color \! colors record, used in overlay windowsSEEK #dPath,258+SIZE(color)+SIZE(varFRec) \! skip to DSMapGET #dPath,DSMap \! initialized DSAT Map arrayCLOSE #dPathdOpen:=FALSEvFile:=dataDir+"varDefs"lnFile:=dataDir+"linDefs"dFile:=dataDir+"procData"(* Get data *)GOSUB 116 \! turn cursor offcol:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \! set cursor position and erase to end-of-linePRINT #2,"Reading Data File..."; OPEN #dPath,dFile:READdOpen:=TRUEGET #dPath,displays \ GET #dPath,hasRecordsGET #dPath,sHour \ GET #dPath,sMinute \ GET #dPath,sSecondGET #dPath,modSiz \ GET #dPath,dataSiz \ GET #dPath,execOffGET #dPath,dsatOff \ GET #dPath,vdtOff \ GET #dPath,tpVarsGET #dPath,dataStOff(* Variables lookup table *)GET #dPath,varRecCLOSE #dPathdOpen:=FALSEPRINT #2,"Done"; GOSUB 450 \! delay before erasing bottom lineGOSUB 110 \ GOSUB 115(* Chain Module String *)chainMod:="ex RunB #32K instruction ("""+file+""","""+modName+""","""+dataDir+""")"(* Open Variable Reference File *)OPEN #vPath,vFile:UPDATEvOpen:=TRUEGET #vPath,varCount(* Open File *)OPEN #path,file:READpOpen:=TRUEIF vdtOff-dsatOff>3 THEN SEEK #path,dsatOffIF displays AND options(18)=1 THEN wOpen:=TRUEENDIF GOSUB 150 \! get date/time infodsMCnt:=0SEEK #vPath,2col:=47 \row:=16 \ GOSUB 110 \! set cursor positionPRINT #2,"Counting "; IF wOpen THEN GOSUB 105 \! turn page pause onGOSUB 118 \! Open background overlayPRINT #2," DSAT Count"; GOSUB 120 \! open middle overlayPRINT #2PRINT #2,"Ofst Pntr Size DSSiz"GOSUB 125 \! open foreground overlayENDIF FOR VDCount:=0 TO varCount-1found:=TRUEGET #vPath,varFRecIF varFRec.dsSiz>0 THEN DSMap(dsMCnt).dsOf:=varRec(VDCount).dsOffDSMap(dsMCnt).dsDm:=varFRec.dsPtrDSMap(dsMCnt).dsMSz:=varFRec.dsvSizDSMap(dsMCnt).dsSz:=varFRec.dsSizIF dsMCnt>0 THEN IF DSMap(dsMCnt).dsOf=DSMap(dsMCnt-1).dsOf THEN dsMCnt:=dsMCnt-1found:=FALSEENDIF ENDIF IF found THEN IF wOpen THEN PRINT #2 USING "h4,x1,h4,x1,h4,x1,i5>",DSMap(dsMCnt).dsOf,DSMap(dsMCnt).dsDm,DSMap(dsMCnt).dsMSz,DSMap(dsMCnt).dsSzENDIF ENDIF dsMCnt:=dsMCnt+1ENDIF IF NOT(wOpen) THEN col:=56 \row:=16 \ GOSUB 110 \! set cursor positionPRINT #2,dsMCnt; ENDIF NEXT VDCountIF wOpen THEN PRINT #2 \ PRINT #2,"Press [ENTER] To Continue"; GOSUB 100 \! turn page pause offGOSUB 140 \! get keypressGOSUB 130 \! close overlayGOSUB 130 \! close overlayGOSUB 130 \! close overlaywOpen:=FALSEENDIF col:=47 \row:=16 \ GOSUB 110 \! set cursor positionPRINT #2,"Sorting    "; RUN dsSort(er,which,0,dsMCnt-1,DSMap)IF er>0 THEN 500 \! goto error trapcol:=47 \row:=16 \ GOSUB 110 \! set cursor positionPRINT #2,"Sorted     "; 
(* Validate DSAT *)IF displays AND options(19)=1 THEN   wOpen:=TRUEENDIF GOSUB 150 \! get date/time infocol:=47 \row:=16 \ GOSUB 110 \! set cursor positionPRINT #2,"Validating"; IF options(25)=1 THEN   oFile:=modName+"DSAT.txt"  col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \! set cursor position  PRINT #2,"Writing "; oFile; "...";   CREATE #oPath,oFile:WRITE  oOpen:=TRUEENDIF IF wOpen THEN   GOSUB 105 \! turn page pause on  GOSUB 118 \! Open background overlay  PRINT #2," DSAT Validation";   GOSUB 120 \! open middle overlay  PRINT #2,"  DSAT"  PRINT #2,"Off  Siz"  GOSUB 125 \! open foreground overlayENDIF 
mSize:=vdtOff-3-dsatOff \gapCnt:=0dsatCnt:=0 \dsPointer:=0 \VDCount:=0 \validated:=TRUESEEK #path,dsatOffREPEAT   IF VDCount<dsMCnt THEN     IF DSMap(VDCount).dsOf>dsPointer THEN       validated:=FALSE      gapOff(gapCnt):=dsPointer \gapSize(gapCnt):=0      FOR nextOff=1 TO DSMap(VDCount).dsOf-dsPointer        GET #path,byteVal        dsPointer:=dsPointer+1        gapSize(gapCnt):=gapSize(gapCnt)+1        IF wOpen THEN           PRINT #2 USING "h2",byteVal;         ENDIF         IF oOpen THEN           PRINT #oPath USING "h2",byteVal;         ENDIF       NEXT nextOff      gapCnt:=gapCnt+1      IF wOpen THEN         PRINT #2," Unidentified"        PRINT #2      ENDIF       IF oOpen THEN         PRINT #oPath," Unidentified"      ENDIF       FOR nextOff:=1 TO DSMap(VDCount).dsSz/2        GET #path,intVal        dsPointer:=dsPointer+2        IF wOpen THEN           PRINT #2 USING "h4,s1",intVal," ";         ENDIF         IF oOpen THEN           PRINT #oPath USING "h4,s1",intVal," ";         ENDIF       NEXT nextOff      IF wOpen THEN         PRINT #2,"Validated"        PRINT #2      ENDIF       IF oOpen THEN         PRINT #oPath,"Validated"      ENDIF     ELSE       FOR nextOff:=1 TO DSMap(VDCount).dsSz/2        GET #path,intVal        dsPointer:=dsPointer+2        IF wOpen THEN           PRINT #2 USING "h4,s1",intVal," ";         ENDIF         IF oOpen THEN           PRINT #oPath USING "h4,s1",intVal," ";         ENDIF       NEXT nextOff      IF wOpen THEN         PRINT #2,"Validated"        PRINT #2      ENDIF       IF oOpen THEN         PRINT #oPath,"Validated"      ENDIF     ENDIF   ENDIF   VDCount:=VDCount+1  dsatCnt:=dsatCnt+1  IF NOT(wOpen) THEN     GOSUB 268 \! display counts  ENDIF UNTIL dsPointer=mSize
IF wOpen THEN   PRINT #2 \ PRINT #2,"There is/are "; gapCnt; " Unidentified Gap(s) in the DSAT"ENDIF 
IF oOpen THEN 
  PRINT #oPath \ PRINT #oPath,"There is/are "; gapCnt; " Unidentified Gap(s) in the DSAT"
ENDIF 
FOR nextOff:=0 TO gapCnt-1  IF wOpen THEN 
    PRINT #2 USING "s8>,h4,s8>,i4>","Offset: ",gapOff(nextOff),"Size: ",gapSize(nextOff)  ENDIF 
  IF oOpen THEN 
    PRINT #oPath USING "s8>,h4,s8>,i4>","Offset: ",gapOff(nextOff),"Size: ",gapSize(nextOff)
  ENDIF 
  GOSUB 220 \! validate gaps
NEXT nextOff
IF wOpen THEN 
  PRINT #2 \ PRINT #2,"Press [ENTER] To Continue";   GOSUB 100 \! turn page pause off  GOSUB 140 \! get keypress  GOSUB 130 \! close overlay  GOSUB 130 \! close overlay  GOSUB 130 \! close overlay  wOpen:=FALSE  GOSUB 268 \! display countsENDIF 
col:=47 \row:=16 \ GOSUB 110 \! set cursor positionIF NOT(validated) THEN   PRINT #2,"Not Validated"; ELSE   PRINT #2,"Validated "; ENDIF IF oOpen THEN   col:=11+LEN(oFile) \row:=23 \ GOSUB 110  PRINT #2,"Done";   CLOSE #oPath  oOpen:=FALSE  GOSUB 450 \! delay before erasing bottom lineENDIF 
(* Display completion time *)col:=69 \row:=16 \ GOSUB 110 \! set cursor positionGOSUB 145 \! get date and time infotypCnt:=0 \tName:="" \typName:=""recNum:=0 \recCnt:=0 \source:=""(* Set record ID numbers *)col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \! set cursor positionPRINT #2,"Fixing records..."; tRec:=0FOR recNum=0 TO varCount-1SEEK #vPath,recNum*SIZE(varFRec)+2GET #vPath,varFRecIF varFRec.pVar>0 AND varFRec.pVar<>tRec THEN tRec:=varFRec.pVarcntr:=0REPEAT SEEK #vPath,cntr*SIZE(varFRec2)+2GET #vPath,varFRec2cntr:=cntr+1UNTIL varFRec2.vRecNum=varFRec.pVarIF cntr>1 THEN cntr:=cntr-1FOR cntr2:=0 TO 2IF cntr-1>0 THEN cntr:=cntr-1SEEK #vPath,cntr*SIZE(varFRec)+2GET #vPath,varFRecIF varFRec.vName=varFRec2.vName THEN varFRec.vRecNum:=varFRec2.vRecNumSEEK #vPath,cntr*SIZE(varFRec)+2PUT #vPath,varFRecPRINT #2,","; ENDIF ENDIF NEXT cntr2ENDIF IF cntr<varCount-1 THEN cntr:=cntr+2FOR cntr2:=0 TO 2IF cntr+1<varCount THEN cntr:=cntr+1SEEK #vPath,cntr*SIZE(varFRec)+2GET #vPath,varFRecIF varFRec.vName=varFRec2.vName THEN varFRec.vRecNum:=varFRec2.vRecNumSEEK #vPath,cntr*SIZE(varFRec)+2PUT #vPath,varFRecPRINT #2,"."; ENDIF ENDIF NEXT cntr2ENDIF ENDIF NEXT recNumPRINT #2,"Done"; GOSUB 450 \! delay before erasing bottom lineELSE col:=47 \row:=16 \ GOSUB 110 \! set cursor positionPRINT #2,"No DSAT References"; ENDIF (* Validate Data Memory Allocation *)GOSUB 150 \! get date/time infocol:=47 \row:=17 \ GOSUB 110 \! set cursor positionPRINT #2,"Validating"; SEEK #vPath,2cntr:=0validated:=TRUEREPEAT GET #vPath,varFRecIF (varRec(cntr).vTyp>=$80 AND varRec(cntr).vTyp<=$88 OR varRec(cntr).vTyp>=$F2 AND varRec(cntr).vTyp<=$F5) AND varRec(cntr).dmOff<>varRec(cntr+1).dmOff THEN IF varRec(cntr+1).dmOff>varRec(cntr).dmOff+varFRec.dmSiz THEN validated:=FALSEENDIF ENDIF cntr:=cntr+1GOSUB 269UNTIL varRec(cntr-1).dmOff+varFRec.dmSiz=dataSiz OR varRec(cntr).dmOff=dataSizcol:=47 \row:=17 \ GOSUB 110 \! set cursor positionIF validated THEN PRINT #2,"Validated "; ELSE PRINT #2,"Not Validated"; ENDIF (* Display completion time *)col:=69 \row:=17 \ GOSUB 110 \! set cursor positionGOSUB 145 \! get date and time infoFOR cntr:=0 TO 19rec(cntr).recID:=0 \! record ID # associated to fieldsrec(cntr).recName:="" \! typName for this record variableNEXT cntrtypCnt:=0 \! # of type statementstName:="" \! last variable nametypName:="" \! ex: TYPE TYP1= TYP1 is typNametStrLen:="" \! last variable string lengthrecNum:=0 \! current variable file record #recCnt:=0 \! count of record variablesucCnt:=0tVar:=0source:="" \! source statement
(* nTyp 0-2: BYTE, INTEGER, REAL, BOOLEAN, STRING, record, array(* nTyp = 0: TYPE field variables(* nTyp = 1: DIM variables(* nTyp = 2: PARAM variables(* nTyp = 3: variable type FOR statement 46 (TO) and 47 (STEP), NEXT statement 00, 01, 02, and 03, subroutine name A0(* Output to Screen *)oFile:=modName+".B09"col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \! set cursor position and erase to end-of-linePRINT #2,"Writing source code to "; oFile; "..."; CREATE #oPath,oFile:WRITEoOpen:=TRUEPRINT #oPath,"PROCEDURE "; modNameIF displays AND options(20)=1 THEN wOpen:=TRUEGOSUB 118 \! Open background overlayPRINT #2," Source Output"; GOSUB 120 \! open middle overlayPRINT ENDIF (* Create Dimension Statements *)IF wOpen THEN PRINT "PROCEDURE "; modName; GOSUB 125 \! open foreground overlayENDIF 
(* ============================= *)
(* Start of Dimension Statements *)
(* ============================= *)
(* Start Dimension Statements *)varCntr:=1REPEAT   SEEK #vPath,recNum*SIZE(varFRec)+2  GET #vPath,varFRec \! get next record  (* Field Variables *)  IF varRec(recNum).nTyp=0 THEN  \! TYPE statements    IF varFRec.pFld THEN  \! if a field variable      IF SUBSTR("s",varFRec.vName)>0 AND tStrLen="" THEN  \! if string variable        tStrLen:=varFRec.vStrLen \! set temp variable to string length modifier      ENDIF 10    IF source="" THEN  \! if a new statement        typCnt:=typCnt+1 \! increment type count        typName:="TYP"+STR$(typCnt) \! assign type name        (* not sure if this part is necessary        (* ==================================        cntr:=0 \found:=FALSE        REPEAT  \! is this type already defined?          IF rec(cntr).recName=typName THEN             found:=TRUE          ENDIF           cntr:=cntr+1        UNTIL found OR cntr>=recCnt        IF NOT(found) THEN  \! no, add to rec          rec(recCnt).recID:=varFRec.pVar \! pVar = rec# of record variable          rec(recCnt).recName:=typName          recCnt:=recCnt+1          source:="TYPE "+typName+"=" \! set beginning of statement        ENDIF         (* ==================================      ENDIF       GOSUB 200 \! check for array      IF varFRec.vName<>tName THEN  \! current var name not previous var name        endOfType:=FALSE        (* Is same type? *)        IF tName<>"" THEN           IF SUBSTR("s",tName)>0 AND tStrLen<>varFRec.vStrLen THEN             endOfType:=TRUE          ELSE             IF tRec<>varFRec.vRecNum AND SUBSTR("c",tName)>0 THEN               endOfType:=TRUE            ELSE               IF LEFT$(varFRec.vName,1)=LEFT$(tName,1) AND varFRec.pVar=tVar THEN \! ex: b009, b010, both BYTE                source:=source+"," \! so separate with a comma              ELSE  \! ex: b010, i011, not same type                endOfType:=TRUE \! so set end of type              ENDIF             ENDIF           ENDIF         ENDIF         (* End of same type? *)        IF endOfType THEN           GOSUB 210 \! end of type          (* End of statement? *)          (* rec(recCnt-1).recID = current type, so if pVar reflects *)          (* a diff number, end of statement, if pVar=0, not a field *)          (* variable, so end of statement *)          IF varFRec.pVar<>rec(recCnt-1).recID OR varFRec.pVar=0 THEN             IF oOpen THEN               PRINT #oPath,source            ENDIF             IF wOpen THEN               PRINT source            ENDIF             source:="" \! clear source for next statement            tName:=varFRec.vName \! set last var name            tVar:=varFRec.pVar            tStrLen:=varFRec.vStrLen            tnTyp:=varRec(recNum).nTyp            IF SUBSTR("c",tName)>0 THEN               tRec:=varFRec.vRecNum              tSiz:=varFRec.dsvSiz            ENDIF             GOTO 10 \! go build next TYPE statement          ELSE             source:=source+"; " \! prepare to add next var type to statement          ENDIF         ENDIF         (* add current name to statement if not end of statement *)        source:=source+varFRec.vName \! add var name to source statement        tName:=varFRec.vName \! set last var name        tVar:=varFRec.pVar        IF SUBSTR("c",tName)>0 THEN           tRec:=varFRec.vRecNum          tSiz:=varFRec.dsvSiz        ENDIF       ELSE         (* add current name to statement if beginning of statement *)        IF RIGHT$(source,1)="=" THEN           source:=source+varFRec.vName        ENDIF       ENDIF     ENDIF   ENDIF IF varRec(recNum).nTyp=1 OR varRec(recNum).nTyp=2 THEN  \! DIM/PARAM statements(* Start DIM/PARAM Statements *)IF NOT(hasRecords) AND SUBSTR("S",varFRec.vName)>0 THEN tStrLen:=varFRec.vStrLenENDIF (* nTyp separates user named variables from subroutine names and internal *)(* variables associated to TO and STEP values in FOR/NEXT loops *)15 IF source="" THEN IF varRec(recNum).nTyp=1 THEN 
source:="DIM "+varFRec.vNameELSE
source:="PARAM "+varFRec.vName
ENDIF
ENDIF GOSUB 200 \! check for arrayIF varFRec.vName<>tName THEN IF RIGHT$(source,1)<>" " THEN endOfType:=FALSE(* Is same type? *)IF tName<>"" THEN (* Parameter variables are named Pvnnnn, ex: PR0065 is a REAL type parameter *)(* Program variables are named Vnnnn, ex: L0044 is a BOOLEAN type variable *)IF SUBSTR("S",tName)>0 AND tStrLen<>varFRec.vStrLen THEN endOfType:=TRUEELSE IF tRec<>varFRec.vRecNum AND SUBSTR("C",tName)>0 THEN endOfType:=TRUEELSE IF LEFT$(tName,1)<>"P" AND LEFT$(varFRec.vName,1)<>"P" THEN IF LEFT$(varFRec.vName,1)=LEFT$(tName,1) THEN IF varCntr=10 THEN varCntr:=1endOfType:=TRUEELSE varCntr:=varCntr+1source:=source+","ENDIF ELSE endOfType:=TRUEvarCntr:=1ENDIF ENDIF IF LEFT$(tName,1)="P" AND LEFT$(varFRec.vName,1)="P" THEN IF MID$(varFRec.vName,2,1)=MID$(tName,2,1) THEN IF varCntr=10 THEN varCntr:=1endOfType:=TRUEELSE varCntr:=varCntr+1source:=source+","ENDIF ELSE endOfType:=TRUEvarCntr:=1ENDIF ENDIF IF LEFT$(tName,1)<>"P" AND LEFT$(varFRec.vName,1)="P" THEN endOfType:=TRUEtName:=varFRec.vNameENDIF ENDIF ENDIF ENDIF (* End of same type? *)IF endOfType THEN GOSUB 210 \! end of type(* End of statement? *)IF varFRec.pVar=0 THEN IF oOpen THEN PRINT #oPath,sourceENDIF IF wOpen THEN PRINT sourceENDIF source:=""tName:=varFRec.vNametStrLen:=varFRec.vStrLentnTyp:=varRec(recNum).nTypIF SUBSTR("C",tName)>0 THEN tRec:=varFRec.vRecNumtSiz:=varFRec.dsvSizENDIF GOTO 15ENDIF ENDIF IF RIGHT$(source,1)=" " OR RIGHT$(source,1)="," THEN source:=source+varFRec.vNameENDIF tName:=varFRec.vNametStrLen:=varFRec.vStrLenIF SUBSTR("C",tName)>0 THEN tRec:=varFRec.vRecNumtSiz:=varFRec.dsvSizENDIF ENDIF ENDIF ENDIF (* end of user variables *)IF varRec(recNum).nTyp=3 THEN GOSUB 210 \! end of typeIF wOpen THEN PRINT sourceENDIF IF oOpen THEN PRINT #oPath,sourceENDIF tnTyp:=varRec(recNum).nTypsource:=""recNum:=varCount
ELSE
recNum:=recNum+1ENDIF 
UNTIL recNum=varCount(* Close Files *)CLOSE #pathpOpen:=FALSECLOSE #vPathvOpen:=FALSEIF oOpen THEN CLOSE #oPathoOpen:=FALSEENDIF (* Chain to Instruction *)CHAIN chainMod(* End of Program *)END (* ============= *)(* Subroutines *)(* == Group 1 == *)(* Display and Input *)(* Reset Pause and Page *)100 packet(7):=0 \packet(8):=$18callCode:=$8Eregs.a:=2regs.b:=$00regs.x:=ADDR(packet)RUN SysCall(callCode,regs)RETURN (* Set Pause and Page *)105 packet(7):=1 \packet(8):=$12callCode:=$8Eregs.a:=2regs.b:=$00regs.x:=ADDR(packet)RUN SysCall(callCode,regs)RETURN 110 RUN GFX2("CURXY",col,row) \ RETURN 114 RUN GFX2("CLEAR") \ RETURN 115 RUN GFX2("EREOLINE") \ RETURN 116 RUN GFX2("CUROFF") \ RETURN 117 RUN GFX2("CURON") \ RETURN 118 RUN GFX2("OWSET",1,0,1,80,22,options(3),options(4)) \ RETURN
120 RUN GFX2("OWSET",1,0,2,80,21,options(5),options(6)) \ RETURN
125 RUN GFX2("OWSET",1,0,4,80,18,options(7),options(8)) \ RETURN
130 RUN GFX2("OWEND") \ RETURN (* ============= *)(* Get Keypress *)140 key:=""REPEAT RUN Inkey(key)IF key>="A" AND key<="Z" THEN key:=CHR$(ASC(key)+$20)ENDIF UNTIL key="y" OR key="n" OR key=CHR$(13)GOSUB 116 \! turn cursor offcol:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \! set cursor position and erase to end-of-lineRETURN (* ============= *)(* Date and Time Stamp *)(* Display completion time *)145 iHour:=hour \iMinute:=minute \iSecond:=secondGOSUB 150 \! get date/time infoeHour:=hour \eMinute:=minute \eSecond:=secondIF eHour<iHour THEN tHour:=eHour+12-iHourELSE tHour:=eHour-iHour \ ENDIF IF eMinute<iMinute THEN tMinute:=eMinute+60-iMinuteELSE tMinute:=eMinute-iMinute \ ENDIF IF eSecond<iSecond THEN tSecond:=eSecond+60-iSecondELSE tSecond:=eSecond-iSecond \ ENDIF IF eSecond<iSecond AND tSecond<60 THEN tMinute:=tMinute-1 \ ENDIF
IF eMinute<iMinute AND tMinute<60 THEN tHour:=tHour-1 \ ENDIF IF tHour<10 THEN PRINT "0"; tHour; ":"; ELSE PRINT tHour; ":";  \ ENDIF IF tMinute<10 THEN PRINT "0"; tMinute; ":"; ELSE PRINT tMinute; ":";  \ ENDIF IF tSecond<10 THEN PRINT "0"; tSecondELSE PRINT tSecond \ ENDIF RETURN (* ============= *)(* Date Stamp *)150 dateTime:=DATE$month:=VAL(MID$(dateTime,4,2))day:=VAL(MID$(dateTime,7,2))year:=2000+VAL(LEFT$(dateTime,2))hour:=VAL(MID$(dateTime,10,2))minute:=VAL(MID$(dateTime,13,2))second:=VAL(MID$(dateTime,16,2))RESTORE 155REPEAT READ number,monthNameUNTIL number=monthRETURN (* ============= *)(* Month Names *)155 DATA 1,"January",2,"February",3,"March"DATA 4,"April",5,"May",6,"June"DATA 7,"July",8,"August",9,"September"DATA 10,"October",11,"November",12,"December"(* ============= *)(* == Group 2 == *)(* These make the array variable names reflect the array elements *)(* Ex: ba039() becomes ba039(3) *)200 IF RIGHT$(varFRec.vName,4)="(,,)" THEN varFRec.vName:=LEFT$(varFRec.vName,LEN(varFRec.vName)-4)+varFRec.vArrayELSE IF RIGHT$(varFRec.vName,3)="(,)" THEN varFRec.vName:=LEFT$(varFRec.vName,LEN(varFRec.vName)-3)+varFRec.vArrayELSE IF RIGHT$(varFRec.vName,2)="()" THEN varFRec.vName:=LEFT$(varFRec.vName,LEN(varFRec.vName)-2)+varFRec.vArrayENDIF ENDIF ENDIF RETURN (* ============= *)210 IF LEFT$(tName,1)="P" THEN posVal:=2ELSE posVal:=1ENDIF IF SUBSTR(MID$(tName,posVal,1),"Bb")>0 THEN source:=source+":BYTE"ELSE IF SUBSTR(MID$(tName,posVal,1),"Ii")>0 THEN source:=source+":INTEGER"ELSE IF SUBSTR(MID$(tName,posVal,1),"Rr")>0 THEN source:=source+":REAL"ELSE IF SUBSTR(MID$(tName,posVal,1),"Ll")>0 THEN source:=source+":BOOLEAN"ELSE IF SUBSTR(MID$(tName,posVal,1),"Ss")>0 THEN source:=source+":STRING"IF tStrLen<>"[32]" THEN source:=source+tStrLenENDIF tStrLen:=varFRec.vStrLenELSE IF SUBSTR(MID$(tName,posVal,1),"Cc")>0 THEN found:=FALSEFOR cntr:=0 TO recCnt-1IF tRec=rec(cntr).recID THEN source:=source+":"+rec(cntr).recNamefound:=TRUEENDIF NEXT cntrIF NOT(found) THEN typCnt:=typCnt+1ucCnt:=ucCnt+1typName:="TYP"+STR$(typCnt)IF wOpen THEN PRINT "TYPE "; typName; "=uC"; ucCnt; "("; tSiz; "):BYTE"ENDIF IF oOpen THEN PRINT #oPath,"TYPE "; typName; "=uC"; ucCnt; "("; tSiz; "):BYTE"ENDIF source:=source+":"+typNameENDIF (* Have to figure this part out *)ENDIF ENDIF ENDIF ENDIF ENDIF ENDIF RETURN (* ============= *)
(* Validate Gaps *)
220 SEEK #path,dsatOff+gapOff(nextOff)
GET #path,intVal
IF wOpen THEN 
  PRINT #2 USING "h4,s1",intVal," "; 
ENDIF 
IF oOpen THEN 
  PRINT #oPath USING "h4,s1",intVal," "; 
ENDIF 
GET #path,intVal
IF wOpen THEN 
  PRINT #2 USING "h4,s1",intVal," "; 
ENDIF 
IF oOpen THEN 
  PRINT #oPath USING "h4,s1",intVal," "; 
ENDIF 
GET #path,byteVal
IF wOpen THEN 
  PRINT #2 USING "h4,s1",byteVal," "; 
ENDIF 
IF oOpen THEN 
  PRINT #oPath USING "h4,s1",byteVal," "; 
ENDIF 
FOR ucCnt=1 TO (gapSize(nextOff)-5)/2
  GET #path,intVal
  IF wOpen THEN 
    PRINT #2 USING "h4,s1",intVal," "; 
  ENDIF 
  IF oOpen THEN 
    PRINT #oPath USING "h4,s1",intVal," "; 
  ENDIF 
NEXT ucCnt
RETURN
(* ============= *)(* Display Counts *)268 col:=14 \row:=16 \ GOSUB 110 \! set cursor positionPRINT USING "i5>",dsatCnt; RETURN 269 col:=14 \row:=17 \ GOSUB 110 \! set cursor positionPRINT USING "i5>",cntr; RETURN (* ============= *)(* == Group 3 == *)(* No Group 3 Routines *)(* ============= *)(* == Group 4 == *)(* Delay Loop *)450 FOR delay=1 TO 12000 \NEXT delayRETURN (* ============= *)(* == Group 5 == *)(* Error Trap *)500 IF er=0 THEN er:=ERRENDIF IF wOpen THEN GOSUB 130 \ GOSUB 130 \ GOSUB 130 \! close overlaysENDIF IF pOpen THEN CLOSE #pathpOpen:=FALSEENDIF IF vOpen THEN CLOSE #vPathvOpen:=FALSEENDIF IF dOpen THEN CLOSE #dPathdOpen:=FALSEENDIF GOSUB 117 \! turn cursor oncol:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \! set cursor position and erase to end-of-lineON ERROR GOTO 510(* For brief error messages, change ,1 to ,0 *)SHELL "RunB ErrorCodes ("+STR$(er)+",1)"END (* ============= *)(* If ErrorCodes is not found *)510 er1:=ERRIF er1=43 THEN PRINT #2,"Error: "; erENDIF END (* ============= *)PROCEDURE dsSort(* based on quicksort, by T.F. Ritter(* DSAT Map *)TYPE DSMP=dsOf,dsDm,dsMSz,dsSz:INTEGERDIM DSMap:DSMPPARAM er,which:INTEGER; bottom,top:INTEGER; DSMaps(100):DSMPDIM lower,upper:INTEGER; btemp:BOOLEANON ERROR GOTO 10which:=which+1RUN GFX2("CURXY",55,16) \ PRINT which; BASE 0lower:=bottomupper:=topLOOP  \! each element gets the once overREPEAT  \! this is a postinc instructionbtemp:=DSMaps(lower).dsOf<DSMaps(top).dsOflower:=lower+1UNTIL NOT(btemp)lower:=lower-1 \! point at the tested elementEXITIF lower=upper THEN ENDEXIT REPEAT  \! this is a postdec instructionupper:=upper-1UNTIL DSMaps(upper).dsOf<=DSMaps(top).dsOf OR upper=lowerEXITIF lower=upper THEN ENDEXIT DSMap:=DSMaps(lower)DSMaps(lower):=DSMaps(upper)DSMaps(upper):=DSMaplower:=lower+1 \! prepare for postincEXITIF lower=upper THEN ENDEXIT ENDLOOP IF lower<>top THEN IF DSMaps(lower).dsOf<>DSMaps(top).dsOf THEN DSMap:=DSMaps(lower)DSMaps(lower):=DSMaps(top)DSMaps(top):=DSMapENDIF ENDIF IF bottom<lower-1 THEN RUN dsSort(er,which,bottom,lower-1,DSMaps)ENDIF IF lower+1<top THEN RUN dsSort(er,which,lower+1,top,DSMaps)ENDIF END 10 er:=ERREND 