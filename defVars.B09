PROCEDURE defVars(* Version 1.2.10 *)(* Variable Array Record *)TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGERDIM varRec(400):VREC(* Variable File Record *)TYPE VFRC=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGER; vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGER; mTyp,vLnk:BYTE; pRec,pFld:BOOLEANDIM varFRec:VFRC(* Registers *)TYPE REG=cc,a,b,dp:BYTE; x,y,u:INTEGERDIM regs:REG(* ==================== *)(* Input Variables *)DIM tokenCode,tokenByte,byteVal,packet(32),callCode:BYTE; intVal:INTEGER(* Various counters *)DIM iToken,vToken:BYTEDIM recNum,mSize,mCount,VDCount,VDCnt,vdtCnt,fRecs,iPointer,vAddr,vPointer,vSize:INTEGERDIM dsAddr,dsPointer,dSize,dsSize,dmAddr,dmSize,pAddr,pSize,fAddr,fSize,element1:INTEGERDIM element2,element3,strRecLen,recSize,recArraySize,gapOff(20),gapSize(20),gapCnt,delay:INTEGER(* Flag Variables *)DIM found,isSimple,isParam,isString,isRecord,isArray,isArray1,isArray2,isArray3:BOOLEANDIM isField,validated,hasRecords,first:BOOLEAN(* Variable Reference Counters *)DIM varRefs,varCount,varNum,fldNum:INTEGER(* Program Options *)DIM options(26):BYTE(* File paths *)DIM path,vPath,dPath,oPath:BYTE(* File status *)DIM pOpen,vOpen,dOpen,oOpen:BOOLEAN(* Error Data *)DIM er,er1,which:INTEGER(* Module Data *)DIM modSiz,dataSiz,execOff,dsatOff,vdtOff,tpVars,dataStAdd:INTEGER(* File names *)DIM vFile,lnFile,dFile,oFile:STRING[29](* Command String *)DIM chainMod:STRING[177](* Strings *)DIM numStr:STRING[4]DIM strLen:STRING[7]DIM version,tokenString:STRING[8]DIM arrayStr:STRING[19]DIM subName,tName:STRING[29](* ==================== *)(* Display and Other *)(* Colors Record *)TYPE COLR=white,blue,black,green,red,yellow,magenta,cyan,white2,blue2,black2,green2,red2,yellow2,magenta2,cyan2:BYTEDIM color:COLR(* Display Variables *)DIM displays,wOpen:BOOLEANDIM key:STRING[1](* String Constants *)DIM cPrompt:STRING[25](* Column,Row *)DIM col,col1,row:BYTE(* Time Stamp *)DIM monthName:STRING[9]DIM dateTime:STRING[17]DIM month,day,year,hour,minute,second,number:INTEGERDIM sMonth,sDay,sYear,sHour,sMinute,sSecond:INTEGERDIM eHour,eMinute,eSecond:INTEGERDIM tHour,tMinute,tSecond:INTEGERDIM iHour,iMinute,iSecond:INTEGER(* ==================== *)(* Parameters PARAMs also passed to buildSrc *)PARAM proc:STRING[80]; modName,dataDir:STRING[29](* Initializations *)BASE 0(* Get Pause and Page *)callCode:=$8D \(* Get Window Packet *)regs.a:=2regs.b:=$00regs.x:=ADDR(packet)RUN SysCall(callCode,regs)er:=0 \er1:=0 \which:=0ON ERROR GOTO 500 \!goto error trapdFile:=dataDir+"initDB"dOpen:=FALSEOPEN #dPath,dFile:READdOpen:=TRUEGET #dPath,versionGET #dPath,optionsSEEK #dPath,258+SIZE(options) \!skip token counter arrayGET #dPath,color \!colors record, used in overlay windowsCLOSE #dPathdOpen:=FALSEcPrompt:="Press [ENTER] To Continue"wOpen:=FALSE \oOpen:=FALSEvFile:=dataDir+"varDefs"lnFile:=dataDir+"linDefs"dFile:=dataDir+"procData"(* Chain Module String *)chainMod:="ex RunB #32K buildSrc ("""+proc+""","""+modName+""","""+dataDir+""")"(* Get data *)GOSUB 116 \!turn cursor offcol:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \!set cursor position and erase to end-of-linePRINT #2, "Reading Data File...";OPEN #dPath,dFile:READdOpen:=TRUE(* Display related *)GET #dPath,displays \(* Procedure has records *)GET #dPath,hasRecords(* Start Time Variables *)GET #dPath,sHour \ GET #dPath,sMinute \ GET #dPath,sSecondGET #dPath,modSiz \ GET #dPath,dataSiz \ GET #dPath,execOffGET #dPath,dsatOff \ GET #dPath,vdtOff \ GET #dPath,tpVarsGET #dPath,dataStAdd(* Variables lookup table *)GET #dPath,varRecCLOSE #dPathdOpen:=FALSEPRINT #2, "Done";GOSUB 450 \!delay before erasing bottom lineGOSUB 110 \ GOSUB 115(* Open Variable Reference File *)OPEN #vPath,vFile:UPDATEvOpen:=TRUEGET #vPath,varCount(* Open File *)OPEN #path,proc:READpOpen:=TRUESEEK #path,dsatOff(* Begin Variable Identification *)(* Displays *)IF displays  AND options(14)=1 THEN  wOpen:=TRUEENDIFGOSUB 150 \!get date/time infocol:=47 \row:=14 \ GOSUB 110 \!set cursor positionPRINT #2, "Identifying";first:=TRUEGOSUB 200IF wOpen THEN  GOSUB 105 \!turn page pause onENDIFrecNum:=0 \hasRecords:=FALSESEEK #vPath,recNum*SIZE(varFRec)+2(* Read Data *)REPEAT  iToken:=0 \iPointer:=0  dmAddr:=0 \dmSize:=0  dsAddr:=0 \dsPointer:=0 \dsSize:=0 \dSize:=0  vAddr:=0 \vPointer:=0 \vToken:=0 \vSize:=0  pAddr:=0 \pSize:=0  fAddr:=0 \fSize:=0  element1:=0 \element2:=0 \element3:=0  strRecLen:=0 \recSize:=0 \recArraySize:=0  subName:="" \arrayStr:="" \strLen:=""  isSimple:=FALSE \isParam:=FALSE \isString:=FALSE \isRecord:=FALSE \isField:=FALSE  isArray:=FALSE \isArray1:=FALSE \isArray2:=FALSE \isArray3:=FALSE  (* Next Record *)  GET #vPath,varFRec  iToken:=varRec(recNum).vTyp  iPointer:=varRec(recNum).vOff  RESTORE 430 \!set to Atomic variable name labels  (* Simple Atomic *)  IF varFRec.mTyp=1 THEN    (* VDT, Param and Field entry not necessary if type 1 *)    (* Get Name String *)    tokenCode:=varRec(recNum).vTyp    GOSUB 410 \!get initial variable name identifer    varFRec.vName:=tokenString    subName:=tokenString    (* Data Memory Address and Variable Size *)    dmAddr:=iPointer    IF varRec(recNum).vTyp=$80 OR varRec(recNum).vTyp=$83 THEN      varRec(recNum).nTyp:=1      varFRec.intReal:=0      dmSize:=1    ENDIF    IF varRec(recNum).vTyp=$81 OR varRec(recNum).vTyp=$00 OR varRec(recNum).vTyp=$01 THEN      IF NOT(varRec(recNum).nVar) THEN        varRec(recNum).nTyp:=3        varFRec.intReal:=1      ELSE        varRec(recNum).nTyp:=1        varFRec.intReal:=0      ENDIF      dmSize:=2    ENDIF    IF varRec(recNum).vTyp=$82 OR varRec(recNum).vTyp=$02 OR varRec(recNum).vTyp=$03 THEN      IF NOT(varRec(recNum).nVar) THEN        varRec(recNum).nTyp:=3        varFRec.intReal:=2      ELSE        varRec(recNum).nTyp:=1        varFRec.intReal:=0      ENDIF      dmSize:=5    ENDIF    IF varRec(recNum).vTyp=$46 OR varRec(recNum).vTyp=$47 THEN      varRec(recNum).nTyp:=3      IF varFRec.intReal=1 THEN        dmSize:=2      ELSE        IF varFRec.intReal=2 THEN          dmSize:=5        ENDIF      ENDIF    ENDIF    varRec(recNum).dmOff:=dmAddr    varFRec.dmSiz:=dmSize  ENDIF  (* STRING *)  IF varFRec.mTyp=2 THEN    (* VDT, Param and Field entry not necessary if type 2 *)    isString:=TRUE    (* Get Name String *)    tokenCode:=varRec(recNum).vTyp    varRec(recNum).nTyp:=1    GOSUB 410 \!get initial variable name identifer    varFRec.vName:=tokenString    subName:=tokenString    (* DSAT Address and Entry Size *)    dsAddr:=iPointer    varRec(recNum).dsOff:=dsAddr    dsSize:=4    varFRec.dsSiz:=dsSize    SEEK #path,dsatOff+dsAddr    GET #path,intVal    (* Data Memory Address and Variable Size *)    dmAddr:=intVal    varRec(recNum).dmOff:=dmAddr    dsPointer:=intVal    varFRec.dsPtr:=dsPointer    GET #path,intVal    dmSize:=intVal    varFRec.dmSiz:=dmSize    dSize:=intVal    varFRec.dsvSiz:=dSize    strLen:="["+STR$(dmSize)+"]"    varFRec.vStrLen:=strLen  ENDIF  (* VDT references *)  (* All references include VDT entry, DSAT, Param and Field entries vary *)  IF varFRec.mTyp=3 THEN    (* Variables *)    (* VDT Address and Entry Size *)    vAddr:=iPointer    varRec(recNum).vdOff:=vAddr    vSize:=3    varFRec.vdSiz:=vSize    SEEK #path,vdtOff+vAddr    (* VDT Token Value *)    GET #path,byteVal    vToken:=byteVal    varFRec.vdTkn:=vToken    (* Get Name String *)    tokenCode:=vToken    RESTORE 420 \!set to VDT variable name labels    GOSUB 410 \!get initial variable name identifer    varFRec.vName:=tokenString    subName:=tokenString    (* VDT Pointer Value *)    (* Points to DSAT, DM or PARAM *)    GET #path,intVal    vPointer:=intVal    varFRec.vdPtr:=vPointer    (* Subroutines *)    IF vToken=$A0 THEN      (* Pointer to Data Memory Offset, DM contains INTEGER *)      varRec(recNum).nTyp:=3      dmAddr:=vPointer      varRec(recNum).dmOff:=dmAddr      dmSize:=2      varFRec.dmSiz:=dmSize      (* Get Name String *)      REPEAT        GET #path,byteVal        subName:=subName+CHR$(LAND(byteVal,$7F))        vSize:=vSize+1      UNTIL byteVal>127      varFRec.vName:=subName    (* All Other VDT Entries *)    ELSE      IF vToken>=$60 AND vToken<=$63 THEN        isSimple:=TRUE        (* Data Memory Address and Variable Size *)        varRec(recNum).nTyp:=1        dmAddr:=vPointer        varRec(recNum).dmOff:=dmAddr        IF vToken=$60 OR vToken=$63 THEN          dmSize:=1        ENDIF        IF vToken=$61 THEN          dmSize:=2        ENDIF        IF vToken=$62 THEN          dmSize:=5        ENDIF        varFRec.dmSiz:=dmSize      ENDIF      IF vToken>=$40 AND vToken<=$43 THEN        varRec(recNum).nTyp:=0        isSimple:=TRUE        isField:=TRUE        varRec(recNum).dmOff:=0        varFRec.dmSiz:=0        (* Field Address and Variable Size *)        fAddr:=vPointer        varRec(recNum).fOff:=fAddr        IF vToken=$40 OR vToken=$43 THEN          fSize:=1        ENDIF        IF vToken=$41 THEN          fSize:=2        ENDIF        IF vToken=$42 THEN          fSize:=5        ENDIF        varFRec.fSiz:=fSize      ENDIF      IF vToken>=$80 AND vToken<=$83 THEN        varRec(recNum).nTyp:=2        isSimple:=TRUE        isParam:=TRUE        (* Parameter Address and Expected Size *)        pAddr:=vPointer        varRec(recNum).pOff:=pAddr        varRec(recNum).dmOff:=pAddr        IF vToken=$80 OR vToken=$83 THEN          pSize:=1        ENDIF        IF vToken=$81 THEN          pSize:=2        ENDIF        IF vToken=$82 THEN          pSize:=5        ENDIF        varFRec.pSiz:=pSize        varFRec.dmSiz:=4      ENDIF      IF NOT(isSimple) THEN        (* Define Types *)        IF vToken>=$44 AND vToken<=$5D THEN          varRec(recNum).nTyp:=0          isField:=TRUE        ENDIF        IF vToken>=$64 AND vToken<=$7D THEN          varRec(recNum).nTyp:=1        ENDIF        IF vToken>=$84 AND vToken<=$9D THEN          varRec(recNum).nTyp:=2          isParam:=TRUE        ENDIF        IF vToken=$44 OR vToken=$4C OR vToken=$54 OR vToken=$5C THEN          isString:=TRUE        ENDIF        IF vToken=$64 OR vToken=$6C OR vToken=$74 OR vToken=$7C THEN          isString:=TRUE        ENDIF        IF vToken=$84 OR vToken=$8C OR vToken=$94 OR vToken=$9C THEN          isString:=TRUE        ENDIF        IF vToken=$45 OR vToken=$4D OR vToken=$55 OR vToken=$5D THEN          isRecord:=TRUE        ENDIF        IF vToken=$65 OR vToken=$6D OR vToken=$75 OR vToken=$7D THEN          isRecord:=TRUE        ENDIF        IF vToken=$85 OR vToken=$8D OR vToken=$95 OR vToken=$9D THEN          isRecord:=TRUE        ENDIF        IF isRecord and NOT(hasRecords) THEN          hasRecords:=TRUE        ENDIF        IF vToken>=$48 AND vToken<=$4D THEN          isArray:=TRUE \isArray1:=TRUE        ENDIF        IF vToken>=$68 AND vToken<=$6D THEN          isArray:=TRUE \isArray1:=TRUE        ENDIF        IF vToken>=$88 AND vToken<=$8D THEN          isArray:=TRUE \isArray1:=TRUE        ENDIF        IF vToken>=$50 AND vToken<=$55 THEN          isArray:=TRUE \isArray2:=TRUE        ENDIF        IF vToken>=$70 AND vToken<=$75 THEN          isArray:=TRUE \isArray2:=TRUE        ENDIF        IF vToken>=$90 AND vToken<=$95 THEN          isArray:=TRUE \isArray2:=TRUE        ENDIF        IF vToken>=$58 AND vToken<=$5D THEN          isArray:=TRUE \isArray3:=TRUE        ENDIF        IF vToken>=$78 AND vToken<=$7D THEN          isArray:=TRUE \isArray3:=TRUE        ENDIF        IF vToken>=$98 AND vToken<=$9D THEN          isArray:=TRUE \isArray3:=TRUE        ENDIF        (* DSAT Address and Entry Size *)        dsAddr:=vPointer        varRec(recNum).dsOff:=dsAddr        dsSize:=2        (* dsPointer points to DSAT, DM or PARAM *)        SEEK #path,dsatOff+dsAddr        GET #path,intVal        dsPointer:=intVal        varFRec.dsPtr:=dsPointer        (* dSize relative to dsPointer *)        GET #path,intVal        dSize:=intVal        varFRec.dsvSiz:=dSize        dsSize:=dsSize+2        IF isString THEN          IF NOT(isParam) AND NOT(isField) THEN            (* Data Memory Address and Variable Size *)            dmAddr:=dsPointer            varRec(recNum).dmOff:=dmAddr            dmSize:=dSize            varFRec.dmSiz:=dmSize          ENDIF          IF NOT(isArray) THEN            strLen:="["+STR$(dSize)+"]"            varFRec.vStrLen:=strLen          ENDIF        ENDIF        IF isRecord THEN          IF NOT(isParam) AND NOT(isField) THEN            (* Data Memory Address and Variable Size *)            dmAddr:=dsPointer            varRec(recNum).dmOff:=dmAddr            dmSize:=dSize            varFRec.dmSiz:=dmSize          ENDIF          recSize:=dSize        ENDIF        IF isField THEN          (* Field Simple Types *)          (* Pointer to position in a record, size based on type *)          (* Field Address and Variable Size *)          fAddr:=dsPointer          varRec(recNum).fOff:=fAddr          fSize:=dSize          varFRec.fSiz:=fSize          varRec(recNum).dmOff:=0          varFRec.dmSiz:=0        ENDIF        IF isParam THEN          (* Parameter Simple Types *)          (* Pointer to Parameter List offset, size is 4 (length of parameter list entry) *)          (* Parameter Address and Expected Size *)          pAddr:=dsPointer          varRec(recNum).pOff:=pAddr          varRec(recNum).dmOff:=pAddr          pSize:=dSize          varFRec.pSiz:=pSize          varFRec.dmSiz:=4        ENDIF        IF isArray THEN          IF NOT(isParam) AND NOT(isField) THEN            (* Data Memory Address and Variable Size *)            dmAddr:=dsPointer            varRec(recNum).dmOff:=dmAddr            dmSize:=dSize            varFRec.dmSiz:=dmSize          ENDIF          arrayStr:=""          GET #path,intVal          element1:=intVal          varFRec.elem1:=element1          arrayStr:=arrayStr+"("+STR$(element1)          dsSize:=dsSize+2          IF isArray2 OR isArray3 THEN            GET #path,intVal            element2:=intVal            varFRec.elem2:=element2            arrayStr:=arrayStr+","+STR$(element2)            dsSize:=dsSize+2          ENDIF          IF isArray3 THEN            GET #path,intVal            element3:=intVal            varFRec.elem3:=element3            arrayStr:=arrayStr+","+STR$(element3)            dsSize:=dsSize+2          ENDIF          arrayStr:=arrayStr+")"          varFRec.vArray:=arrayStr          (* STRING/Record variable *)          IF isString OR isRecord THEN            GET #path,intVal            strRecLen:=intVal            varFRec.vSRLen:=strRecLen            dsSize:=dsSize+2            IF isString THEN              strLen:="["+STR$(strRecLen)+"]"              varFRec.vStrLen:=strLen            ENDIF            IF isRecord THEN              recArraySize:=recSize              recSize:=strRecLen            ENDIF          ENDIF        ENDIF        (* Set DSAT Entry Size *)        IF dsSize>0 THEN          varFRec.dsSiz:=dsSize        ENDIF      ENDIF    ENDIF  ENDIF  (* Resets *)  IF isRecord AND NOT(varFRec.pRec) THEN    varFRec.pRec:=TRUE  ENDIF  IF NOT(isRecord) AND varFRec.pRec THEN    varFRec.pRec:=FALSE  ENDIF  IF isField AND NOT(varFRec.pFld) THEN    varFRec.pFld:=TRUE  ENDIF  IF NOT(isField) AND varFRec.pFld THEN    varFRec.pFld:=FALSE  ENDIF  IF NOT(isString) THEN    varFRec.vStrLen:=""  ENDIF  IF NOT(isArray) THEN    varFRec.vArray:=""  ENDIF  GOSUB 250 \!Display Variable References  SEEK #vPath,recNum*SIZE(varFRec)+2  PUT #vPath,varFRec  recNum:=recNum+1UNTIL recNum=varCountIF wOpen THEN  PRINT #2  \ PRINT #2, cPrompt;  GOSUB 140 \!get keypress  GOSUB 100 \!turn page pause off  GOSUB 130 \!close overlay  GOSUB 130 \!close overlay  GOSUB 130 \!close overlay  wOpen:=FALSEENDIFcol:=47 \row:=14 \ GOSUB 110 \!set cursor positionPRINT #2, "Identified ";(* Sort Variables *)col:=47 \row:=14 \ GOSUB 110 \!set cursor positionPRINT #2, "Sorting   ";SEEK #vPath,0RUN vSort (er,which,vPath,0,varCount-1,varRec)IF er>0 THEN 500 \!goto error trap(* The bubble sort for sorting the field records *)(* Count field records *)fRecs:=0REPEAT  SEEK #vPath,fRecs*SIZE(varFRec)+2  GET #vPath,varFRec  fRecs:=fRecs+1UNTIL varFRec.vdTkn>$5F OR varFRec.vdTkn=0fRecs:=fRecs-1IF fRecs>0 THEN  col:=47 \row:=14 \ GOSUB 110 \!set cursor position  PRINT #2, "Sorting "; fRecs; " Fields";  RUN fSort (vPath,0,fRecs,varRec)ENDIFOPEN #dPath,dFile:UPDATEIF hasRecords THEN  SEEK #dPath,1  PUT #dPath,hasRecordsENDIFSEEK #dPath,22PUT #dPath,varRecCLOSE #dPathcol:=47 \row:=14 \ GOSUB 110 \!set cursor positionPRINT #2, "Sorted           ";(* Display Naming Variables? *)IF displays AND options(15)=1 THEN  wOpen:=TRUEENDIFcol:=47 \row:=14 \ GOSUB 110 \!set cursor positionPRINT #2, "Naming";IF wOpen THEN  GOSUB 105 \!turn page pause on  GOSUB 118 \!Open background overlay  PRINT #2, " Variable References: Naming";  GOSUB 120 \!open middle overlay  PRINT #2  PRINT #2, "Record Variable Name"  GOSUB 125 \!open foreground overlayENDIF(* Name Variables *)recNum:=0 \varNum:=1 \fldNum:=1 \numStr:=""fAddr:=0 \dmAddr:=0 \tName:=""REPEAT  SEEK #vPath,recNum*SIZE(varFRec)+2  GET #vPath,varFRec  IF varRec(recNum).nVar THEN    IF varRec(recNum).nTyp=0 THEN      IF fldNum<10 THEN        numStr:="00"+STR$(fldNum)      ELSE        numStr:="0"+STR$(fldNum)      ENDIF      IF recNum>0 AND varRec(recNum).fOff=fAddr THEN        varFRec.vName:=tName      ELSE        IF RIGHT$(varFRec.vName,1)=")" THEN          varFRec.vName:=LEFT$(varFRec.vName,2)+numStr+RIGHT$(varFRec.vName,LEN(varFRec.vName)-2)        ELSE          varFRec.vName:=LEFT$(varFRec.vName,1)+numStr        ENDIF        fAddr:=varRec(recNum).fOff        tName:=varFRec.vName        fldNum:=fldNum+1      ENDIF    ELSE      IF varRec(recNum).nTyp=1 THEN        IF varNum<10 THEN          numStr:="000"+STR$(varNum)        ELSE          IF varNum<100 THEN            numStr:="00"+STR$(varNum)          ELSE            numStr:="0"+STR$(varNum)          ENDIF        ENDIF        IF dmAddr>0 AND varRec(recNum).dmOff=dmAddr THEN          varFRec.vName:=tName        ELSE          IF RIGHT$(varFRec.vName,1)=")" THEN            varFRec.vName:=LEFT$(varFRec.vName,2)+numStr+RIGHT$(varFRec.vName,LEN(varFRec.vName)-2)          ELSE            varFRec.vName:=LEFT$(varFRec.vName,1)+numStr          ENDIF          dmAddr:=varRec(recNum).dmOff          tName:=varFRec.vName          varNum:=varNum+1        ENDIF      ELSE        IF varRec(recNum).nTyp=2 THEN          IF varNum<10 THEN            numStr:="000"+STR$(varNum)          ELSE            IF varNum<100 THEN              numStr:="00"+STR$(varNum)            ELSE              numStr:="0"+STR$(varNum)            ENDIF          ENDIF          IF varRec(recNum).dmOff=dmAddr THEN            varFRec.vName:=tName          ELSE            IF RIGHT$(varFRec.vName,1)=")" THEN              varFRec.vName:=LEFT$(varFRec.vName,3)+numStr+RIGHT$(varFRec.vName,LEN(varFRec.vName)-3)            ELSE              varFRec.vName:=LEFT$(varFRec.vName,2)+numStr            ENDIF            dmAddr:=varRec(recNum).dmOff            tName:=varFRec.vName            varNum:=varNum+1          ENDIF        ENDIF      ENDIF    ENDIF  ENDIF  IF wOpen THEN      PRINT #2 USING "i6>,s1,s29", recNum, " ", varFRec.vName  ENDIF  IF varRec(recNum).nVar THEN    SEEK #vPath,recNum*SIZE(varFRec)+2    PUT #vPath,varFRec  ENDIF  recNum:=recNum+1UNTIL recNum=varCountIF wOpen THEN  GOSUB 100 \!turn page pause off  PRINT #2  \ PRINT #2, "Press [ENTER] To Continue";  GOSUB 140 \!get keypress  GOSUB 130 \!close overlay  GOSUB 130 \!close overlay  GOSUB 130 \!close overlay  wOpen:=FALSEENDIFcol:=47 \row:=14 \ GOSUB 110 \!set cursor positionPRINT #2, "Named ";(* Display completion time *)col:=69 \ GOSUB 110 \!set cursor positionGOSUB 145 \!get date and time info(* Display Sorted Variables? *)IF displays AND options(16)=1 THEN  wOpen:=TRUEENDIF(* Write and display variable records *)IF options(23)=1 THEN  oFile:=modName+"Vars.txt"  col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \!set cursor position  PRINT #2, "Writing "; oFile; "...";  CREATE #oPath, oFile  oOpen:=TRUE  GOSUB 269 \!Write Variable Reference LabelsENDIFIF wOpen THEN  first:=FALSE  GOSUB 200 \!Display Variable Reference Labels  GOSUB 105 \!turn page pause onENDIFSEEK #vPath,2FOR recNum:=0 TO varCount-1  GET #vPath,varFRec  IF wOpen THEN    GOSUB 250 \!Display Variable References  ENDIF  IF oOpen THEN    GOSUB 270 \!Write Variable References  ENDIFNEXT recNumIF wOpen THEN  PRINT #2  \ PRINT #2, cPrompt;  GOSUB 140 \!get keypress  GOSUB 100 \!turn page pause off  GOSUB 130 \!close overlay  GOSUB 130 \!close overlay  GOSUB 130 \!close overlay  wOpen:=FALSEENDIFIF oOpen THEN  CLOSE #oPath  oOpen:=FALSE(*  col:=LEN(oFile)+11 \row:=23 \ GOSUB 110 \!set cursor position  PRINT #2, "Done";  GOSUB 450 \!delay before erasing bottom lineENDIF(* Validate VDT *)mSize:=modSiz-3-vdtOffIF mSize>0 THEN  (* Open Output File *)  IF options(24)=1 THEN    oFile:=modName+"VDT.txt"    CREATE #oPath,oFile:UPDATE    oOpen:=TRUE    col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \!set cursor position    PRINT #2, "Writing "; oFile; "...";  ENDIF  IF displays AND options(17)=1 THEN    wOpen:=TRUE  ENDIF  GOSUB 150 \!get date/time info  col:=47 \row:=15 \ GOSUB 110 \!set cursor position  PRINT #2, "Validating";  IF wOpen THEN    GOSUB 105 \!turn page pause on    GOSUB 118 \!Open background overlay    PRINT #2, " VDT Validation";    GOSUB 120 \!open middle overlay    PRINT #2, "  VDT"    PRINT #2, "Tk Ptr  Subroutine"    GOSUB 125 \!open foreground overlay  ENDIF  VDCount:=0 \vdtCnt:=0 \VDCnt:=0 \mCount:=0 \validated:=TRUE  SEEK #path,vdtOff  REPEAT    GET #path,vToken    GET #path,vPointer    mCount:=mCount+3    IF wOpen THEN      PRINT #2 USING "h2,x1,h4",vToken,vPointer;    ENDIF    IF oOpen THEN      PRINT #oPath USING "h2,x1,h4",vToken,vPointer;    ENDIF    IF vToken=$A0 THEN      subName:=""      REPEAT        GET #path,byteVal        subName:=subName+CHR$(LAND(byteVal,$7F))        mCount:=mCount+1      UNTIL byteVal>127      IF wOpen THEN        PRINT #2, " "; subName;      ENDIF      IF oOpen THEN        PRINT #oPath, " "; subName;      ENDIF    ENDIF    found:=FALSE10  SEEK #vPath,VDCount*SIZE(varFRec)+2    REPEAT      GET #vPath,varFRec      IF varFRec.vdTkn=vToken and varFRec.vdPtr=vPointer THEN        found:=TRUE      ENDIF      VDCount:=VDCount+1    UNTIL found OR VDCount=varCount    IF NOT(found) THEN      IF VDCnt=0 THEN        VDCnt:=1 \VDCount:=0        GOTO 10      ENDIF    ENDIF    VDCount:=VDCount-1    IF wOpen THEN      IF found THEN        PRINT #2, " "; varFRec.vName; " Validated"      ELSE        PRINT #2, " Unidentified"        validated:=FALSE      ENDIF    ENDIF    IF found THEN      IF oOpen THEN        PRINT #oPath, " "; varFRec.vName; " Validated"      ENDIF    ELSE      IF oOpen THEN        PRINT #oPath, " Unidentified"      ENDIF    ENDIF    vdtCnt:=vdtCnt+1    IF NOT(wOpen) THEN      GOSUB 267 \!display counts    ENDIF    VDCnt:=0  UNTIL mCount=mSize  IF wOpen THEN    PRINT #2    IF NOT(validated) THEN      PRINT #2, "VDT Size Not Validated"    ELSE      PRINT #2, "VDT Size Validated"    ENDIF    GOSUB 100 \!turn page pause off    PRINT #2  \ PRINT #2, "Press [ENTER] To Continue";    GOSUB 140 \!get keypress    GOSUB 130 \!close overlay    GOSUB 130 \!close overlay    GOSUB 130 \!close overlay    wOpen:=FALSE    GOSUB 267 \!display counts  ENDIF  col:=47 \row:=15 \ GOSUB 110 \!set cursor position  IF NOT(validated) THEN    PRINT #2, "Not Validated";  ELSE    PRINT #2, "Validated ";  ENDIF  (* Display completion time *)  col:=69 \ GOSUB 110 \!set cursor position  GOSUB 145 \!get date and time info  IF oOpen THEN    CLOSE #oPath    oOpen:=FALSE    col:=11+LEN(oFile) \row:=23 \ GOSUB 110 \!set cursor position    PRINT #2, "Done";    GOSUB 450 \!delay before erasing bottom line  ENDIFELSE  col:=47 \row:=15 \ GOSUB 110 \!set cursor position  PRINT #2, "No VDT Entries";ENDIFcol:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \!set cursor positionGOSUB 117 \!turn cursor on(* Chain to buildSrc *)CHAIN chainMod(* End of Program *)END(* ============= *)(* Subroutines *)(* == Group 1 == *)(* Display and Input *)(* Reset Pause and Page *)100 packet(7):=0 \packet(8):=$18callCode:=$8E \(* Set Window Packet *)regs.a:=2regs.b:=$00regs.x:=ADDR(packet)RUN SysCall(callCode,regs)RETURN(* Set Pause and Page *)105 packet(7):=1 \packet(8):=$12callCode:=$8E \(* Set Window Packet *)regs.a:=2regs.b:=$00regs.x:=ADDR(packet)RUN SysCall(callCode,regs)RETURN110 RUN GFX2("CURXY",col,row) \ RETURN115 RUN GFX2("EREOLINE") \ RETURN116 RUN GFX2("CUROFF") \ RETURN117 RUN GFX2("CURON") \ RETURN118 RUN GFX2("OWSET",1,0,1,80,22,options(3),options(4)) \ RETURN120 RUN GFX2("OWSET",1,0,2,80,21,options(5),options(6)) \ RETURN125 RUN GFX2("OWSET",1,0,4,80,18,options(7),options(8)) \ RETURN130 RUN GFX2("OWEND") \ RETURN(* ============= *)(* Get Keypress *)140 key:=""REPEAT  RUN Inkey(key)  IF key>="A" AND key<="Z" THEN    key:=CHR$(ASC(key)+$20)  ENDIFUNTIL key="y" OR key="n" OR key=CHR$(13)GOSUB 116 \!turn cursor offcol:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \!set cursor position and erase to end-of-lineRETURN(* ============= *)(* Date and Time Stamp *)(* Display completion time *)145 iHour:=hour \iMinute:=minute \iSecond:=secondGOSUB 150 \!get date/time infoeHour:=hour \eMinute:=minute \eSecond:=secondIF eHour<iHour THEN tHour:=eHour+12-iHourELSE tHour:=eHour-iHour \ ENDIFIF eMinute<iMinute THEN tMinute:=eMinute+60-iMinuteELSE tMinute:=eMinute-iMinute \ ENDIFIF eSecond<iSecond THEN tSecond:=eSecond+60-iSecondELSE tSecond:=eSecond-iSecond \ ENDIFIF eSecond<iSecond AND tSecond<60 THEN tMinute:=tMinute-1 \ ENDIFIF eMinute<iMinute AND tMinute<60 THEN tHour:=tHour-1 \ ENDIFIF tHour<10 THEN PRINT #2, "0"; tHour; ":";ELSE PRINT #2, tHour; ":";  \ ENDIFIF tMinute<10 THEN PRINT #2, "0"; tMinute; ":";ELSE PRINT #2, tMinute; ":";  \ ENDIFIF tSecond<10 THEN PRINT #2, "0"; tSecondELSE PRINT #2, tSecond \ ENDIFRETURN(* ============= *)(* Date Stamp *)150 dateTime:=DATE$month:=VAL(MID$(dateTime,4,2))day:=VAL(MID$(dateTime,7,2))year:=2000+VAL(LEFT$(dateTime,2))hour:=VAL(MID$(dateTime,10,2))minute:=VAL(MID$(dateTime,13,2))second:=VAL(MID$(dateTime,16,2))RESTORE 155 \!set to beginning of month name dataREPEAT  READ number,monthNameUNTIL number=monthRETURN(* ============= *)(* Month Names *)155 DATA 1,"January",2,"February",3,"March"DATA 4,"April",5,"May",6,"June"DATA 7,"July",8,"August",9,"September"DATA 10,"October",11,"November",12,"December"(* ============= *)(* == Group 2 == *)(* Display Variable References *)200 IF wOpen THEN  GOSUB 118 \!Open background overlay  IF first THEN    PRINT #2, " Variable References (unsorted)";  ELSE    PRINT #2, " Variable References (sorted)";  ENDIF  GOSUB 120 \!open middle overlay  PRINT #2, "RNum _Instr_ VDT__________VDT_ DSAT___________DSAT Data_Mmry __Field__ Parm Expd";  PRINT #2 USING "i4>,s76",varCount," Tk Pntr Addr Tk Pntr Size Addr Pntr Size Size Addr Size Addr Size Addr Size";  col:=0 \row:=20 \ GOSUB 110 \!set cursor position  PRINT #2, " VES_ TES_ MES_ SRSz Array Size String   Variable/Subroutine Name      StrLen";  GOSUB 125 \!open foreground overlayENDIFRETURN(* ============= *)250 IF wOpen THEN  (* "Ref  _Instr_ "  (* "Num_ Tk Pntr "  PRINT #2 USING "i4>,s1",recNum+1," ";  PRINT #2 USING "h2,s1",varRec(recNum).vTyp," ";  PRINT #2 USING "h4,s1",varRec(recNum).vOff," ";  IF varFRec.vdTkn>0 THEN    (* "________VDT______ "    (* "Addr Tk Pntr Size "    PRINT #2 USING "h4,s1",varRec(recNum).vdOff," ";    PRINT #2 USING "h2,s1",varFRec.vdTkn," ";    PRINT #2 USING "h4,s1",varFRec.vdPtr," ";    PRINT #2 USING "h4,s1",varFRec.vdSiz," ";  ELSE    PRINT #2, "---- -- ---- ---- ";  ENDIF  IF varFRec.dsSiz>0 THEN    (* "DSAT___________DSAT "    (* "Addr Pntr Size Size "    PRINT #2 USING "h4,s1",varRec(recNum).dsOff," ";    PRINT #2 USING "h4,s1",varFRec.dsPtr," ";    PRINT #2 USING "h4,s1",varFRec.dsvSiz," ";    PRINT #2 USING "h4,s1",varFRec.dsSiz," ";  ELSE    PRINT #2, "---- ---- ---- ---- ";  ENDIF  IF varFRec.dmSiz>0 THEN    (* "Data_Mmry "    (* "Addr Size "    PRINT #2 USING "h4,s1",varRec(recNum).dmOff," ";    PRINT #2 USING "h4,s1",varFRec.dmSiz," ";  ELSE    PRINT #2, "---- ---- ";  ENDIF  IF varFRec.fSiz>0 THEN    (* "__Field__ "    (* "Addr Size "    PRINT #2 USING "h4,s1",varRec(recNum).fOff," ";    PRINT #2 USING "h4,s1",varFRec.fSiz," ";  ELSE    PRINT #2, "---- ---- ";  ENDIF  IF varFRec.pSiz>0 THEN    (* "Parm Expd";    (* "Addr Size";    PRINT #2 USING "h4,s1",varRec(recNum).pOff," ";    PRINT #2 USING "h4,s1",varFRec.pSiz," ";  ELSE    PRINT #2, "---- ---- ";  ENDIF  IF varFRec.elem1>0 THEN    (* "VES_ "    PRINT #2 USING "h4,s1",varFRec.elem1," ";  ELSE    PRINT #2, "---- ";  ENDIF  IF varFRec.elem2>0 THEN    (* "TES_ "    PRINT #2 USING "h4,s1",varFRec.elem2," ";  ELSE    PRINT #2, "---- ";  ENDIF  IF varFRec.elem3>0 THEN    (* "MES_ "    PRINT #2 USING "h4,s1",varFRec.elem3," ";  ELSE    PRINT #2, "---- ";  ENDIF  IF varFRec.vSRLen>0 THEN    (* "SRSz "    PRINT #2 USING "h4,s1",varFRec.vSRLen," ";  ELSE    PRINT #2, "---- ";  ENDIF  IF varFRec.vArray<>"" THEN    (* "Array Size String   "    PRINT #2 USING "s19,s1",varFRec.vArray," ";  ELSE    PRINT #2, "------------------- ";  ENDIF  IF varFRec.vName<>"" THEN    (* "Variable/Subroutine Name      "    PRINT #2 USING "s29,s1",varFRec.vName," ";  ELSE    PRINT #2, "----------------------------- ";  ENDIF  IF varFRec.vStrLen<>"" THEN    (* "StrLen ";    PRINT #2 USING "s7",varFRec.vStrLen;  ELSE    PRINT #2, "-------";  ENDIF  PRINTENDIFRETURN(* ============= *)(* Display Counts *)267 col:=14 \row:=15 \ GOSUB 110 \!set cursor positionPRINT USING "i5>", vdtCnt;RETURN(* ============= *)(* Write Records *)269 IF oOpen THEN  PRINT #oPath, "RNum _Instr_ VDT__________VDT_ DSAT___________DSAT Data_Mmry __Field__ Parm Expd"  PRINT #oPath USING "i4>,s76",varCount," Tk Pntr Addr Tk Pntr Size Addr Pntr Size Size Addr Size Addr Size Addr Size ";  PRINT #oPath, " VES_ TES_ MES_ SRSz Array Size String   Variable/Subroutine Name      StrLen"ENDIFRETURN270 IF oOpen THEN  (* Print to Output File *)  (* "Ref  _Instr_ "  (* "Num_ Tk Pntr "  PRINT #oPath USING "i4>,s1",recNum+1," ";  PRINT #oPath USING "h2,s1",varRec(recNum).vTyp," ";  PRINT #oPath USING "h4,s1",varRec(recNum).vOff," ";  IF varFRec.vdTkn>0 THEN    (* "________VDT______ "    (* "Addr Tk Pntr Size "    PRINT #oPath USING "h4,s1",varRec(recNum).vdOff," ";    PRINT #oPath USING "h2,s1",varFRec.vdTkn," ";    PRINT #oPath USING "h4,s1",varFRec.vdPtr," ";    PRINT #oPath USING "h4,s1",varFRec.vdSiz," ";  ELSE    PRINT #oPath, "---- -- ---- ---- ";  ENDIF  IF varFRec.dsSiz>0 THEN    (* "DSAT___________DSAT "    (* "Addr Pntr Size Size "    PRINT #oPath USING "h4,s1",varRec(recNum).dsOff," ";    PRINT #oPath USING "h4,s1",varFRec.dsPtr," ";    PRINT #oPath USING "h4,s1",varFRec.dsvSiz," ";    PRINT #oPath USING "h4,s1",varFRec.dsSiz," ";  ELSE    PRINT #oPath, "---- ---- ---- ---- ";  ENDIF  IF varFRec.dmSiz>0 THEN    (* "Data_Mmry "    (* "Addr Size "    PRINT #oPath USING "h4,s1",varRec(recNum).dmOff," ";    PRINT #oPath USING "h4,s1",varFRec.dmSiz," ";  ELSE    PRINT #oPath, "---- ---- ";  ENDIF  IF varFRec.fSiz>0 THEN    (* "__Field__ "    (* "Addr Size "    PRINT #oPath USING "h4,s1",varRec(recNum).fOff," ";    PRINT #oPath USING "h4,s1",varFRec.fSiz," ";  ELSE    PRINT #oPath, "---- ---- ";  ENDIF  IF varFRec.pSiz>0 THEN    (* "Parm Expd";    (* "Addr Size";    PRINT #oPath USING "h4,s1",varRec(recNum).pOff," ";    PRINT #oPath USING "h4,s1",varFRec.pSiz," ";  ELSE    PRINT #oPath, "---- ---- ";  ENDIF  IF varFRec.elem1>0 THEN    (* "VES_ "    PRINT #oPath USING "h4,s1",varFRec.elem1," ";  ELSE    PRINT #oPath, "---- ";  ENDIF  IF varFRec.elem2>0 THEN    (* "TES_ "    PRINT #oPath USING "h4,s1",varFRec.elem2," ";  ELSE    PRINT #oPath, "---- ";  ENDIF  IF varFRec.elem3>0 THEN    (* "MES_ "    PRINT #oPath USING "h4,s1",varFRec.elem3," ";  ELSE    PRINT #oPath, "---- ";  ENDIF  IF varFRec.vSRLen>0 THEN    (* "SRSz "    PRINT #oPath USING "h4,s1",varFRec.vSRLen," ";  ELSE    PRINT #oPath, "---- ";  ENDIF  IF varFRec.vArray<>"" THEN    (* "Array Size String   "    PRINT #oPath USING "s19,s1",varFRec.vArray," ";  ELSE    PRINT #oPath, "------------------- ";  ENDIF  IF varFRec.vName<>"" THEN    (* "Variable/Subroutine Name      "    PRINT #oPath USING "s29,s1",varFRec.vName," ";  ELSE    PRINT #oPath, "----------------------------- ";  ENDIF  IF varFRec.vStrLen<>"" THEN    (* "StrLen ";    PRINT #oPath USING "s7",varFRec.vStrLen;  ELSE    PRINT #oPath, "-------";  ENDIF  PRINT #oPathENDIFRETURN(* ============= *)(* == Group 3 == *)(* ============= *)(* == Group 4 == *)(* Assign Beginning Variable Label Name *)410 REPEAT  READ tokenByte,tokenStringUNTIL tokenByte=tokenCode OR tokenByte=$A0RETURN(* ============= *)(* Data for Label Names *)420 DATA $40,"b",$41,"i",$42,"r",$43,"l",$44,"s",$45,"c"DATA $60,"B",$61,"I",$62,"R",$63,"L",$64,"S",$65,"C"DATA $80,"PB",$81,"PI",$82,"PR",$83,"PL",$84,"PS",$85,"PC"DATA $48,"ba()",$49,"ia()",$4A,"ra()",$4B,"la()",$4C,"sa()",$4D,"ca()"DATA $68,"BA()",$69,"IA()",$6A,"RA()",$6B,"LA()",$6C,"SA()",$6D,"CA()"DATA $88,"PBA()",$89,"PIA()",$8A,"PRA()",$8B,"PLA()",$8C,"PSA()",$8D,"PCA()"DATA $50,"ba(,)",$51,"ia(,)",$52,"ra(,)",$53,"la(,)",$54,"sa(,)",$55,"ca(,)"DATA $70,"BA(,)",$71,"IA(,)",$72,"RA(,)",$73,"LA(,)",$74,"SA(,)",$75,"CA(,)"DATA $90,"PBA(,)",$91,"PIA(,)",$92,"PRA(,)",$93,"PLA(,)",$94,"PSA(,)",$95,"PCA(,)"DATA $58,"ba(,,)",$59,"ia(,,)",$5A,"ra(,,)",$5B,"la(,,)",$5C,"sa(,,)",$5D,"ca(,,)"DATA $78,"BA(,,)",$79,"IA(,,)",$7A,"RA(,,)",$7B,"LA(,,)",$7C,"SA(,,)",$7D,"CA(,,)"DATA $98,"PBA(,,)",$99,"PIA(,,)",$9A,"PRA(,,)",$9B,"PLA(,,)",$9C,"PSA(,,)",$9D,"PCA(,,)"DATA $A0,""(* ============= *)(* Data for Simple Label Names *)430 DATA $00,"I",$01,"I",$02,"R",$03,"R",$46,"TO",$47,"STEP"DATA $80,"B",$81,"I",$82,"R",$83,"L",$84,"S"DATA $85,"",$86,"",$87,"",$88,"",$89,"",$8A,"",$8B,"",$8C,""DATA $F2,"",$F3,"",$F4,"",$F5,"",$F6,"",$F7,"",$F8,"",$F9,""450 FOR delay=1 TO 12000 \NEXT delayRETURN(* ============= *)(* == Group 5 == *)(* Error Trap *)500 IF er=0 THEN  er:=ERRENDIFIF wOpen THEN  GOSUB 130 \GOSUB 130 \GOSUB 130 \!close overlaysENDIFIF pOpen THEN  CLOSE #path  pOpen:=FALSEENDIFIF vOpen THEN  CLOSE #vPath  vOpen:=FALSEENDIFIF dOpen THEN  CLOSE #dPath  dOpen:=FALSEENDIFGOSUB 117 \!turn cursor oncol:=0 \row:=23 \ GOSUB 110 \ GOSUB 115 \!set cursor position and erase to end-of-lineON ERROR GOTO 510(* For brief error messages, change ,1 to ,0 *)SHELL "RunB ErrorCodes (" + STR$(er) + ",1)"END(* ============= *)(* If ErrorCodes is not found *)510 er1:=ERRIF er1=43 THEN  PRINT #2, "Error: "; erENDIFEND(* ============= *)PROCEDURE vSort(* based on quicksort, by T.F. Ritter(* Variable Record *)(* Array *)TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGERDIM varRec:VREC(* File Record *)TYPE VFRC=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGER; vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGER; mTyp,vLnk:BYTE; pRec,pFld:BOOLEANDIM varFRec,varFRecs(2):VFRCPARAM er,which:INTEGER; vPath:BYTE; bottom,top:INTEGER; varRecs(400):VRECDIM lower,upper:INTEGER; btemp:BOOLEANON ERROR GOTO 10which:=which+1RUN GFX2("CURXY",55,14) \PRINT #2, which;BASE 0lower:=bottomupper:=topLOOP \!each element gets the once over  REPEAT \!this is a postinc instruction    btemp:=varRecs(lower).dmOff<varRecs(top).dmOff    lower:=lower+1  UNTIL NOT(btemp)  lower:=lower-1 \!point at the tested element  EXITIF lower=upper THEN  ENDEXIT  REPEAT \!this is a postdec instruction    upper:=upper-1  UNTIL varRecs(upper).dmOff<=varRecs(top).dmOff OR upper=lower  EXITIF lower=upper THEN  ENDEXIT  SEEK #vPath,lower*SIZE(varFRec)+2  GET #vPath,varFRec  varFRecs(0):=varFRec  SEEK #vPath,upper*SIZE(varFRec)+2  GET #vPath,varFRec  varFRecs(1):=varFRec  varRec:=varRecs(lower)  varRecs(lower):=varRecs(upper)  varRecs(upper):=varRec  varFRec:=varFRecs(0)  varFRecs(0):=varFRecs(1)  varFRecs(1):=varFRec  SEEK #vPath,lower*SIZE(varFRec)+2  varFRec:=varFRecs(0)  PUT #vPath,varFRec  SEEK #vPath,upper*SIZE(varFRec)+2  varFRec:=varFRecs(1)  PUT #vPath,varFRec  lower:=lower+1 \!prepare for postinc  EXITIF lower=upper THEN  ENDEXITENDLOOPIF lower<>top THEN  IF varRecs(lower).dmOff<>varRecs(top).dmOff THEN    SEEK #vPath,lower*SIZE(varFRec)+2    GET #vPath,varFRec    varFRecs(0):=varFRec    SEEK #vPath,top*SIZE(varFRec)+2    GET #vPath,varFRec    varFRecs(1):=varFRec    varRec:=varRecs(lower)    varRecs(lower):=varRecs(top)    varRecs(top):=varRec    varFRec:=varFRecs(0)    varFRecs(0):=varFRecs(1)    varFRecs(1):=varFRec    SEEK #vPath,lower*SIZE(varFRec)+2    varFRec:=varFRecs(0)    PUT #vPath,varFRec    SEEK #vPath,top*SIZE(varFRec)+2    varFRec:=varFRecs(1)    PUT #vPath,varFRec  ENDIFENDIFIF bottom<lower-1 THEN  RUN vSort(er,which,vPath,bottom,lower-1,varRecs)ENDIFIF lower+1<top THEN  RUN vSort(er,which,vPath,lower+1,top,varRecs)ENDIFEND10 er:=ERREND(* ============= *)PROCEDURE fSort(* Field Sort *)(* Variable Record *)(* Array *)TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGERDIM varRec:VREC(* File Record *)TYPE VFRC=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGER; vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGER; mTyp,vLnk:BYTE; pRec,pFld:BOOLEANDIM varFRec,varFRecs(2):VFRCDIM sortedInt:INTEGERPARAM vPath:BYTE; recCount,varCount:INTEGER; varRecs(400):VRECBASE 0(* new variable, this tells us where in the array to jump to when a sorted pair is found *)sortedInt:=0REPEAT  SEEK #vPath,recCount*SIZE(varFRec)+2  GET #vPath,varFRec  IF varFRec.vdTkn>$3F AND varFRec.vdTkn<$60 THEN    (* compare current element to next element *)    IF varRecs(recCount).vOff>varRecs(recCount+1).vOff THEN      (* current element is larger than following, swap them *)      varRec:=varRecs(recCount)      varRecs(recCount):=varRecs(recCount+1)      varRecs(recCount+1):=varRec      SEEK #vPath,recCount*SIZE(varFRec)+2      GET #vPath,varFRecs      varFRec:=varFRecs(0)      varFRecs(0):=varFRecs(1)      varFRecs(1):=varFRec      SEEK #vPath,recCount*SIZE(varFRec)+2      PUT #vPath,varFRecs      (* decrement position if > 0 (this is the "bubble" effect) *)      recCount:=ABS(recCount-1)    ELSE      (* these elements are sorted or equal, move to next comparison *)      recCount:=sortedInt      (* increment our jump pointer to next pair of records *)      sortedInt:=sortedInt+1      (* recCount:=recCount+1 *)    ENDIF  ENDIF(* if our position is the last element, our array is sorted *)UNTIL recCount=varCount-1END