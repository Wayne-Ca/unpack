PROCEDURE ubuildSrc (* Version 01.00.00 *) (* Variable Array Record *) TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGER DIM varRec(400):VREC (* Variable File Record *) TYPE VFP1=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGER TYPE VFP2=vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGER TYPE VFP3=mTyp,vLnk,fNum:BYTE; pRec,pFld:BOOLEAN TYPE VFRC= vp1:VFP1; vp2:VFP2; vp3:VFP3 DIM varFRec,varFRec2:VFRC (* DSAT Map *) TYPE DSMP=dsOf:REAL; dsDm,dsMSz,dsSz:INTEGER DIM DSMap(100):DSMP (* Records Map *) TYPE RECS=recID:INTEGER; recName:STRING[7] DIM rec(20):RECS (* File paths *) DIM vPath,dPath:BYTE (* File,Overlay open status *) DIM vOpen,dOpen:BOOLEAN (* Booleans *) DIM found,validated,endOfType,hasRecords:BOOLEAN (* File names *) DIM version:STRING[8]; vFile,lnFile,ltFile,dFile:STRING[29] (* Temporary nTyp *) DIM tnTyp:BYTE (* Variable Reference Counters *) DIM varRefs,varCount,recCnt:INTEGER (* Error and Module Data *) DIM modSiz,lastOff,dataStOff:INTEGER (* Various counters *) DIM byteVal,posVal,varCntr:BYTE DIM recNum,intVal,which:INTEGER DIM VDCount:INTEGER DIM dsatCnt,ucCnt:INTEGER DIM gapSize(20),gapCnt,dsMCnt,typCnt,cntr,cntr2,tRec,tSiz,tVar:INTEGER DIM mSize,dsPointer,nextOff,gapOff(20):REAL (* Strings *) DIM tStrLen,typName:STRING[7] DIM tName:STRING[29] DIM source:STRING[512] (* Parameters PARAMs also passed to instruction *) PARAM path,oPath:BYTE; er,dataSiz:INTEGER; pOpen,verbose:BOOLEAN; descOff,symTabOff:REAL; dataDir:STRING[16]; oFile:STRING[29]  (* Initializations *) BASE 0 er:=0 \which:=0 \vOpen:=FALSE \dOpen:=FALSE ON ERROR GOTO 500 \REM goto error trap dOpen:=FALSE dFile:=dataDir+"initDB" OPEN #dPath,dFile:READ dOpen:=TRUE GET #dPath,version SEEK #dPath,SIZE(version)+SIZE(varFRec) \REM skip to DSMap GET #dPath,DSMap \REM initialized DSAT Map array CLOSE #dPath dOpen:=FALSE vFile:=dataDir+"varDefs" lnFile:=dataDir+"linDefs" dFile:=dataDir+"procData" (* Get data *) OPEN #dPath,dFile:READ dOpen:=TRUE GET #dPath,hasRecords (* Variables lookup table *) GET #dPath,varRec CLOSE #dPath dOpen:=FALSE (* Chain Module String *) ! chainMod:="ex RunB #32K instruction ("""+file+""","""+modName+""","""+dataDir+""")" (* Open Variable Reference File *) OPEN #vPath,vFile:UPDATE vOpen:=TRUE GET #vPath,varCount IF symTabOff-descOff>3 THEN    SEEK #path,descOff   dsMCnt:=0   SEEK #vPath,2   PRINT #2,"Counting Description Area References ";    IF verbose THEN      PRINT #2     PRINT #2,"  Description Area     Count"     PRINT #2,"Ofst Pntr Size DSSiz"   ENDIF    FOR VDCount:=0 TO varCount-1     found:=TRUE     GET #vPath,varFRec     IF varFRec.vp1.dsSiz>0 THEN        DSMap(dsMCnt).dsOf:=FLOAT(varRec(VDCount).dsOff)       DSMap(dsMCnt).dsDm:=varFRec.vp1.dsPtr       DSMap(dsMCnt).dsMSz:=varFRec.vp1.dsvSiz       DSMap(dsMCnt).dsSz:=varFRec.vp1.dsSiz       IF dsMCnt>0 THEN          IF DSMap(dsMCnt).dsOf=DSMap(dsMCnt-1).dsOf THEN            dsMCnt:=dsMCnt-1           found:=FALSE         ENDIF        ENDIF        IF found THEN          IF verbose THEN            PRINT #2 USING "h4,x1,h4,x1,h4,x1,i5>",DSMap(dsMCnt).dsOf,DSMap(dsMCnt).dsDm,DSMap(dsMCnt).dsMSz,DSMap(dsMCnt).dsSz;            PRINT #2," "; dsMCnt+1         ENDIF        ENDIF        dsMCnt:=dsMCnt+1     ENDIF    NEXT VDCount   IF NOT(verbose) THEN      PRINT #2," ";   ENDIF   PRINT "Done"   PRINT #2,"Sorting Description Area References ";    RUN dsSort(er,which,0,dsMCnt-1,DSMap)   IF er>0 THEN 500 \REM goto error trap   PRINT #2," Done"   (* Validate DSAT *)   PRINT #2,"Validating Description Area";    IF verbose THEN      PRINT #2     PRINT #2,"  DSAT"     PRINT #2,"Off  Siz"   ELSE     PRINT " ";   ENDIF    mSize:=symTabOff-3-descOff \gapCnt:=0   dsatCnt:=0 \dsPointer:=0 \VDCount:=0 \validated:=TRUE   SEEK #path,descOff   REPEAT      IF VDCount<dsMCnt THEN        IF DSMap(VDCount).dsOf>dsPointer THEN          validated:=FALSE         gapOff(gapCnt):=dsPointer \gapSize(gapCnt):=0         FOR nextOff=1 TO DSMap(VDCount).dsOf-dsPointer           GET #path,byteVal           dsPointer:=dsPointer+1           gapSize(gapCnt):=gapSize(gapCnt)+1           IF verbose THEN              PRINT #2 USING "h2",byteVal;            ENDIF          NEXT nextOff         gapCnt:=gapCnt+1         IF verbose THEN            PRINT #2," Unidentified"           PRINT #2         ELSE           PRINT #2,".";         ENDIF          FOR nextOff:=1 TO DSMap(VDCount).dsSz/2           GET #path,intVal           dsPointer:=dsPointer+2           IF verbose THEN              PRINT #2 USING "h4,s1",intVal," ";            ENDIF          NEXT nextOff         IF verbose THEN            PRINT #2,"Validated"           PRINT #2         ELSE           PRINT #2,".";         ENDIF        ELSE          FOR nextOff:=1 TO DSMap(VDCount).dsSz/2           GET #path,intVal           dsPointer:=dsPointer+2           IF verbose THEN              PRINT #2 USING "h4,s1",intVal," ";            ENDIF          NEXT nextOff         IF verbose THEN            PRINT #2,"Validated"           PRINT #2         ELSE           PRINT #2,".";         ENDIF        ENDIF      ENDIF      VDCount:=VDCount+1     dsatCnt:=dsatCnt+1   UNTIL dsPointer>=mSize   IF verbose THEN      GOSUB 268 \REM display counts   ENDIF    PRINT #2   PRINT #2,"There is/are "; gapCnt; " Unidentified Gap(s) in the DSAT"   IF verbose THEN      FOR nextOff:=0 TO gapCnt-1       PRINT #2 USING "s8>,h4,s8>,i4>","Offset: ",gapOff(nextOff),"Size: ",gapSize(nextOff)     NEXT nextOff     PRINT #2     GOSUB 268 \REM display counts   ENDIF    IF verbose AND NOT(validated) THEN      PRINT #2,"Not Validated"   ELSE      IF verbose AND validated THEN        PRINT #2,"Validated "     ENDIF    ENDIF    PRINT #2,"Done"    typCnt:=0 \tName:="" \typName:=""   recNum:=0 \recCnt:=0 \source:=""    (* Set record ID numbers *)   PRINT #2,"Fixing Type Records ";    tRec:=0   FOR recNum=0 TO varCount-1     SEEK #vPath,recNum*SIZE(varFRec)+2     GET #vPath,varFRec     IF varFRec.vp2.pVar>0 AND varFRec.vp2.pVar<>tRec THEN        tRec:=varFRec.vp2.pVar       cntr:=0       REPEAT          SEEK #vPath,cntr*SIZE(varFRec2)+2         GET #vPath,varFRec2         cntr:=cntr+1       UNTIL varFRec2.vp2.vRecNum=varFRec.vp2.pVar       IF cntr>1 THEN          cntr:=cntr-1         FOR cntr2:=0 TO 2           IF cntr-1>0 THEN              cntr:=cntr-1             SEEK #vPath,cntr*SIZE(varFRec)+2             GET #vPath,varFRec             IF varFRec.vp2.vName=varFRec2.vp2.vName THEN                varFRec.vp2.vRecNum:=varFRec2.vp2.vRecNum               SEEK #vPath,cntr*SIZE(varFRec)+2               PUT #vPath,varFRec               PRINT #2,",";              ENDIF            ENDIF          NEXT cntr2       ENDIF        IF cntr<varCount-1 THEN          cntr:=cntr+2         FOR cntr2:=0 TO 2           IF cntr+1<varCount THEN              cntr:=cntr+1             SEEK #vPath,cntr*SIZE(varFRec)+2             GET #vPath,varFRec             IF varFRec.vp2.vName=varFRec2.vp2.vName THEN                varFRec.vp2.vRecNum:=varFRec2.vp2.vRecNum               SEEK #vPath,cntr*SIZE(varFRec)+2               PUT #vPath,varFRec               PRINT #2,".";              ENDIF            ENDIF          NEXT cntr2       ENDIF      ENDIF    NEXT recNum   PRINT #2,"Done" ELSE   PRINT #2,"No Description Area References" ENDIF   (* Validate Data Memory Allocation *) PRINT #2,"Validating Data Meemory ";  SEEK #vPath,2 cntr:=0 validated:=TRUE REPEAT    GET #vPath,varFRec   IF (varRec(cntr).vTyp>=$80 AND varRec(cntr).vTyp<=$88 OR varRec(cntr).vTyp>=$F2 AND varRec(cntr).vTyp<=$F5) AND varRec(cntr).dmOff<>varRec(cntr+1).dmOff THEN      IF varRec(cntr+1).dmOff>varRec(cntr).dmOff+varFRec.vp1.dmSiz THEN        validated:=FALSE     ENDIF    ENDIF    cntr:=cntr+1   GOSUB 269 UNTIL varRec(cntr-1).dmOff+varFRec.vp1.dmSiz=dataSiz OR varRec(cntr).dmOff=dataSiz IF verbose THEN   PRINT #2 ELSE   PRINT #2," "; ENDIF IF validated THEN    PRINT #2,"Validated" ELSE    PRINT #2,"Not Validated" ENDIF   FOR cntr:=0 TO 19   rec(cntr).recID:=0 \REM record ID # associated to fields   rec(cntr).recName:="" \REM typName for this record variable NEXT cntr  typCnt:=0 \REM # of type statements tName:="" \REM last variable name typName:="" \REM ex: TYPE TYP1= TYP1 is typName tStrLen:="" \REM last variable string length recNum:=0 \REM current variable file record # recCnt:=0 \REM count of record variables ucCnt:=0 tVar:=0 source:="" \REM source statement  (* nTyp = 0: TYPE fields all types (* nTyp = 1: DIM types BYTE, INTEGER, REAL, BOOLEAN, STRING, record or array (* nTyp = 2: PARAMs all types (* nTyp = 3: variable type F/N 00, 01, 02, and 03, 46 (TO) and 47 (STEP), A0 (subroutine)  (* Output to Screen *) PRINT #2,"Writing source code to "; oFile; "..." PRINT #2," Dimension Statement Source Output" PRINT #2 (* Create Dimension Statements *) varCntr:=1 REPEAT    SEEK #vPath,recNum*SIZE(varFRec)+2   GET #vPath,varFRec \REM get next record    (* Field Variables *)   IF varRec(recNum).nTyp=0 THEN  \REM TYPE statements     IF varFRec.vp3.pFld THEN  \REM if a field variable       IF SUBSTR("s",varFRec.vp2.vName)>0 AND tStrLen="" THEN  \REM if string variable         tStrLen:=varFRec.vp2.vStrLen \REM set temp variable to string length modifier       ENDIF  10    IF source="" THEN  \REM if a new statement         typCnt:=typCnt+1 \REM increment type count         typName:="TYP"+STR$(typCnt) \REM assign type name         REM not sure if this part is necessary         REM ==================================         cntr:=0 \found:=FALSE         REPEAT  \REM is this type already defined?           IF rec(cntr).recName=typName THEN              found:=TRUE           ENDIF            cntr:=cntr+1         UNTIL found OR cntr>=recCnt         IF NOT(found) THEN  \REM no, add to rec           rec(recCnt).recID:=varFRec.vp2.pVar \REM pVar = rec# of record variable           rec(recCnt).recName:=typName           recCnt:=recCnt+1           source:="TYPE "+typName+"=" \REM set beginning of statement         ENDIF        REM ==================================       ENDIF        GOSUB 200 \REM check for array       IF varFRec.vp2.vName<>tName THEN  \REM current var name not previous var name         endOfType:=FALSE         (* Is same type? *)         IF tName<>"" THEN            IF SUBSTR("s",tName)>0 AND tStrLen<>varFRec.vp2.vStrLen THEN              endOfType:=TRUE           ELSE              IF tRec<>varFRec.vp2.vRecNum AND SUBSTR("c",tName)>0 THEN                endOfType:=TRUE             ELSE                IF LEFT$(varFRec.vp2.vName,1)=LEFT$(tName,1) AND varFRec.vp2.pVar=tVar THEN \REM ex: b009, b010, both BYTE                 source:=source+"," \REM so separate with a comma               ELSE  \REM ex: b010, i011, not same type                 endOfType:=TRUE \REM so set end of type               ENDIF              ENDIF            ENDIF          ENDIF          (* End of same type? *)         IF endOfType THEN            GOSUB 210 \REM end of type           (* End of statement? *)           (* rec(recCnt-1).recID = current type, so if pVar reflects *)           (* a diff number, end of statement, if pVar=0, not a field *)           (* variable, so end of statement *)           IF varFRec.vp2.pVar<>rec(recCnt-1).recID OR varFRec.vp2.pVar=0 THEN              PRINT #oPath,source             IF verbose THEN                PRINT #2, source             ENDIF              source:="" \REM clear source for next statement             tName:=varFRec.vp2.vName \REM set last var name             tVar:=varFRec.vp2.pVar             tStrLen:=varFRec.vp2.vStrLen             tnTyp:=varRec(recNum).nTyp             IF SUBSTR("c",tName)>0 THEN                tRec:=varFRec.vp2.vRecNum               tSiz:=varFRec.vp1.dsvSiz             ENDIF              GOTO 10 \REM go build next TYPE statement           ELSE              source:=source+"; " \REM prepare to add next var type to statement           ENDIF          ENDIF          (* add current name to statement if not end of statement *)         source:=source+varFRec.vp2.vName \REM add var name to source statement         tName:=varFRec.vp2.vName \REM set last var name         tVar:=varFRec.vp2.pVar         IF SUBSTR("c",tName)>0 THEN            tRec:=varFRec.vp2.vRecNum           tSiz:=varFRec.vp1.dsvSiz         ENDIF        ELSE          (* add current name to statement if beginning of statement *)         IF RIGHT$(source,1)="=" THEN            source:=source+varFRec.vp2.vName         ENDIF        ENDIF      ENDIF    ENDIF     IF varRec(recNum).nTyp=1 THEN  \REM DIM statements     (* Start DIM Statements *)     IF NOT(hasRecords) AND SUBSTR("S",varFRec.vp2.vName)>0 THEN        tStrLen:=varFRec.vp2.vStrLen     ENDIF      (* nTyp separates user named variables from subroutine names and internal *)     (* variables associated to TO and STEP values in FOR/NEXT loops *) 15  IF source="" THEN        source:="DIM "+varFRec.vp2.vName     ENDIF      GOSUB 200 \REM check for array     IF varFRec.vp2.vName<>tName THEN        IF RIGHT$(source,1)<>" " THEN          endOfType:=FALSE         (* Is same type? *)         IF tName<>"" THEN            (* Parameter variables are named Pvnnnn, ex: PR0065 is a REAL type parameter *)           (* Program variables are named Vnnnn, ex: L0044 is a BOOLEAM type variable *)           IF SUBSTR("S",tName)>0 AND tStrLen<>varFRec.vp2.vStrLen THEN              endOfType:=TRUE           ELSE              IF tRec<>varFRec.vp2.vRecNum AND SUBSTR("C",tName)>0 THEN                endOfType:=TRUE             ELSE                IF LEFT$(tName,1)<>"P" AND LEFT$(varFRec.vp2.vName,1)<>"P" THEN                  IF LEFT$(varFRec.vp2.vName,1)=LEFT$(tName,1) THEN                    IF varCntr=10 THEN                      varCntr:=1                     endOfType:=TRUE                   ELSE                      varCntr:=varCntr+1                     source:=source+","                   ENDIF                  ELSE                    endOfType:=TRUE                   varCntr:=1                 ENDIF                ENDIF                IF LEFT$(tName,1)="P" AND LEFT$(varFRec.vp2.vName,1)="P" THEN                  IF MID$(varFRec.vp2.vName,2,1)=MID$(tName,2,1) THEN                    IF varCntr=10 THEN                      varCntr:=1                     endOfType:=TRUE                   ELSE                      varCntr:=varCntr+1                     source:=source+","                   ENDIF                  ELSE                    endOfType:=TRUE                   varCntr:=1                 ENDIF                ENDIF                IF LEFT$(tName,1)<>"P" AND LEFT$(varFRec.vp2.vName,1)="P" THEN                  endOfType:=TRUE                 tName:=varFRec.vp2.vName               ENDIF              ENDIF            ENDIF          ENDIF          (* End of same type? *)         IF endOfType THEN            GOSUB 210 \REM end of type           (* End of statement? *)           IF varFRec.vp2.pVar=0 THEN              PRINT #oPath,source             IF verbose THEN                PRINT #2, source             ENDIF              source:=""             tName:=varFRec.vp2.vName             tStrLen:=varFRec.vp2.vStrLen             tnTyp:=varRec(recNum).nTyp             IF SUBSTR("C",tName)>0 THEN                tRec:=varFRec.vp2.vRecNum               tSiz:=varFRec.vp1.dsvSiz             ENDIF              GOTO 15           ELSE              source:=source+"; "           ENDIF          ENDIF          IF RIGHT$(source,1)=" " OR RIGHT$(source,1)="," THEN            source:=source+varFRec.vp2.vName         ENDIF          tName:=varFRec.vp2.vName         tStrLen:=varFRec.vp2.vStrLen         IF SUBSTR("C",tName)>0 THEN            tRec:=varFRec.vp2.vRecNum           tSiz:=varFRec.vp1.dsvSiz         ENDIF        ENDIF      ENDIF      (* Process last variable *)     (* This section may be unnecessary *)     IF recNum=varCount-1 OR recNum<varCount-1 AND SUBSTR("0",varFRec.vp2.vName)=0 THEN        IF SUBSTR("S",tName)>0 THEN          tStrLen:=varFRec.vp2.vStrLen       ENDIF        GOSUB 210 \REM end of type       PRINT #oPath,source       IF verbose THEN          PRINT #2, source       ENDIF      ENDIF    ENDIF     IF varRec(recNum).nTyp=2 THEN  \REM PARAM statements   (* Start PARAM Statements *)   IF NOT(hasRecords) AND SUBSTR("S",varFRec.vp2.vName)>0 THEN      tStrLen:=varFRec.vp2.vStrLen   ENDIF    (* nTyp separates user named variables from subroutine names and internal *)   (* variables associated to TO and STEP values in FOR/NEXT loops *) 20 IF source="" THEN      source:="PARAM "+varFRec.vp2.vName   ENDIF    GOSUB 200 \REM check for array   IF varFRec.vp2.vName<>tName THEN      IF RIGHT$(source,1)<>" " THEN        endOfType:=FALSE       (* Is same type? *)       IF tName<>"" THEN          (* Parameter variables are named Pvnnnn, ex: PR0065 is a REAL type parameter *)         (* Program variables are named Vnnnn, ex: L0044 is a BOOLEAM type variable *)         IF SUBSTR("S",tName)>0 AND tStrLen<>varFRec.vp2.vStrLen THEN            endOfType:=TRUE         ELSE            IF tRec<>varFRec.vp2.vRecNum AND SUBSTR("C",tName)>0 THEN              endOfType:=TRUE           ELSE              IF LEFT$(tName,1)<>"P" AND LEFT$(varFRec.vp2.vName,1)<>"P" THEN                IF LEFT$(varFRec.vp2.vName,1)=LEFT$(tName,1) THEN                  IF varCntr=10 THEN                    varCntr:=1                   endOfType:=TRUE                 ELSE                    varCntr:=varCntr+1                   source:=source+","                 ENDIF                ELSE                  endOfType:=TRUE                 varCntr:=1               ENDIF              ENDIF              IF LEFT$(tName,1)="P" AND LEFT$(varFRec.vp2.vName,1)="P" THEN                IF MID$(varFRec.vp2.vName,2,1)=MID$(tName,2,1) THEN                  IF varCntr=10 THEN                    varCntr:=1                   endOfType:=TRUE                 ELSE                    varCntr:=varCntr+1                   source:=source+","                 ENDIF                ELSE                  endOfType:=TRUE                 varCntr:=1               ENDIF              ENDIF              IF LEFT$(tName,1)<>"P" AND LEFT$(varFRec.vp2.vName,1)="P" THEN                endOfType:=TRUE               tName:=varFRec.vp2.vName             ENDIF            ENDIF          ENDIF        ENDIF        (* End of same type? *)       IF endOfType THEN          GOSUB 210 \REM end of type         (* End of statement? *)           IF varFRec.vp2.pVar=0 THEN              PRINT #oPath,source             IF verbose THEN                PRINT #2, source             ENDIF              source:=""             tName:=varFRec.vp2.vName             tStrLen:=varFRec.vp2.vStrLen             tnTyp:=varRec(recNum).nTyp             IF SUBSTR("C",tName)>0 THEN                tRec:=varFRec.vp2.vRecNum               tSiz:=varFRec.vp1.dsvSiz             ENDIF              GOTO 20           ELSE              source:=source+"; "           ENDIF          ENDIF          IF RIGHT$(source,1)=" " OR RIGHT$(source,1)="," THEN            source:=source+varFRec.vp2.vName         ENDIF          tName:=varFRec.vp2.vName         tStrLen:=varFRec.vp2.vStrLen         IF SUBSTR("C",tName)>0 THEN            tRec:=varFRec.vp2.vRecNum           tSiz:=varFRec.vp1.dsvSiz         ENDIF        ENDIF      ENDIF      (* Process last variable *)     (* This section may be unnecessary *)     IF recNum=varCount-1 OR recNum<varCount-1 AND SUBSTR("0",varFRec.vp2.vName)=0 THEN        IF SUBSTR("S",tName)>0 THEN          tStrLen:=varFRec.vp2.vStrLen       ENDIF        GOSUB 210 \REM end of type       PRINT #oPath,source       IF verbose THEN          PRINT #2, source       ENDIF      ENDIF      REM ================================     (* end of user variables *)     IF tnTyp<3 THEN        GOSUB 210 \REM end of type       IF verbose THEN          PRINT #2, source       ENDIF        PRINT #oPath,source       tnTyp:=varRec(recNum).nTyp       source:=""     ENDIF    REM ================================   ENDIF    recNum:=recNum+1 UNTIL recNum=varCount  (* Close Files *) CLOSE #vPath vOpen:=FALSE (* Chain to Instruction *) ! CHAIN chainMod (* End of Program *) END  (* ============= *) (* Subroutines *)(* These make the array variable names reflect the array elements *)(* Ex: ba039() becomes ba039(3) *)200 IF RIGHT$(varFRec.vp2.vName,4)="(,,)" THEN varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,LEN(varFRec.vp2.vName)-4)+varFRec.vp2.vArrayELSE IF RIGHT$(varFRec.vp2.vName,3)="(,)" THEN varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,LEN(varFRec.vp2.vName)-3)+varFRec.vp2.vArrayELSE IF RIGHT$(varFRec.vp2.vName,2)="()" THEN varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,LEN(varFRec.vp2.vName)-2)+varFRec.vp2.vArrayENDIF ENDIF ENDIF RETURN (* ============= *)210 IF LEFT$(tName,1)="P" THEN posVal:=2ELSE posVal:=1ENDIF IF SUBSTR(MID$(tName,posVal,1),"Bb")>0 THEN source:=source+":BYTE"ELSE IF SUBSTR(MID$(tName,posVal,1),"Ii")>0 THEN source:=source+":INTEGER"ELSE IF SUBSTR(MID$(tName,posVal,1),"Rr")>0 THEN source:=source+":REAL"ELSE IF SUBSTR(MID$(tName,posVal,1),"Ll")>0 THEN source:=source+":BOOLEAN"ELSE IF SUBSTR(MID$(tName,posVal,1),"Ss")>0 THEN source:=source+":STRING"IF tStrLen<>"[32]" THEN source:=source+tStrLenENDIF tStrLen:=varFRec.vp2.vStrLenELSE IF SUBSTR(MID$(tName,posVal,1),"Cc")>0 THEN found:=FALSEFOR cntr:=0 TO recCnt-1IF tRec=rec(cntr).recID THEN source:=source+":"+rec(cntr).recNamefound:=TRUEENDIF NEXT cntrIF NOT(found) THEN typCnt:=typCnt+1ucCnt:=ucCnt+1typName:="TYP"+STR$(typCnt)IF verbose THEN PRINT "TYPE "; typName; "=uC"; ucCnt; "("; tSiz; "):BYTE"ENDIF PRINT #oPath,"TYPE "; typName; "=uC"; ucCnt; "("; tSiz; "):BYTE"source:=source+":"+typNameENDIF (* Have to figure this part out *)ENDIF ENDIF ENDIF ENDIF ENDIF ENDIF RETURN (* ============= *)(* Display Counts *)268 PRINT #2 USING "i5>",dsatCntRETURN 269 IF verbose THEN  PRINT #2 USING "i5>",cntr; " ";ELSE  PRINT #2,".";ENDIFRETURN (* ============= *)(* Error Trap *)500 IF er=0 THEN er:=ERRENDIF IF vOpen THEN CLOSE #vPathvOpen:=FALSEENDIF IF dOpen THEN CLOSE #dPathdOpen:=FALSEENDIF END (* ============= *)PROCEDURE dsSort(* based on quicksort, by T.F. Ritter(* DSAT Map *)TYPE DSMP=dsOf:REAL; dsDm,dsMSz,dsSz:INTEGERDIM DSMap:DSMPPARAM er,which:INTEGER; bottom,top:INTEGER; DSMaps(100):DSMPDIM lower,upper:INTEGER; btemp:BOOLEANON ERROR GOTO 10which:=which+1PRINT #2,"."; BASE 0lower:=bottomupper:=topLOOP  \REM each element gets the once overREPEAT  \REM this is a postinc instructionbtemp:=DSMaps(lower).dsOf<DSMaps(top).dsOflower:=lower+1UNTIL NOT(btemp)lower:=lower-1 \REM point at the tested elementEXITIF lower=upper THEN ENDEXIT REPEAT  \REM this is a postdec instructionupper:=upper-1UNTIL DSMaps(upper).dsOf<=DSMaps(top).dsOf OR upper=lowerEXITIF lower=upper THEN ENDEXIT DSMap:=DSMaps(lower)DSMaps(lower):=DSMaps(upper)DSMaps(upper):=DSMaplower:=lower+1 \REM prepare for postincEXITIF lower=upper THEN ENDEXIT ENDLOOP IF lower<>top THEN IF DSMaps(lower).dsOf<>DSMaps(top).dsOf THEN DSMap:=DSMaps(lower)DSMaps(lower):=DSMaps(top)DSMaps(top):=DSMapENDIF ENDIF IF bottom<lower-1 THEN RUN dsSort(er,which,bottom,lower-1,DSMaps)ENDIF IF lower+1<top THEN RUN dsSort(er,which,lower+1,top,DSMaps)ENDIF END 10 er:=ERREND 