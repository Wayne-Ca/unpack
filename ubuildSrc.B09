PROCEDURE ubuildSrc (* Version 01.00.00 *) (* Variable Array Record *) TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGER DIM varRec(400):VREC (* Variable File Record *) TYPE VFP1=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGER TYPE VFP2=vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGER TYPE VFP3=mTyp,vLnk,fNum:BYTE; pRec,pFld:BOOLEAN TYPE VFRC=vp1:VFP1; vp2:VFP2; vp3:VFP3 DIM varFRec,varFRec2:VFRC (* DSAT Map *) TYPE DSMP=dsOf:REAL; dsDm,dsMSz,dsSz:INTEGER DIM DSMap(100):DSMP (* Records Map *) TYPE RECS=recID:INTEGER; recName:STRING[7] DIM rec(20):RECS (* File filePaths *) DIM vPath,dPath:BYTE (* File,Overlay open status *) DIM vOpen,dOpen:BOOLEAN (* Booleans *) DIM found,validated,endOfType,hasRecords:BOOLEAN (* File names *) DIM version:STRING[8]; vFile,dFile:STRING[29] (* Temporary nTyp *) DIM tnTyp:BYTE (* Variable Reference Counters *) DIM varCount,recCnt:INTEGER (* Various counters *) DIM byteVal,posVal,varCntr:BYTE DIM recNum,intVal,which:INTEGER DIM VDCount:INTEGER DIM dsatCnt,ucCnt:INTEGER DIM gapSize(20),gapCnt,dsMCnt,typCnt,cntr,cntr2,tRec,tSiz,tVar:INTEGER DIM mSize,dsPointer,nextOff,gapOff(20):REAL (* Strings *) DIM tStrLen,typName:STRING[7] DIM tName:STRING[29] DIM source:STRING[512] (* Parameters PARAMs also passed to instruction *) PARAM filePath,outPath:BYTE; er,dataSiz:INTEGER; outExists,verbose:BOOLEAN; descOff,symTabOff:REAL; dataDir:STRING[16]; outFile:STRING[29]  (* **************** *) (* Start of Program *) (* Preliminary initialization of variables *) BASE 0 er:=0 \which:=0 \vOpen:=FALSE \dOpen:=FALSE ON ERROR GOTO 500 \REM goto error trap dOpen:=FALSE dFile:=dataDir+"initDB" OPEN #dPath,dFile:READ dOpen:=TRUE GET #dPath,version SEEK #dPath,SIZE(version)+SIZE(varFRec) \REM skip to DSMap GET #dPath,DSMap \REM initialized DSAT Map array CLOSE #dPath dOpen:=FALSE vFile:=dataDir+"varDefs" dFile:=dataDir+"procData" (* Get data *) OPEN #dPath,dFile:READ dOpen:=TRUE GET #dPath,hasRecords (* Variables lookup table *) GET #dPath,varRec CLOSE #dPath dOpen:=FALSE OPEN #vPath,vFile:UPDATE vOpen:=TRUE GET #vPath,varCount IF symTabOff-descOff>3 THEN    SEEK #filePath,descOff   dsMCnt:=0   SEEK #vPath,2   PRINT #2,"Counting Description Area References";    IF verbose THEN      PRINT #2     PRINT #2,"  Description Area"     PRINT #2,"Ofst Pntr Size DSSiz  Count"   ELSE     PRINT #2,"...";    ENDIF    FOR VDCount:=0 TO varCount-1     found:=TRUE     GET #vPath,varFRec     IF varFRec.vp1.dsSiz>0 THEN        DSMap(dsMCnt).dsOf:=FLOAT(varRec(VDCount).dsOff)       DSMap(dsMCnt).dsDm:=varFRec.vp1.dsPtr       DSMap(dsMCnt).dsMSz:=varFRec.vp1.dsvSiz       DSMap(dsMCnt).dsSz:=varFRec.vp1.dsSiz       IF dsMCnt>0 THEN          IF DSMap(dsMCnt).dsOf=DSMap(dsMCnt-1).dsOf THEN            dsMCnt:=dsMCnt-1           found:=FALSE         ENDIF        ENDIF        IF found THEN          IF verbose THEN            PRINT #2 USING "h4,x1,h4,x1,h4,x1,i5>",DSMap(dsMCnt).dsOf,DSMap(dsMCnt).dsDm,DSMap(dsMCnt).dsMSz,DSMap(dsMCnt).dsSz;            PRINT #2,"  "; dsMCnt+1         ENDIF        ENDIF        dsMCnt:=dsMCnt+1     ENDIF    NEXT VDCount   PRINT "Done"   PRINT #2,"Sorting Description Area References ";    RUN udsSort(er,which,0,dsMCnt-1,DSMap)   IF er>0 THEN 500 \REM goto error trap   PRINT #2," Done"   (* Validate DSAT *)   PRINT #2,"Validating Description Area";    IF verbose THEN      PRINT #2     PRINT #2,"  DSAT"     PRINT #2,"Off  Siz"   ELSE     PRINT " ";   ENDIF    mSize:=symTabOff-3-descOff \gapCnt:=0   dsatCnt:=0 \dsPointer:=0 \VDCount:=0 \validated:=TRUE   SEEK #filePath,descOff   REPEAT      IF VDCount<dsMCnt THEN        IF DSMap(VDCount).dsOf>dsPointer THEN          validated:=FALSE         gapOff(gapCnt):=dsPointer \gapSize(gapCnt):=0         FOR nextOff=1 TO DSMap(VDCount).dsOf-dsPointer           GET #filePath,byteVal           dsPointer:=dsPointer+1           gapSize(gapCnt):=gapSize(gapCnt)+1           IF verbose THEN              PRINT #2 USING "h2",byteVal;            ENDIF          NEXT nextOff         gapCnt:=gapCnt+1         IF verbose THEN            PRINT #2," Unidentified"           PRINT #2         ELSE           PRINT #2,".";         ENDIF          FOR nextOff:=1 TO DSMap(VDCount).dsSz/2           GET #filePath,intVal           dsPointer:=dsPointer+2           IF verbose THEN              PRINT #2 USING "h4,s1",intVal," ";            ENDIF          NEXT nextOff         IF verbose THEN            PRINT #2,"Validated"           PRINT #2         ELSE           PRINT #2,".";         ENDIF        ELSE          FOR nextOff:=1 TO DSMap(VDCount).dsSz/2           GET #filePath,intVal           dsPointer:=dsPointer+2           IF verbose THEN              PRINT #2 USING "h4,s1",intVal," ";            ENDIF          NEXT nextOff         IF verbose THEN            PRINT #2,"Validated"         ELSE           PRINT #2,".";         ENDIF        ENDIF      ENDIF      VDCount:=VDCount+1     dsatCnt:=dsatCnt+1   UNTIL dsPointer>=mSize   IF NOT(verbose) THEN      PRINT #2," ";    ENDIF    PRINT #2,"Done"   IF verbose THEN      GOSUB 268 \REM display counts   ENDIF    PRINT #2   PRINT #2,"There is/are "; gapCnt; " Unidentified Gap(s) in the DSAT"   IF verbose THEN      FOR nextOff:=0 TO gapCnt-1       PRINT #2 USING "s8>,h4,s8>,i4>","Offset: ",gapOff(nextOff),"Size: ",gapSize(nextOff)     NEXT nextOff     PRINT #2   ENDIF    IF verbose AND NOT(validated) THEN      PRINT #2,"Not Validated"   ELSE      IF verbose AND validated THEN        PRINT #2,"Validated "     ENDIF    ENDIF     typCnt:=0 \tName:="" \typName:=""   recNum:=0 \recCnt:=0 \source:=""    (* Set record ID numbers *)   PRINT #2,"Fixing Type Records ";    tRec:=0   FOR recNum=0 TO varCount-1     SEEK #vPath,recNum*SIZE(varFRec)+2     GET #vPath,varFRec     IF varFRec.vp2.pVar>0 AND varFRec.vp2.pVar<>tRec THEN        tRec:=varFRec.vp2.pVar       cntr:=0       REPEAT          SEEK #vPath,cntr*SIZE(varFRec2)+2         GET #vPath,varFRec2         cntr:=cntr+1       UNTIL varFRec2.vp2.vRecNum=varFRec.vp2.pVar       IF cntr>1 THEN          cntr:=cntr-1         FOR cntr2:=0 TO 2           IF cntr-1>0 THEN              cntr:=cntr-1             SEEK #vPath,cntr*SIZE(varFRec)+2             GET #vPath,varFRec             IF varFRec.vp2.vName=varFRec2.vp2.vName THEN                varFRec.vp2.vRecNum:=varFRec2.vp2.vRecNum               SEEK #vPath,cntr*SIZE(varFRec)+2               PUT #vPath,varFRec               PRINT #2,",";              ENDIF            ENDIF          NEXT cntr2       ENDIF        IF cntr<varCount-1 THEN          cntr:=cntr+2         FOR cntr2:=0 TO 2           IF cntr+1<varCount THEN              cntr:=cntr+1             SEEK #vPath,cntr*SIZE(varFRec)+2             GET #vPath,varFRec             IF varFRec.vp2.vName=varFRec2.vp2.vName THEN                varFRec.vp2.vRecNum:=varFRec2.vp2.vRecNum               SEEK #vPath,cntr*SIZE(varFRec)+2               PUT #vPath,varFRec               PRINT #2,".";              ENDIF            ENDIF          NEXT cntr2       ENDIF      ENDIF    NEXT recNum   PRINT #2," Done" ELSE   PRINT #2,"No Description Area References" ENDIF   (* Validate Data Memory Allocation *) PRINT #2,"Validating Data Memory ";  SEEK #vPath,2 cntr:=0 validated:=TRUE REPEAT    GET #vPath,varFRec   IF (varRec(cntr).vTyp>=$80 AND varRec(cntr).vTyp<=$88 OR varRec(cntr).vTyp>=$F2 AND varRec(cntr).vTyp<=$F5) AND varRec(cntr).dmOff<>varRec(cntr+1).dmOff THEN      IF varRec(cntr+1).dmOff>varRec(cntr).dmOff+varFRec.vp1.dmSiz THEN        validated:=FALSE     ENDIF    ENDIF    cntr:=cntr+1   PRINT #2,"."; UNTIL varRec(cntr-1).dmOff+varFRec.vp1.dmSiz=dataSiz OR varRec(cntr).dmOff=dataSiz PRINT #2, " Done" IF validated THEN    PRINT #2,"Data Memory Validated" ELSE    PRINT #2,"Data Memory Not Validated" ENDIF   FOR cntr:=0 TO 19   rec(cntr).recID:=0 \REM record ID # associated to fields   rec(cntr).recName:="" \REM typName for this record variable NEXT cntr  typCnt:=0 \REM # of type statements tName:="" \REM last variable name typName:="" \REM ex: TYPE TYP1= TYP1 is typName tStrLen:="" \REM last variable string length recNum:=0 \REM current variable file record # recCnt:=0 \REM count of record variables ucCnt:=0 tVar:=0 source:="" \REM source statement  (* nTyp = 0: TYPE field variables, all types (* nTyp = 1: DIM types BYTE, INTEGER, REAL, BOOLEAN, STRING, record or array (* nTyp = 2: PARAM variables, all types (* nTyp = 3: variable type F/N 00, 01, 02, and 03, 46 (TO) and 47 (STEP), A0 (subroutine)  (* Output to Screen *) PRINT #2,"Writing dimension statements to "; outFile;  IF NOT(verbose) THEN    PRINT #2," "; ELSE    PRINT #2 ENDIF  (* Create Dimension Statements *) varCntr:=1 REPEAT    SEEK #vPath,recNum*SIZE(varFRec)+2   GET #vPath,varFRec \REM get next record    IF varRec(recNum).nTyp=0 THEN  \REM TYPE statements     (* Start TYPE Statements *)     IF varFRec.vp3.pFld THEN  \REM if a field variable       IF SUBSTR("s",varFRec.vp2.vName)>0 AND tStrLen="" THEN  \REM if string variable         tStrLen:=varFRec.vp2.vStrLen \REM set temp variable to string length modifier       ENDIF        (* nTyp separates user named variables (0-TYPE, 1=DIM and 2=PARAM) from subroutine names *)       (* and internal variables associated to TO and STEP values in FOR/NEXT loops *) 10    IF source="" THEN  \REM if a new statement         typCnt:=typCnt+1 \REM increment type count         typName:="TYP"+STR$(typCnt) \REM assign type name         REM not sure if this part is necessary         REM ==================================         cntr:=0 \found:=FALSE         REPEAT  \REM is this type already defined?           IF rec(cntr).recName=typName THEN              found:=TRUE           ENDIF            cntr:=cntr+1         UNTIL found OR cntr>=recCnt         IF NOT(found) THEN  \REM no, add to rec           rec(recCnt).recID:=varFRec.vp2.pVar \REM pVar = rec# of record variable           rec(recCnt).recName:=typName           recCnt:=recCnt+1           source:="TYPE "+typName+"=" \REM set beginning of statement         ENDIF        REM ==================================       ENDIF        GOSUB 200 \REM check for array       IF varFRec.vp2.vName<>tName THEN  \REM current var name not previous var name         endOfType:=FALSE         (* Is same type? *)         IF tName<>"" THEN            IF SUBSTR("s",tName)>0 AND tStrLen<>varFRec.vp2.vStrLen THEN              endOfType:=TRUE           ELSE              IF tRec<>varFRec.vp2.vRecNum AND SUBSTR("c",tName)>0 THEN                endOfType:=TRUE             ELSE                IF LEFT$(varFRec.vp2.vName,1)=LEFT$(tName,1) AND varFRec.vp2.pVar=tVar THEN \REM ex: b009, b010, both BYTE                 source:=source+"," \REM so separate with a comma               ELSE  \REM ex: b010, i011, not same type                 endOfType:=TRUE \REM so set end of type               ENDIF              ENDIF            ENDIF          ENDIF          (* End of same type? *)         IF endOfType THEN            GOSUB 210 \REM end of type           (* End of statement? *)           (* rec(recCnt-1).recID = current type, so if pVar reflects *)           (* a diff number, end of statement, if pVar=0, not a field *)           (* variable, so end of statement *)           IF varFRec.vp2.pVar<>rec(recCnt-1).recID OR varFRec.vp2.pVar=0 THEN              IF verbose THEN                PRINT #2, source             ELSE               PRINT #2,".";             ENDIF              IF outExists THEN                PRINT #outPath,source             ENDIF              source:="" \REM clear source for next statement             tName:=varFRec.vp2.vName \REM set last var name             tVar:=varFRec.vp2.pVar             tStrLen:=varFRec.vp2.vStrLen             tnTyp:=varRec(recNum).nTyp             IF SUBSTR("c",tName)>0 THEN                tRec:=varFRec.vp2.vRecNum               tSiz:=varFRec.vp1.dsvSiz             ENDIF              GOTO 10 \REM go build next TYPE statement           ELSE              source:=source+"; " \REM prepare to add next var type to statement           ENDIF          ENDIF          (* add current name to statement if not end of statement *)         source:=source+varFRec.vp2.vName \REM add var name to source statement         tName:=varFRec.vp2.vName \REM set last var name         tVar:=varFRec.vp2.pVar         IF SUBSTR("c",tName)>0 THEN            tRec:=varFRec.vp2.vRecNum           tSiz:=varFRec.vp1.dsvSiz         ENDIF        ELSE          (* add current name to statement if beginning of statement *)         IF RIGHT$(source,1)="=" THEN            source:=source+varFRec.vp2.vName         ENDIF        ENDIF      ENDIF    ENDIF     IF varRec(recNum).nTyp=1 OR varRec(recNum).nTyp=2 THEN      (* Start DIM or PARAM Statements *)     IF NOT(hasRecords) AND SUBSTR("S",varFRec.vp2.vName)>0 THEN  \REM if a string variable       tStrLen:=varFRec.vp2.vStrLen \REM set temp variable to string length modifier     ENDIF      (* nTyp separates user named variables (0-TYPE, 1=DIM and 2=PARAM) from subroutine names *)     (* and internal variables associated to TO and STEP values in FOR/NEXT loops *) 15  IF source="" AND varRec(recNum).nTyp=1 THEN  \REM if a new DIM statement       source:="DIM "+varFRec.vp2.vName     ELSE        IF source="" AND varRec(recNum).nTyp=2 THEN  \REM if a new PARAM statement         source:="PARAM "+varFRec.vp2.vName       ENDIF      ENDIF      GOSUB 200 \REM check for array     IF varFRec.vp2.vName<>tName THEN  \REM current var name not previous var name       IF RIGHT$(source,1)<>" " THEN          endOfType:=FALSE         (* Is same type? *)         IF tName<>"" THEN            (* Program variables are named Vnnnn, ex: L0044 is a BOOLEAM type variable *)           (* Parameter variables are named PVnnnn, ex: PR0065 is a REAL type parameter *)           IF SUBSTR("S",tName)>0 AND tStrLen<>varFRec.vp2.vStrLen THEN              endOfType:=TRUE           ELSE              IF tRec<>varFRec.vp2.vRecNum AND SUBSTR("C",tName)>0 THEN                endOfType:=TRUE             ELSE                IF LEFT$(tName,1)<>"P" AND LEFT$(varFRec.vp2.vName,1)<>"P" THEN  \REM ex: B0009, B0010, both BYTE                 IF LEFT$(varFRec.vp2.vName,1)=LEFT$(tName,1) THEN                    IF varCntr=10 THEN  \REM stack only 10 variables of the same type on a single DIM statement                     varCntr:=1                     endOfType:=TRUE                   ELSE                      varCntr:=varCntr+1                     source:=source+"," \REM so separate with a comma                   ENDIF                  ELSE  \REM ex: B0010, I0011, not same type                   endOfType:=TRUE                   varCntr:=1                 ENDIF                ENDIF                IF LEFT$(tName,1)="P" AND LEFT$(varFRec.vp2.vName,1)="P" THEN                  IF MID$(varFRec.vp2.vName,2,1)=MID$(tName,2,1) THEN                    IF varCntr=10 THEN                      varCntr:=1                     endOfType:=TRUE                   ELSE                      varCntr:=varCntr+1                     source:=source+"," \REM so separate same type with a comma                   ENDIF                  ELSE                    endOfType:=TRUE                   varCntr:=1                 ENDIF                ENDIF                IF LEFT$(tName,1)<>"P" AND LEFT$(varFRec.vp2.vName,1)="P" THEN                  endOfType:=TRUE                 tName:=varFRec.vp2.vName               ENDIF              ENDIF            ENDIF          ENDIF          (* End of same type? *)         IF endOfType THEN            GOSUB 210 \REM end of type           (* End of statement? *)           IF varFRec.vp2.pVar=0 THEN              IF verbose THEN                PRINT #2, source             ELSE               PRINT #2,".";             ENDIF              IF outExists THEN                PRINT #outPath,source             ENDIF              source:="" \REM clear source for next statement             tName:=varFRec.vp2.vName \REM set last var name             tStrLen:=varFRec.vp2.vStrLen             tnTyp:=varRec(recNum).nTyp             IF SUBSTR("C",tName)>0 THEN                tRec:=varFRec.vp2.vRecNum               tSiz:=varFRec.vp1.dsvSiz             ENDIF              GOTO 15           ELSE              source:=source+"; "           ENDIF          ENDIF          IF RIGHT$(source,1)=" " OR RIGHT$(source,1)="," THEN            source:=source+varFRec.vp2.vName \REM add var name to source statement         ENDIF          tName:=varFRec.vp2.vName \REM set last var name         tStrLen:=varFRec.vp2.vStrLen         IF SUBSTR("C",tName)>0 THEN            tRec:=varFRec.vp2.vRecNum           tSiz:=varFRec.vp1.dsvSiz         ENDIF        ENDIF      ENDIF      (* Process last variable *)     (* This section may be unnecessary *)     IF recNum=varCount-1 OR recNum<varCount-1 AND SUBSTR("0",varFRec.vp2.vName)=0 THEN        IF SUBSTR("S",tName)>0 THEN          tStrLen:=varFRec.vp2.vStrLen       ENDIF        GOSUB 210 \REM end of type       IF verbose THEN          PRINT #2, source       ELSE         PRINT #2,".";       ENDIF        IF outExists THEN          PRINT #outPath,source       ENDIF      ENDIF      REM ================================     (* end of user variables *)     IF tnTyp<3 THEN        GOSUB 210 \REM end of type       IF verbose THEN          PRINT #2, source       ELSE         PRINT #2,".";       ENDIF        IF outExists THEN          PRINT #outPath,source       ENDIF        tnTyp:=varRec(recNum).nTyp       source:=""     ENDIF    REM ================================   ENDIF    recNum:=recNum+1 UNTIL recNum=varCount  (* Close Files *) CLOSE #vPath vOpen:=FALSE (* End of Program *) END   (* These make the array variable names reflect the array elements *) (* Ex: ba039() becomes ba039(3) *) 200 IF RIGHT$(varFRec.vp2.vName,4)="(,,)" THEN    varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,LEN(varFRec.vp2.vName)-4)+varFRec.vp2.vArray ELSE    IF RIGHT$(varFRec.vp2.vName,3)="(,)" THEN      varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,LEN(varFRec.vp2.vName)-3)+varFRec.vp2.vArray   ELSE      IF RIGHT$(varFRec.vp2.vName,2)="()" THEN        varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,LEN(varFRec.vp2.vName)-2)+varFRec.vp2.vArray     ENDIF    ENDIF  ENDIF  RETURN   210 IF LEFT$(tName,1)="P" THEN    posVal:=2 ELSE    posVal:=1 ENDIF  IF SUBSTR(MID$(tName,posVal,1),"Bb")>0 THEN    source:=source+":BYTE" ELSE    IF SUBSTR(MID$(tName,posVal,1),"Ii")>0 THEN      source:=source+":INTEGER"   ELSE      IF SUBSTR(MID$(tName,posVal,1),"Rr")>0 THEN        source:=source+":REAL"     ELSE        IF SUBSTR(MID$(tName,posVal,1),"Ll")>0 THEN          source:=source+":BOOLEAN"       ELSE          IF SUBSTR(MID$(tName,posVal,1),"Ss")>0 THEN            source:=source+":STRING"           IF tStrLen<>"[32]" THEN              source:=source+tStrLen           ENDIF            tStrLen:=varFRec.vp2.vStrLen         ELSE            IF SUBSTR(MID$(tName,posVal,1),"Cc")>0 THEN              found:=FALSE             FOR cntr:=0 TO recCnt-1               IF tRec=rec(cntr).recID THEN                  source:=source+":"+rec(cntr).recName                 found:=TRUE               ENDIF              NEXT cntr             IF NOT(found) THEN                typCnt:=typCnt+1               ucCnt:=ucCnt+1               typName:="TYP"+STR$(typCnt)               IF verbose THEN                  PRINT "TYPE "; typName; "=uC"; ucCnt; "("; tSiz; "):BYTE"               ELSE                 PRINT ".";               ENDIF                IF outExists THEN                 PRINT #outPath,"TYPE "; typName; "=uC"; ucCnt; "("; tSiz; "):BYTE"               ENDIF               source:=source+":"+typName             ENDIF            (* Have to figure this part out *)           ENDIF          ENDIF        ENDIF      ENDIF    ENDIF  ENDIF  RETURN   (* Display Counts *) 268 PRINT #2,"Description Area Entries: "; dsatCnt RETURN   (* Error Trap *) 500 er:=ERR IF vOpen THEN    CLOSE #vPath   vOpen:=FALSE ENDIF  IF dOpen THEN    CLOSE #dPath   dOpen:=FALSE ENDIF  END PROCEDURE udsSort (* based on quicksort, by T.F. Ritter (* DSAT Map *) TYPE DSMP=dsOf:REAL; dsDm,dsMSz,dsSz:INTEGER DIM DSMap:DSMP PARAM er,which:INTEGER; bottom,top:INTEGER; DSMaps(100):DSMP DIM lower,upper:INTEGER; btemp:BOOLEAN  ON ERROR GOTO 10  which:=which+1 PRINT #2,".";  BASE 0  lower:=bottom upper:=top  LOOP  \REM each element gets the once over    REPEAT  \REM this is a postinc instruction     btemp:=DSMaps(lower).dsOf<DSMaps(top).dsOf     lower:=lower+1   UNTIL NOT(btemp)   lower:=lower-1 \REM point at the tested element EXITIF lower=upper THEN  ENDEXIT     REPEAT  \REM this is a postdec instruction     upper:=upper-1   UNTIL DSMaps(upper).dsOf<=DSMaps(top).dsOf OR upper=lower EXITIF lower=upper THEN  ENDEXIT     DSMap:=DSMaps(lower)   DSMaps(lower):=DSMaps(upper)   DSMaps(upper):=DSMap    lower:=lower+1 \REM prepare for postinc EXITIF lower=upper THEN  ENDEXIT   ENDLOOP   IF lower<>top THEN    IF DSMaps(lower).dsOf<>DSMaps(top).dsOf THEN      DSMap:=DSMaps(lower)     DSMaps(lower):=DSMaps(top)     DSMaps(top):=DSMap   ENDIF  ENDIF   IF bottom<lower-1 THEN    RUN udsSort(er,which,bottom,lower-1,DSMaps) ENDIF  IF lower+1<top THEN    RUN udsSort(er,which,lower+1,top,DSMaps) ENDIF   END   10 er:=ERR END 