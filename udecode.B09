PROCEDURE udecode (* Version 01.00.00 *) (* Variable Array Record *) TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGER DIM varRec(400):VREC (* Variable File Record *) TYPE VFP1=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGER TYPE VFP2=vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGER TYPE VFP3=mTyp,vLnk,fNum:BYTE; pRec,pFld:BOOLEAN TYPE VFRC=vp1:VFP1; vp2:VFP2; vp3:VFP3 DIM varFRec,defFRec:VFRC (* Line Reference Record *) (* Array *) TYPE LNREF=hLTyp:BYTE; hLOff:INTEGER DIM linRefs(300):LNREF (* File Record *) TYPE LNREC=lnRecNum,lnRefCnt:INTEGER; lnTyp:BYTE; lnOff:INTEGER; lnNum:STRING[5] DIM linRec:LNREC (* DSAT Map Record *) TYPE DSMP=dsOf:REAL; dsDm,dsMSz,dsSz:INTEGER DIM DSMap(100):DSMP (* Counters and Input Variables *) DIM tokenVal,byteVal,linkVal:BYTE DIM nextRef,recCount,tInstr:INTEGER DIM quote,modCnt,intVal,tmpTyp,intOrReal:INTEGER DIM realVal:REAL (* Flag Variables *) DIM found,nextVar,forVar,namVar,creOp,isOn,isRestore,renum,potRec,isField,extRef,hasRecords:BOOLEAN (* Variable Reference Counters *) DIM varRefs,varCount:INTEGER (* Line Reference Counters *) DIM lineRefs,linCount,lnCnt:INTEGER DIM lastOff:INTEGER; lastNum:STRING[5] (* File Paths *) DIM vPath,lnPath,dPath:BYTE (* File,Overlay Open Status *) DIM vOpen,lnOpen,dOpen:BOOLEAN (* Error and Module Data *) DIM which:INTEGER (* Strings *) (* File names *) DIM vFile,lnFile,dFile:STRING[29] DIM version:STRING[8]  (* I-Code File Pathname *) PARAM filePath:BYTE; er,tpVars:INTEGER; verbose:BOOLEAN; execOff,descOff,symTabOff,dataoff:REAL; dataDir:STRING[16]; modName:STRING[29]  (* **************** *) (* Start of Program *) (* Preliminary initialization of variables *) BASE 0 vOpen:=FALSE \lnOpen:=FALSE \dOpen:=FALSE ON ERROR GOTO 500 \REM goto error trap dFile:=dataDir+"initDB" GOSUB 400 \REM get data from initDB (* Flags *) creOp:=FALSE \isOn:=FALSE isRestore:=FALSE \nextVar:=FALSE \found:=FALSE \potRec:=FALSE \extRef:=FALSE (* Counters and Program Variables *) quote:=0 \modCnt:=0 \tmpTyp:=0 \recCount:=0 \tInstr:=0 tokenVal:=0 \byteVal:=0 \intVal:=0 \realVal:=0 \which:=0 (* Variable Reference Counters *) varRefs:=0 \varCount:=0 (* Line Reference Counters *) lineRefs:=0 \linCount:=0 (* Open Reference Files *) vFile:=dataDir+"varDefs" lnFile:=dataDir+"linDefs" dFile:=dataDir+"procData" (* Variable Reference *) OPEN #vPath,vFile:UPDATE vOpen:=TRUE (* Line Reference *) OPEN #lnPath,lnFile:UPDATE lnOpen:=TRUE  hasRecords:=FALSE \REM used in defVars and buildSrc  (* Start of Program *) (* Total Program Variables *) (* does not include REAL or STRING variables defined by use. *) 20 SEEK #filePath,symTabOff-3 GET #filePath,tpVars PRINT #2, "Total Program Variables: "; tpVars  (* This is the main routine. *) (* Decode Instructions *) GOSUB 200  (* Line Reference List, Sort, Number *) IF linCount>0 THEN    GOSUB 300 ELSE    PRINT #2, "No Line References" ENDIF  PRINT #2,"Total Variable References Found: "; varRefs PRINT #2,"Total Unique Variable References: "; varCount PRINT #2,"Total Instruction Statements: "; tInstr  (* Close Files *) CLOSE #vPath vOpen:=FALSE CLOSE #lnPath lnOpen:=FALSE (* Save Data *) PRINT #2, "Saving data..."; (* This data is saved so each part has access to the data *) OPEN #dPath,dFile:WRITE dOpen:=TRUE PUT #dPath,hasRecords (* Variables lookup table *) PUT #dPath,varRec (* Variable Reference Counts *) PUT #dPath,varRefs \ PUT #dPath,varCount (* Line Reference Counts *) PUT #dPath,lineRefs \ PUT #dPath,linCount (* Close Data File *) CLOSE #dPath dOpen:=FALSE PRINT #2, "Done" (* End of Program *) END  (* Instruction Decode *) (* Instruction code section, first pass *) (* This section will direct all window output to stderr. *) 200 SEEK #filePath,execOff PRINT #2, "Decoding "; modName; " "; IF verbose THEN   PRINT #2 ENDIF modCnt:=0 \forVar:=FALSE \namVar:=TRUE REPEAT   extRef:=FALSE   IF verbose THEN     PRINT #2 USING "h4,s1",modcnt+32," ";   ENDIF   REPEAT     GET #filePath,tokenVal     IF verbose THEN       PRINT #2 USING "h2,s1",tokenVal," ";     ENDIF     modCnt:=modCnt+1 \REM I-Code area offset     (* ON {var} GOTO/GOSUB statement for <ivgt> count *)     IF tokenVal=$1D THEN       isOn:=TRUE  \REM this statement is a ON statement     ENDIF     (* KILL References *)     IF tokenVal=$24 THEN       extRef:=TRUE \REM external reference (SHELL, CHAIN, etc.)       linkVal:=tokenVal \REM for linking external statements with strings or literals. not uased by decode.     ENDIF     (* OPEN or CREATE statement for file mode *)     IF tokenVal=$29 OR tokenVal=$2A THEN       creOp:=TRUE \extRef:=TRUE \linkVal:=tokenVal     ENDIF     (* CLOSE References *)     IF tokenVal=$30 THEN       extRef:=TRUE \linkVal:=tokenVal     ENDIF     (* RESTORE References *)     IF tokenVal=$31 THEN       isRestore:=TRUE     ENDIF     (* DELETE References *)     IF tokenVal=$32 THEN       extRef:=TRUE \linkVal:=tokenVal     ENDIF     (* CHAIN References *)     IF tokenVal=$33 THEN       extRef:=TRUE \linkVal:=tokenVal     ENDIF     (* SHELL References *)     IF tokenVal=$34 THEN       extRef:=TRUE \linkVal:=tokenVal     ENDIF     (* Complex Variable Assignments *)     IF tokenVal=$0E THEN       ! keeping this for the token reference     ENDIF     (* Variable References *)     IF tokenVal=$13 OR tokenVal=$14 THEN  \REM FOR(13) NEXT(14)       IF tokenVal=$13 THEN         forVar:=TRUE       ELSE         nextVar:=TRUE       ENDIF       GET #filePath,tokenVal       IF verbose THEN         PRINT #2 USING "h2,s1",tokenVal," ";       ENDIF       modCnt:=modCnt+1     ENDIF     IF forVar THEN       IF tokenVal=$81 THEN  \REM INTEGER variable         intOrReal:=1       ELSE         IF tokenVal=$82 THEN  \REM REAL variable           intOrReal:=2         ENDIF       ENDIF       IF tokenVal=$46 OR tokenVal=$47 THEN  \REM TO(46) STEP(47)         namVar:=FALSE         varFRec.vp2.intReal:=intOrReal       ELSE         namVar:=TRUE       ENDIF     ENDIF     (* =============== =============== *)     (* 00 INT no STEP  23 RUN          *)     (* 01 INT w/ STEP  46 TO           *)     (* 02 REAL no STEP 47 STEP         *)     (* 03 REAL w/ STEP                 *)     (* 80-8C/F2-F9 Variable references *)     (* =============== =============== *)     IF nextVar AND (tokenVal>=$00 AND tokenVal<=$03) OR tokenVal=$23 OR tokenVal=$46 OR tokenVal=$47 OR tokenVal>=$80 AND tokenVal<=$8C OR tokenVal>=$F2 AND tokenVal<=$F9 THEN       GET #filePath,intVal       IF verbose THEN         PRINT #2 USING "h4,s1",intVal," ";       ENDIF       modCnt:=modCnt+2       varRefs:=varRefs+1       GOSUB 210 \REM add variable reference       IF nextVar THEN         FOR nextRef:=1 TO 3           GET #filePath,intVal           IF verbose THEN             PRINT #2 USING "h4,s1",intVal," ";           ENDIF           modCnt:=modCnt+2               IF nextRef=1 THEN             namVar:=FALSE             GOSUB 210 \REM add variable reference           ELSE             IF nextRef=2 THEN               IF intVal>0 THEN                 namVar:=FALSE                 GOSUB 210 \REM add variable reference               ENDIF             ELSE               IF nextRef=3 THEN                 namVar:=TRUE               ENDIF             ENDIF           ENDIF         NEXT nextRef         nextVar:=FALSE       ENDIF     (* Literals *)     ELSE       IF tokenVal>=$8D AND tokenVal<=$91 AND tokenVal<>$90 THEN         (* BYTE Literals *)         IF tokenVal=$8D THEN           GET #filePath,byteVal           IF verbose THEN             PRINT #2 USING "h2,s1",byteVal," ";           ENDIF           modCnt:=modCnt+1         (* REAL Literals *)         ELSE           IF tokenVal=$8F THEN             GET #filePath,realVal             IF verbose THEN               PRINT #2 USING "h10,s1",realVal," ";             ENDIF             modCnt:=modCnt+5           (* INTEGER and HEX Literals *)           ELSE             GET #filePath,intVal             IF verbose THEN               PRINT #2 USING "h4,s1",intVal," ";             ENDIF             modCnt:=modCnt+2                 ENDIF         ENDIF       (* String Literals *)       ELSE         IF tokenVal=$90 THEN         quote:=tokenVal           REPEAT             GET #filePath,byteVal             IF verbose AND byteVal<>$FF THEN               PRINT #2 USING "h2",byteVal;               quote:=0             ENDIF             modCnt:=modCnt+1           UNTIL byteVal=$FF           IF verbose THEN             IF byteVal=$FF AND quote<>144 THEN               PRINT #2," ";             ENDIF             PRINT #2 USING "h2,s1",byteVal," ";           ENDIF         (* Line References *)         ELSE           (* =============== =============== *)           (* 20 GOTO         16 ENDWHILE     *)           (* 22 GOSUB        1A ENDLOOP      *)           (* 55 ivgt         1C ENDEXIT      *)           (* 11 ELSE         3B blrf         *)           (* =============== =============== *)           IF tokenVal=$20 OR tokenVal=$22 OR tokenVal=$55 OR tokenVal=$11 OR tokenVal=$16 OR tokenVal=$1A OR tokenVal=$1C OR tokenVal=$3B THEN             GET #filePath,intVal             IF verbose THEN               PRINT #2 USING "h4,s1",intVal," ";             ENDIF             modCnt:=modCnt+2                   lineRefs:=lineRefs+1             IF isRestore AND tokenVal=$3B THEN             ENDIF             IF isOn THEN               isOn:=FALSE             ENDIF             IF tokenVal=$20 OR tokenVal=$22 OR tokenVal=$3B THEN               GOSUB 220 \REM add line number reference             ENDIF           ELSE             IF tokenVal=$46 OR tokenVal=$47 THEN               GET #filePath,intVal               IF verbose THEN                 PRINT #2 USING "h4,s1",intVal," ";               ENDIF               modCnt:=modCnt+2                     ENDIF           ENDIF         ENDIF       ENDIF     ENDIF     (* Get File Open/Create Mode *)     IF tokenVal=$4A AND creOp THEN       GET #filePath,byteVal       IF verbose THEN         PRINT #2 USING "h2,s1",byteVal," ";       ENDIF       modCnt:=modCnt+1       creOp:=FALSE     ENDIF   (* End of Instruction Statement *)   UNTIL tokenVal=$3E OR tokenVal=$3F   IF verbose THEN     PRINT #2   ELSE     PRINT #2, ".";   ENDIF   IF forVar THEN     forVar:=FALSE   ENDIF   IF NOT(namVar) THEN     namVar:=TRUE   ENDIF   IF tokenVal=$3E THEN     tInstr:=tInstr+1   ENDIF   IF tokenVal=$3F THEN     tInstr:=tInstr+1   ENDIF   IF isOn THEN     isOn:=FALSE   ENDIF   IF isRestore THEN     isRestore:=FALSE   ENDIF (* End of Instruction Code Section *) UNTIL modCnt=descOff-execOff IF NOT(verbose) THEN   PRINT #2," "; ENDIF PRINT #2, "Done" RETURN  (* Identify Duplicate and Add Variable Record *) (* Is it a field? *) 210 IF tokenVal>=$F6 AND tokenVal<=$F9 OR tokenVal>=$89 AND tokenVal<=$8C THEN   isField:=TRUE ELSE   isField:=FALSE ENDIF (* Is it a potential record? *) (* At this stage whether a reference is a record or not *) (* is not determinable. That happens in defVars. *) IF tokenVal>=$85 AND tokenVal<=$8C OR tokenVal>=$F2 AND tokenVal<=$F9 THEN   potRec:=TRUE ELSE   potRec:=FALSE ENDIF (* Search Records *) recCount:=0 \found:=FALSE IF varCount>0 THEN   REPEAT     IF tokenVal=varRec(recCount).vTyp THEN       IF intVal=varRec(recCount).vOff THEN         found:=TRUE         SEEK #vPath,recCount*SIZE(varFRec)+2         GET #vPath,varFRec         SEEK #vPath,recCount*SIZE(varFRec)+2       ENDIF     ENDIF     EXITIF found THEN     ENDEXIT     recCount:=recCount+1   UNTIL found OR recCount=varCount ENDIF (* Add Record *) IF NOT(found) THEN   varFRec:=defFRec   varRec(varCount).vTyp:=0 \varRec(varCount).nTyp:=0 \varRec(varCount).nVar:=FALSE   varRec(varCount).vOff:=0 \varRec(varCount).vdOff:=0 \varRec(varCount).dsOff:=0   varRec(varCount).dmOff:=0 \varRec(varCount).fOff:=0 \varRec(varCount).pOff:=0   SEEK #vPath,varCount*SIZE(varFRec)+2   varRec(varCount).vTyp:=tokenVal   varRec(varCount).vOff:=intVal   varRec(varCount).nVar:=namVar   varCount:=varCount+1   varFRec.vp2.vRecNum:=varCount   varFRec.vp2.vRefCnt:=1   varFRec.vp3.pRec:=FALSE   varFRec.vp3.vLnk:=0   varFRec.vp2.vArray:=""   varFRec.vp2.vName:=""   varFRec.vp2.vStrLen:=""   IF tokenVal>=$80 AND tokenVal<=$83 OR tokenVal>=$00 AND tokenVal<=$03 OR tokenVal=$46 OR tokenVal=$47 THEN     varFRec.vp3.mTyp:=1 \REM atomic type: BYTE, INTEGER, REAL, BOOLEAN   ENDIF   IF tokenVal=$84 THEN     varFRec.vp3.mTyp:=2 \REM atomic type: STRING   ENDIF   IF tokenVal>$84 OR tokenVal=$23 THEN     varFRec.vp3.mTyp:=3 \REM all others point to the VDT   ENDIF   IF extRef THEN     varFRec.vp3.vLnk:=linkVal \REM external link reference - unused   ENDIF ENDIF (* Connect Records with Fields *) IF isField THEN   varFRec.vp2.pVar:=tmpTyp   varFRec.vp3.pFld:=TRUE ELSE   varFRec.vp2.pVar:=0   varFRec.vp3.pFld:=FALSE ENDIF IF potRec THEN   varFRec.vp3.pRec:=TRUE   tmpTyp:=varFRec.vp2.vRecNum ELSE   varFRec.vp3.pRec:=FALSE ENDIF IF found THEN   varFRec.vp2.vRefCnt:=varFRec.vp2.vRefCnt+1 ENDIF PUT #vPath,varFRec IF NOT(found) THEN   SEEK #vPath,0   PUT #vPath,varCount ENDIF RETURN  (* Identify Duplicate and Add Line Record *) (* Search Records *) 220 recCount:=0 \found:=FALSE IF NOT(isRestore) OR isRestore AND intVal<>dataoff THEN   IF linCount>0 THEN     REPEAT       IF tokenVal=linRefs(recCount).hLTyp THEN         IF intVal=linRefs(recCount).hLOff THEN           found:=TRUE           SEEK #lnPath,recCount*SIZE(linRec)+2           GET #lnPath,linRec           linRec.lnRefCnt:=linRec.lnRefCnt+1           SEEK #lnPath,recCount*SIZE(linRec)+2           PUT #lnPath,linRec         ENDIF       ENDIF       recCount:=recCount+1     UNTIL found OR recCount=linCount   ENDIF   (* Add Record *)   IF NOT(found) THEN     SEEK #lnPath,linCount*SIZE(linRec)+2     linRefs(linCount).hLTyp:=tokenVal     linRefs(linCount).hLOff:=intVal     linCount:=linCount+1     linRec.lnRecNum:=linCount     linRec.lnRefCnt:=1     linRec.lnTyp:=tokenVal     linRec.lnOff:=intVal     PUT #lnPath,linRec     SEEK #lnPath,0     PUT #lnPath,linCount   ENDIF ENDIF RETURN  (* Sort Line References *) 300 IF linCount>1 THEN   PRINT #2, "Sorting Line References ";   renum:=TRUE   SEEK #lnPath,0   RUN ulSort (er,which,lnPath,0,linCount-1,linRefs)   IF er>0 THEN 500 \REM goto error trap   PRINT #2, " Done" ELSE   IF linCount=1 THEN     renum:=TRUE   ELSE     renum:=FALSE   ENDIF ENDIF IF renum THEN   PRINT #2, "Numbering Line Referrences ";   IF verbose THEN     PRINT #2   ENDIF   SEEK #lnPath,2   recCount:=0 \lnCnt:=0   (* Line Number Assignment *)   lastOff:=0 \lastNum:=""   REPEAT     GET #lnPath,linRec     linRec.lnRecNum:=recCount+1     IF lnCnt>0 AND linRec.lnOff=lastOff THEN \REM same reference       linRec.lnNum:=lastNum \REM gets same number     ELSE \REM next number       linRec.lnNum:=STR$((lnCnt+1)*10)       lastOff:=linRec.lnOff       lastNum:=linRec.lnNum       lnCnt:=lnCnt+1     ENDIF     SEEK #lnPath,recCount*SIZE(linRec)+2     PUT #lnPath,linRec     IF verbose THEN       PRINT #2 USING "i3>,s1,i3>,s1,h2,s1,h4,s1,s5",linRec.lnRecNum," ",linRec.lnRefCnt," ",linRec.lnTyp," ",linRec.lnOff," ",linRec.lnNum     ELSE       PRINT ".";     ENDIF     recCount:=recCount+1   UNTIL recCount=linCount   IF NOT(verbose) THEN     PRINT #2," ";   ENDIF   PRINT #2, "Done"   PRINT #2, "Total Line References Found: "; linCount ELSE   IF linCount=0 THEN     PRINT #2, "No Line References Found"   ENDIF   IF linCount=1 THEN     PRINT #2, linCount; " Line Reference Found"   ENDIF ENDIF RETURN  (* Get Data from initDB *) 400 OPEN #dPath,dFile:READ dOpen:=TRUE GET #dPath,version GET #dPath,defFRec \REM initialized variable file record GET #dPath,DSMap \REM initialized DSAT Map array CLOSE #dPath dOpen:=FALSE RETURN  (* Error Trap *) 500 er:=ERR IF vOpen THEN   CLOSE #vPath   vOpen:=FALSE ENDIF IF lnOpen THEN   CLOSE #lnPath   lnOpen:=FALSE ENDIF IF dOpen THEN   CLOSE #dPath   dOpen:=FALSE ENDIF ENDPROCEDURE ulSort (* based on quicksort, by T.F. Ritter (* Line Reference Record *) (* Array *) TYPE LNREF=hLTyp:BYTE; hLOff:INTEGER DIM linRef:LNREF (* Record *) TYPE LNREC=lnRecNum,lnRefCnt:INTEGER; lnTyp:BYTE; lnOff:INTEGER; lnNum:STRING[5] DIM linRec,linRecs(2):LNREC PARAM er,which:INTEGER; lnPath:BYTE; bottom,top:INTEGER; linRefs(300):LNREF DIM lower,upper:INTEGER; btemp:BOOLEAN  ON ERROR GOTO 10  which:=which+1 PRINT #2,".";  BASE 0  lower:=bottom upper:=top  LOOP \REM each element gets the once over    REPEAT \REM this is a postinc instruction     btemp:=linRefs(lower).hLOff<linRefs(top).hLOff     lower:=lower+1   UNTIL NOT(btemp)   lower:=lower-1 \REM point at the tested element   EXITIF lower=upper THEN   ENDEXIT    REPEAT \REM this is a postdec instruction     upper:=upper-1   UNTIL linRefs(upper).hLOff<=linRefs(top).hLOff OR upper=lower   EXITIF lower=upper THEN   ENDEXIT    SEEK #lnPath,lower*SIZE(linRec)+2   GET #lnPath,linRec   linRecs(0):=linRec   SEEK #lnPath,upper*SIZE(linRec)+2   GET #lnPath,linRec   linRecs(1):=linRec   linRef:=linRefs(lower)   linRefs(lower):=linRefs(upper)   linRefs(upper):=linRef   linRec:=linRecs(0)   linRecs(0):=linRecs(1)   linRecs(1):=linRec   SEEK #lnPath,lower*SIZE(linRec)+2   linRec:=linRecs(0)   PUT #lnPath,linRec   SEEK #lnPath,upper*SIZE(linRec)+2   linRec:=linRecs(1)   PUT #lnPath,linRec    lower:=lower+1 \REM prepare for postinc   EXITIF lower=upper THEN   ENDEXIT  ENDLOOP  IF lower<>top THEN   IF linRefs(lower).hLOff<>linRefs(top).hLOff THEN     SEEK #lnPath,lower*SIZE(linRec)+2     GET #lnPath,linRec     linRecs(0):=linRec     SEEK #lnPath,top*SIZE(linRec)+2     GET #lnPath,linRec     linRecs(1):=linRec     linRef:=linRefs(lower)     linRefs(lower):=linRefs(top)     linRefs(top):=linRef     linRec:=linRecs(0)     linRecs(0):=linRecs(1)     linRecs(1):=linRec     SEEK #lnPath,lower*SIZE(linRec)+2     linRec:=linRecs(0)     PUT #lnPath,linRec     SEEK #lnPath,top*SIZE(linRec)+2     linRec:=linRecs(1)     PUT #lnPath,linRec   ENDIF ENDIF  IF bottom<lower-1 THEN   RUN ulSort(er,which,lnPath,bottom,lower-1,linRefs) ENDIF IF lower+1<top THEN   RUN ulSort(er,which,lnPath,lower+1,top,linRefs) ENDIF  END  10 er:=ERR END