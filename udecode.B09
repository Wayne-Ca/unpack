PROCEDURE udecode(* Version 01.00.00 *)(* Declarations *)(* Variable Record *)(* Array *)TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGERDIM varRec(400):VREC(* File Record *)TYPE VFP1=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGERTYPE VFP2=vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGERTYPE VFP3=mTyp,vLnk,fNum:BYTE; pRec,pFld:BOOLEANTYPE VFRC=vp1:VFP1; vp2:VFP2; vp3:VFP3DIM varFRec,defFRec:VFRC(* Line Reference Record *)(* Array *)TYPE LNREF=hLTyp:BYTE; hLOff:INTEGERDIM linRefs(300):LNREF(* File Record *)TYPE LNREC=lnRecNum,lnRefCnt:INTEGER; lnTyp:BYTE; lnOff:INTEGER; lnNum:STRING[5]DIM linRec:LNREC(* DSAT Map Record *)TYPE DSMP=dsOf:REAL; dsDm,dsMSz,dsSz:INTEGERDIM DSMap(100):DSMP(* Counters and Input Variables *)DIM tokenVal,byteVal,linkVal:BYTEDIM loopCnt,nextRef,recCount,tInstr:INTEGERDIM quote,modCnt,intVal,tmpTyp,intOrReal:INTEGERDIM realVal:REAL(* Flag Variables *)DIM found,nextVar,forVar,namVar,creop,isOn,isRestore,renum,potRec,isField,extRef,hasRecords:BOOLEAN(* Variable Reference Counters *)DIM varRefs,varCount:INTEGER(* Line Reference Counters *)DIM lineRefs,linCount,lnCnt:INTEGERDIM lastOff:INTEGER; lastNum:STRING[5](* File Paths *)DIM vPath,lnPath,dPath:BYTE(* File,Overlay Open Status *)DIM vOpen,lnOpen,dOpen:BOOLEAN(* Error and Module Data *)DIM which,dataStAdd:INTEGER(* Strings *)(* File names *)DIM vFile,lnFile,dFile:STRING[29](* I-Code File Pathname *)PARAM path:BYTE; er,tpVars:INTEGER; pOpen,verbose:BOOLEAN; execOff,descOff,symTabOff:REAL; dataDir:STRING[16]; modName:STRING[29](* Preliminary Assignments *)BASE 0vOpen:=FALSE \lnOpen:=FALSE \dOpen:=FALSEON ERROR GOTO 500 \REM goto error trapdFile:=dataDir+"initDB"(* For options definitions, see setOpts.B09 *)GOSUB 400 \REM get data from initDB! proc1:=file(* Flags *)creop:=FALSE \isOn:=FALSEisRestore:=FALSE \nextVar:=FALSE \found:=FALSE \potRec:=FALSE \extRef:=FALSE(* Counters and Program Variables *)quote:=0 \modCnt:=0 \tmpTyp:=0 \recCount:=0 \tInstr:=0tokenVal:=0 \byteVal:=0 \intVal:=0 \realVal:=0 \which:=0(* Variable Reference Counters *)varRefs:=0 \varCount:=0(* Line Reference Counters *)lineRefs:=0 \linCount:=0(* Open Reference Files *)vFile:=dataDir+"varDefs"lnFile:=dataDir+"linDefs"dFile:=dataDir+"procData"(* Variable Reference *)OPEN #vPath,vFile:UPDATEvOpen:=TRUE(* Line Reference *)OPEN #lnPath,lnFile:UPDATElnOpen:=TRUEhasRecords:=FALSE \REM used in defVars and buildSrc(* Start of Program *)(* Total Program Variables *)(* does not include REAL or STRING variables defined by use. *)20 SEEK #path,symTabOff-3GET #path,tpVarsPRINT #2, "Total Program Variables: "; tpVars(* This is the main routine. *)(* Decode Instructions *)GOSUB 200(* Line Reference List, Sort, Number *)IF linCount>0 THEN   GOSUB 300ELSE   PRINT #2, "No Line References"ENDIF PRINT #2,"Total Variable References Found: "; varRefsPRINT #2,"Total Unique Variable References: "; varCountPRINT #2,"Total Instruction Statements: "; tInstr(* Close Files *)CLOSE #vPathvOpen:=FALSECLOSE #lnPathlnOpen:=FALSE(* Save Data *)PRINT #2, "Saving data...";(* This data is saved so each part has access to the data *)OPEN #dPath,dFile:WRITEdOpen:=TRUEPUT #dPath,hasRecords(* Variables lookup table *)PUT #dPath,varRec(* Variable Reference Counts *)PUT #dPath,varRefs \ PUT #dPath,varCount(* Line Reference Counts *)PUT #dPath,lineRefs \ PUT #dPath,linCount(* Close Data File *)CLOSE #dPathdOpen:=FALSEPRINT #2, "Done"(* Chain to defVars *)! CHAIN chainMod(* End of Program *)END(* ============= *)(* == Group 2 == *)(* Instruction Decode *)(* Instruction code section, first pass *)(* This section will direct all window output to stderr. *)(* Instruction decode *)200 SEEK #path,execOffPRINT #2, "Decoding "; modName; " ";IF verbose THEN  PRINT #2ENDIFmodCnt:=0 \forVar:=FALSE \namVar:=TRUEREPEAT  extRef:=FALSE  IF verbose THEN    PRINT #2 USING "h4,s1",modcnt+32," ";  ENDIF  REPEAT    GET #path,tokenVal    IF verbose THEN      PRINT #2 USING "h2,s1",tokenVal," ";    ENDIF    modCnt:=modCnt+1 \REM I-Code area offset    (* ON {var} GOTO/GOSUB statement for <ivgt> count *)    IF tokenVal=$1D THEN      isOn:=TRUE  \REM this statement is a ON statement    ENDIF    (* KILL References *)    IF tokenVal=$24 THEN      extRef:=TRUE \REM external reference (SHELL, CHAIN, etc.)      linkVal:=tokenVal \REM for linking external statements with strings or literals. not uased by decode.    ENDIF    (* OPEN or CREATE statement for file mode *)    IF tokenVal=$29 OR tokenVal=$2A THEN      creop:=TRUE \extRef:=TRUE \linkVal:=tokenVal    ENDIF    (* CLOSE References *)    IF tokenVal=$30 THEN      extRef:=TRUE \linkVal:=tokenVal    ENDIF    (* RESTORE References *)    IF tokenVal=$31 THEN      isRestore:=TRUE    ENDIF    (* DELETE References *)    IF tokenVal=$32 THEN      extRef:=TRUE \linkVal:=tokenVal    ENDIF    (* CHAIN References *)    IF tokenVal=$33 THEN      extRef:=TRUE \linkVal:=tokenVal    ENDIF    (* SHELL References *)    IF tokenVal=$34 THEN      extRef:=TRUE \linkVal:=tokenVal    ENDIF    (* Complex Variable Assignments *)    IF tokenVal=$0E THEN      ! keeping this for the token reference    ENDIF    (* Variable References *)    IF tokenVal=$13 OR tokenVal=$14 THEN  \REM FOR(13) NEXT(14)      IF tokenVal=$13 THEN        forVar:=TRUE      ELSE        nextVar:=TRUE      ENDIF      GET #path,tokenVal      IF verbose THEN        PRINT #2 USING "h2,s1",tokenVal," ";      ENDIF      modCnt:=modCnt+1    ENDIF    IF forVar THEN      IF tokenVal=$81 THEN  \REM INTEGER variable        intOrReal:=1      ELSE        IF tokenVal=$82 THEN  \REM REAL variable          intOrReal:=2        ENDIF      ENDIF      IF tokenVal=$46 OR tokenVal=$47 THEN  \REM TO(46) STEP(47)        namVar:=FALSE        varFRec.vp2.intReal:=intOrReal      ELSE        namVar:=TRUE      ENDIF    ENDIF    (* =============== =============== *)    (* 00 INT no STEP  23 RUN          *)    (* 01 INT w/ STEP  46 TO           *)    (* 02 REAL no STEP 47 STEP         *)    (* 03 REAL w/ STEP                 *)    (* 80-8C/F2-F9 Variable references *)    (* =============== =============== *)    IF nextVar AND (tokenVal>=$00 AND tokenVal<=$03) OR tokenVal=$23 OR tokenVal=$46 OR tokenVal=$47 OR tokenVal>=$80 AND tokenVal<=$8C OR tokenVal>=$F2 AND tokenVal<=$F9 THEN      GET #path,intVal      IF verbose THEN        PRINT #2 USING "h4,s1",intVal," ";      ENDIF      modCnt:=modCnt+2      varRefs:=varRefs+1      GOSUB 210 \REM add variable reference      IF nextVar THEN        FOR nextRef:=1 TO 3          GET #path,intVal          IF verbose THEN            PRINT #2 USING "h4,s1",intVal," ";          ENDIF          modCnt:=modCnt+2              IF nextRef=1 THEN            namVar:=FALSE            GOSUB 210 \REM add variable reference          ELSE            IF nextRef=2 THEN              IF intVal>0 THEN                namVar:=FALSE                GOSUB 210 \REM add variable reference              ENDIF            ELSE              IF nextRef=3 THEN                namVar:=TRUE              ENDIF            ENDIF          ENDIF        NEXT nextRef        nextVar:=FALSE      ENDIF    (* Literals *)    ELSE      IF tokenVal>=$8D AND tokenVal<=$91 AND tokenVal<>$90 THEN        (* BYTE Literals *)        IF tokenVal=$8D THEN          GET #path,byteVal          IF verbose THEN            PRINT #2 USING "h2,s1",byteVal," ";          ENDIF          modCnt:=modCnt+1        (* REAL Literals *)        ELSE          IF tokenVal=$8F THEN            GET #path,realVal            IF verbose THEN              PRINT #2 USING "h10,s1",realVal," ";            ENDIF            modCnt:=modCnt+5          (* INTEGER and HEX Literals *)          ELSE            GET #path,intVal            IF verbose THEN              PRINT #2 USING "h4,s1",intVal," ";            ENDIF            modCnt:=modCnt+2                ENDIF        ENDIF      (* String Literals *)      ELSE        IF tokenVal=$90 THEN        quote:=tokenVal          REPEAT            GET #path,byteVal            IF verbose AND byteVal<>$FF THEN              PRINT #2 USING "h2",byteVal;              quote:=0            ENDIF            modCnt:=modCnt+1          UNTIL byteVal=$FF          IF verbose THEN            IF byteVal=$FF AND quote<>144 THEN              PRINT #2," ";            ENDIF            PRINT #2 USING "h2,s1",byteVal," ";          ENDIF        (* Line References *)        ELSE         (* =============== =============== *)         (* 20 GOTO         16 ENDWHILE     *)         (* 22 GOSUB        1A ENDLOOP      *)         (* 55 ivgt         1C ENDEXIT      *)         (* 11 ELSE         3B blrf         *)         (* =============== =============== *)          IF tokenVal=$20 OR tokenVal=$22 OR tokenVal=$55 OR tokenVal=$11 OR tokenVal=$16 OR tokenVal=$1A OR tokenVal=$1C OR tokenVal=$3B THEN            GET #path,intVal            IF verbose THEN              PRINT #2 USING "h4,s1",intVal," ";            ENDIF            modCnt:=modCnt+2                  lineRefs:=lineRefs+1            IF isRestore AND tokenVal=$3B THEN            ENDIF            IF isOn THEN              isOn:=FALSE            ENDIF            IF tokenVal=$20 OR tokenVal=$22 OR tokenVal=$3B THEN              GOSUB 220 \REM add line number reference            ENDIF          ELSE            IF tokenVal=$46 OR tokenVal=$47 THEN              GET #path,intVal              IF verbose THEN                PRINT #2 USING "h4,s1",intVal," ";              ENDIF              modCnt:=modCnt+2                    ENDIF          ENDIF        ENDIF      ENDIF    ENDIF    (* Get File Open/Create Mode *)    IF tokenVal=$4A AND creop THEN      GET #path,byteVal      IF verbose THEN        PRINT #2 USING "h2,s1",byteVal," ";      ENDIF      modCnt:=modCnt+1      creop:=FALSE    ENDIF  (* End of Instruction Statement *)  UNTIL tokenVal=$3E OR tokenVal=$3F  IF verbose THEN    PRINT #2  ELSE    PRINT #2, ".";  ENDIF  IF forVar THEN    forVar:=FALSE  ENDIF  IF NOT(namVar) THEN    namVar:=TRUE  ENDIF  IF tokenVal=$3E THEN    tInstr:=tInstr+1  ENDIF  IF tokenVal=$3F THEN    tInstr:=tInstr+1  ENDIF  IF isOn THEN    isOn:=FALSE  ENDIF  IF isRestore THEN    isRestore:=FALSE  ENDIF(* End of Instruction Code Section *)UNTIL modCnt=descOff-execOffIF NOT(verbose) THEN  PRINT #2," ";ENDIFPRINT #2, "Done"RETURN(* ============= *)(* Identify Duplicate and Add Variable Record *)(* Is it a field? *)210 IF tokenVal>=$F6 AND tokenVal<=$F9 OR tokenVal>=$89 AND tokenVal<=$8C THEN  isField:=TRUEELSE  isField:=FALSEENDIF(* Is it a potential record? *)(* At this stage whether a reference is a record or not *)(* is not determinable. That happens in defVars. *)IF tokenVal>=$85 AND tokenVal<=$8C OR tokenVal>=$F2 AND tokenVal<=$F9 THEN  potRec:=TRUEELSE  potRec:=FALSEENDIF(* Search Records *)recCount:=0 \found:=FALSEIF varCount>0 THEN  REPEAT    IF tokenVal=varRec(recCount).vTyp THEN      IF intVal=varRec(recCount).vOff THEN        found:=TRUE        SEEK #vPath,recCount*SIZE(varFRec)+2        GET #vPath,varFRec        SEEK #vPath,recCount*SIZE(varFRec)+2      ENDIF    ENDIF    EXITIF found THEN    ENDEXIT    recCount:=recCount+1  UNTIL found OR recCount=varCountENDIF(* Add Record *)IF NOT(found) THEN  varFRec:=defFRec  varRec(varCount).vTyp:=0 \varRec(varCount).nTyp:=0 \varRec(varCount).nVar:=FALSE  varRec(varCount).vOff:=0 \varRec(varCount).vdOff:=0 \varRec(varCount).dsOff:=0  varRec(varCount).dmOff:=0 \varRec(varCount).fOff:=0 \varRec(varCount).pOff:=0  SEEK #vPath,varCount*SIZE(varFRec)+2  varRec(varCount).vTyp:=tokenVal  varRec(varCount).vOff:=intVal  varRec(varCount).nVar:=namVar  varCount:=varCount+1  varFRec.vp2.vRecNum:=varCount  varFRec.vp2.vRefCnt:=1  varFRec.vp3.pRec:=FALSE  varFRec.vp3.vLnk:=0  IF tokenVal>=$80 AND tokenVal<=$83 OR tokenVal>=$00 AND tokenVal<=$03 OR tokenVal=$46 OR tokenVal=$47 THEN    varFRec.vp3.mTyp:=1 \REM atomic type: BYTE, INTEGER, REAL, BOOLEAN  ENDIF  IF tokenVal=$84 THEN    varFRec.vp3.mTyp:=2 \REM atomic type: STRING  ENDIF  IF tokenVal>$84 OR tokenVal=$23 THEN    varFRec.vp3.mTyp:=3 \REM all others point to the VDT  ENDIF  IF extRef THEN    varFRec.vp3.vLnk:=linkVal \REM external link reference - unused  ENDIFENDIF(* Connect Records with Fields *)IF isField THEN  varFRec.vp2.pVar:=tmpTyp  varFRec.vp3.pFld:=TRUEELSE  varFRec.vp2.pVar:=0  varFRec.vp3.pFld:=FALSEENDIFIF potRec THEN  varFRec.vp3.pRec:=TRUE  tmpTyp:=varFRec.vp2.vRecNumELSE  varFRec.vp3.pRec:=FALSEENDIFIF found THEN  varFRec.vp2.vRefCnt:=varFRec.vp2.vRefCnt+1ENDIFPUT #vPath,varFRecIF NOT(found) THEN  SEEK #vPath,0  PUT #vPath,varCountENDIFRETURN(* ============= *)(* Identify Duplicate and Add Line Record *)(* Search Records *)220 recCount:=0 \found:=FALSEIF NOT(isRestore) OR isRestore AND intVal<>dataStAdd THEN  IF linCount>0 THEN    REPEAT      IF tokenVal=linRefs(recCount).hLTyp THEN        IF intVal=linRefs(recCount).hLOff THEN          found:=TRUE          SEEK #lnPath,recCount*SIZE(linRec)+2          GET #lnPath,linRec          linRec.lnRefCnt:=linRec.lnRefCnt+1          SEEK #lnPath,recCount*SIZE(linRec)+2          PUT #lnPath,linRec        ENDIF      ENDIF      recCount:=recCount+1    UNTIL found OR recCount=linCount  ENDIF  (* Add Record *)  IF NOT(found) THEN    SEEK #lnPath,linCount*SIZE(linRec)+2    linRefs(linCount).hLTyp:=tokenVal    linRefs(linCount).hLOff:=intVal    linCount:=linCount+1    linRec.lnRecNum:=linCount    linRec.lnRefCnt:=1    linRec.lnTyp:=tokenVal    linRec.lnOff:=intVal    PUT #lnPath,linRec    SEEK #lnPath,0    PUT #lnPath,linCount  ENDIFENDIFRETURN(* ============= *)(* == Group 3 == *)(* Display line references? *)(* Sort Line References *)300 IF linCount>1 THEN  PRINT #2, "Sorting Line References ";  renum:=TRUE  SEEK #lnPath,0  RUN lSort (er,which,lnPath,0,linCount-1,linRefs)  IF er>0 THEN 500 \REM goto error trap  PRINT #2, " Done"ELSE  IF linCount=1 THEN    renum:=TRUE  ELSE    renum:=FALSE  ENDIFENDIFIF renum THEN  PRINT #2, "Numbering Line Referrences ";  IF verbose THEN    PRINT #2  ENDIF  SEEK #lnPath,2  recCount:=0 \lnCnt:=0  (* Line Number Assignment *)  lastOff:=0 \lastNum:=""  REPEAT    GET #lnPath,linRec    linRec.lnRecNum:=recCount+1    IF lnCnt>0 AND linRec.lnOff=lastOff THEN \REM same reference      linRec.lnNum:=lastNum \REM gets same number    ELSE \REM next number      linRec.lnNum:=STR$((lnCnt+1)*10)      lastOff:=linRec.lnOff      lastNum:=linRec.lnNum      lnCnt:=lnCnt+1    ENDIF    SEEK #lnPath,recCount*SIZE(linRec)+2    PUT #lnPath,linRec    IF verbose THEN      PRINT #2 USING "i3>,s1,i3>,s1,h2,s1,h4,s1,s5",linRec.lnRecNum," ",linRec.lnRefCnt," ",linRec.lnTyp," ",linRec.lnOff," ",linRec.lnNum    ELSE      PRINT ".";    ENDIF    recCount:=recCount+1  UNTIL recCount=linCount  IF NOT(verbose) THEN    PRINT #2," ";  ENDIF  PRINT #2, "Done"  PRINT #2, "Total Line References Found: "; linCountELSE  IF linCount=0 THEN    PRINT #2, "No Line References Found"  ENDIF  IF linCount=1 THEN    PRINT #2, linCount; " Line Reference Found"  ENDIFENDIFRETURN(* ============= *)(* == Group 4 == *)(* Get Data from initDB *)400OPEN #dPath,dFile:READdOpen:=TRUEGET #dPath,versionGET #dPath,varFRec \REM initialized variable file recordGET #dPath,DSMap \REM initialized DSAT Map arrayCLOSE #dPathdOpen:=FALSERETURN(* ============= *)(* == Group 5 == *)(* Error Trap *)500 IF er=0 THEN  er:=ERRENDIFIF er=56 OR er=216 THEN  IF er=216 THEN    er:=0    GOTO 20  ENDIF  er:=0  IF vOpen THEN    CLOSE #vPath    vOpen:=FALSE  ENDIF  IF lnOpen THEN    CLOSE #lnPath    lnOpen:=FALSE  ENDIF  IF dOpen THEN    CLOSE #dPath    dOpen:=FALSE  ENDIF  ENDELSE  IF vOpen THEN    CLOSE #vPath    vOpen:=FALSE  ENDIF  IF lnOpen THEN    CLOSE #lnPath    lnOpen:=FALSE  ENDIF  IF dOpen THEN    CLOSE #dPath    dOpen:=FALSE  ENDIF  ENDENDIFEND(* ============= *)PROCEDURE lSort(* based on quicksort, by T.F. Ritter(* Line Reference Record *)(* Array *)TYPE LNREF=hLTyp:BYTE; hLOff:INTEGERDIM linRef:LNREF(* Record *)TYPE LNREC=lnRecNum,lnRefCnt:INTEGER; lnTyp:BYTE; lnOff:INTEGER; lnNum:STRING[5]DIM linRec,linRecs(2):LNRECPARAM er,which:INTEGER; lnPath:BYTE; bottom,top:INTEGER; linRefs(300):LNREFDIM lower,upper:INTEGER; btemp:BOOLEANON ERROR GOTO 10which:=which+1PRINT #2,".";BASE 0lower:=bottomupper:=topLOOP \REM each element gets the once over  REPEAT \REM this is a postinc instruction    btemp:=linRefs(lower).hLOff<linRefs(top).hLOff    lower:=lower+1  UNTIL NOT(btemp)  lower:=lower-1 \REM point at the tested element  EXITIF lower=upper THEN  ENDEXIT  REPEAT \REM this is a postdec instruction    upper:=upper-1  UNTIL linRefs(upper).hLOff<=linRefs(top).hLOff OR upper=lower  EXITIF lower=upper THEN  ENDEXIT  SEEK #lnPath,lower*SIZE(linRec)+2  GET #lnPath,linRec  linRecs(0):=linRec  SEEK #lnPath,upper*SIZE(linRec)+2  GET #lnPath,linRec  linRecs(1):=linRec  linRef:=linRefs(lower)  linRefs(lower):=linRefs(upper)  linRefs(upper):=linRef  linRec:=linRecs(0)  linRecs(0):=linRecs(1)  linRecs(1):=linRec  SEEK #lnPath,lower*SIZE(linRec)+2  linRec:=linRecs(0)  PUT #lnPath,linRec  SEEK #lnPath,upper*SIZE(linRec)+2  linRec:=linRecs(1)  PUT #lnPath,linRec  lower:=lower+1 \REM prepare for postinc  EXITIF lower=upper THEN  ENDEXITENDLOOPIF lower<>top THEN  IF linRefs(lower).hLOff<>linRefs(top).hLOff THEN    SEEK #lnPath,lower*SIZE(linRec)+2    GET #lnPath,linRec    linRecs(0):=linRec    SEEK #lnPath,top*SIZE(linRec)+2    GET #lnPath,linRec    linRecs(1):=linRec    linRef:=linRefs(lower)    linRefs(lower):=linRefs(top)    linRefs(top):=linRef    linRec:=linRecs(0)    linRecs(0):=linRecs(1)    linRecs(1):=linRec    SEEK #lnPath,lower*SIZE(linRec)+2    linRec:=linRecs(0)    PUT #lnPath,linRec    SEEK #lnPath,top*SIZE(linRec)+2    linRec:=linRecs(1)    PUT #lnPath,linRec  ENDIFENDIFIF bottom<lower-1 THEN  RUN lSort(er,which,lnPath,bottom,lower-1,linRefs)ENDIFIF lower+1<top THEN  RUN lSort(er,which,lnPath,lower+1,top,linRefs)ENDIFEND10 er:=ERREND