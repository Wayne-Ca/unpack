PROCEDURE instruction
(* Version 1.2.10 *)
(* Declarations *)
(* Variable Record *)
(* Array *)
TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGER
DIM varRec(400):VREC
(* File Record *)
TYPE VFRC=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGER; vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGER; mTyp,vLnk:BYTE; pRec,pFld:BOOLEAN
DIM varFRec:VFRC
(* Line Reference Record *)
(* Record *)
TYPE LNREC=lnRecNum,lnRefCnt:INTEGER; lnTyp:BYTE; lnOff:INTEGER; lnNum:STRING[5]
DIM linRec:LNREC
(* Booleans *)
DIM found,nextVar,forVar,creop,displays,hasRecords,hasLines,isRestore:BOOLEAN
(* Various counters *)
DIM tokenCode,tokenVal,byteVal:BYTE
(* Various variables *)
DIM filCnt,modCnt,intVal:INTEGER
DIM month,day,year,hour,minute,second,number:INTEGER
DIM sHour,sMinute,sSecond,tHour,tMinute,tSecond:INTEGER
DIM col,row:INTEGER
DIM varCount,varCnt:INTEGER
DIM linCount,lrCnt,lnCnt,lastOff:INTEGER
(* Error and Module Data *)
DIM er,which,modSiz,dataSiz,execOff,dsatOff,vdtOff,tpVars,dataStAdd:INTEGER
(* Program Options *)
DIM options(26),defFcol,defBcol:BYTE
(* File Paths *)
DIM path,vPath,lnPath,dPath,oPath:BYTE
(* File Status *)
DIM pOpen,vOpen,lnOpen,dOpen,oOpen,wOpen:BOOLEAN
(* File names *)
DIM version:STRING[8]; vFile,lnFile,dFile,oFile:STRING[29]
DIM proc:STRING[80]; chainMod:STRING[177]
(* Strings *)
DIM key:STRING[1]; hex:STRING[4]; lastNum:STRING[5]; tokenName:STRING[29]
DIM monthName:STRING[9]; dateTime:STRING[17]; cPrompt:STRING[25]
DIM source:STRING[512]
(* I-Code File Pathname *)
PARAM file:STRING[80]; modName,dataDir:STRING[29]

BASE 0
dOpen:=FALSE
dFile:=dataDir+"initDB"
OPEN #dPath,dFile:READ
dOpen:=TRUE
GET #dPath,version
GET #dPath,options
(* Default Display Colors *)
GET #dPath,defFcol \ GET #dPath,defBcol
CLOSE #dPath
dOpen:=FALSE
pOpen:=FALSE \vOpen:=FALSE \lnOpen:=FALSE \dOpen:=FALSE \oOpen:=FALSE
ON ERROR GOTO 530
proc:=file
vFile:=dataDir+"varDefs"
lnFile:=dataDir+"linDefs"
dFile:=dataDir+"procData"
oFile:=modName+".B09"
cPrompt:="Press [ENTER] To Continue"
(* Open Procedure File *)
OPEN #path,proc:READ
pOpen:=TRUE
OPEN #dPath,dFile:READ
dOpen:=TRUE
GET #dPath,displays \ GET #dPath,hasRecords
GET #dPath,sHour \ GET #dPath,sMinute \ GET #dPath,sSecond
GET #dPath,modSiz \ GET #dPath,dataSiz \ GET #dPath,execOff
GET #dPath,dsatOff \ GET #dPath,vdtOff \ GET #dPath,tpVars
GET #dPath,dataStAdd
(* Variables lookup table *)
GET #dPath,varRec
CLOSE #dPath
dOpen:=FALSE
(* Variable Reference *)
OPEN #vPath,vFile:UPDATE
vOpen:=TRUE
GET #vPath,varCount
(* Line Reference *)
OPEN #lnPath,lnFile:UPDATE
lnOpen:=TRUE
GET #lnPath,linCount
hasLines:=FALSE
IF linCount>0 THEN
  GET #lnPath,linRec
  lastOff:=linRec.lnOff
  lastNum:=linRec.lnNum
  hasLines:=TRUE
ENDIF
(* Output File *)
(* IF options(26)=1 THEN
  OPEN #oPath,oFile:UPDATE
  (* CREATE #oPath,oFile:UPDATE
  oOpen:=TRUE
  REPEAT
    READ #oPath,source
  UNTIL EOF(#oPath)
(* ENDIF
wOpen:=FALSE
IF displays and options(20)=1 THEN
  wOpen:=TRUE
ENDIF
(* Instruction code section, second pass *)
(* Output instructions *)
IF wOpen THEN
  PRINT "(* Source Instructions *)"
ENDIF
IF oOpen THEN
  PRINT #oPath,"(* Source Instructions *)"
ENDIF
SEEK #path,execOff
filCnt:=execOff \modCnt:=0 \lnCnt:=0 \forVar:=FALSE \nextVar:=FALSE
REPEAT
  source:=""
  (* Insert Line Number Here *)
  IF hasLines THEN
    IF modCnt=lastOff THEN
      (* PRINT lastNum; " ";
      source:=lastNum+" "
      IF linCount>1 THEN
        REPEAT
          lnCnt:=lnCnt+1
          SEEK #lnPath,lnCnt*SIZE(linRec)+2
          GET #lnPath,linRec
        UNTIL linRec.lnOff>lastOff OR lnCnt=linCount
        lastOff:=linRec.lnOff
        lastNum:=linRec.lnNum
      ENDIF
    ENDIF
  ENDIF
  REPEAT
    GET #path,tokenVal
    modCnt:=modCnt+1
    filCnt:=filCnt+1
    GOSUB 270
    IF tokenName<>"" THEN
      source:=source+tokenName
      (* PRINT tokenName;
      (* OPEN or CREATE statement for file mode *)
      IF tokenVal=$29 OR tokenVal=$2A THEN
        creop:=TRUE
      ENDIF
      (* RESTORE References *)
      IF tokenVal=$31 THEN
        isRestore:=TRUE
      ENDIF
      IF tokenVal=$13 OR tokenVal=$14 THEN
        IF tokenVal=$13 THEN
          forVar:=TRUE
        ELSE
          nextVar:=TRUE
        ENDIF
        GET #path,tokenVal
        modCnt:=modCnt+1
        filCnt:=filCnt+1
      ENDIF
      IF tokenVal=$46 OR tokenVal=$47 THEN
        GET #path,intVal
        modCnt:=modCnt+2
        filCnt:=filCnt+2
      ENDIF
    ENDIF
    (* Variable References *)
    IF tokenVal=$55 OR tokenVal=$11 OR tokenVal=$16 OR tokenVal=$1A OR tokenVal=$1C THEN
      GET #path,intVal
      modCnt:=modCnt+2
      filCnt:=filCnt+2
    ENDIF
    IF nextVar THEN
      FOR nextRef:=1 TO 4
        GET #path,intVal
        modCnt:=modCnt+2
        filCnt:=filCnt+2
        IF nextRef=1 THEN
          GOSUB 210
          source:=source+tokenName
          (* PRINT tokenName;
        ENDIF
      NEXT nextRef
      nextVar:=FALSE
    ENDIF
    IF tokenVal=$23 OR tokenVal>=$80 AND tokenVal<=$8C OR tokenVal>=$F2 AND tokenVal<=$F9 THEN
      GET #path,intVal
      modCnt:=modCnt+2
      filCnt:=filCnt+2
      GOSUB 210
      tokenName:="®"+tokenName
      source:=source+tokenName
      (* PRINT tokenName;
    ELSE
      (* Literals *)
      IF tokenVal>=$8D AND tokenVal<=$91 AND tokenVal<>$90 THEN
        (* BYTE Literals *)
        IF tokenVal=$8D THEN
          GET #path,byteVal
          modCnt:=modCnt+1
          filCnt:=filCnt+1
          source:=source+"®"+STR$(byteVal)
          (* PRINT "®"; byteVal;
        ELSE
          (* REAL Literals *)
          IF tokenVal=$8F THEN
            GET #path,realVal
            modCnt:=modCnt+5
            filCnt:=filCnt+5
            source:=source+"®"+STR$(realVal)
            (* PRINT "®"; realVal;
          ELSE
            (* INTEGER and HEX Literals *)
            GET #path,intVal
            modCnt:=modCnt+2
            filCnt:=filCnt+2
            IF tokenVal=$91 THEN
              RUN hex$(intVal,hex)
              source:=source+hex
              (* PRINT hex;
            ELSE
              source:=source+"®"+STR$(intVal)
              (* PRINT "®"; intVal;
            ENDIF
          ENDIF
        ENDIF
      ELSE
        (* String Literals *)
        IF tokenVal=$90 THEN
          REPEAT
            GET #path,byteVal
            modCnt:=modCnt+1
            filCnt:=filCnt+1
            IF byteVal=$FF THEN
              tokenVal:=byteVal
              GOSUB 270
              source:=source+tokenName
              (* PRINT tokenName;
            ELSE
              IF byteVal>=$20 THEN
                IF byteVal=$AE THEN
                  source:=source+"¾" \!$BE
                ELSE
                  source:=source+CHR$(byteVal)
                ENDIF
                (* PRINT CHR$(byteVal);
              ENDIF
            ENDIF
          UNTIL byteVal=$FF
        ELSE
          (* Line References *)
          IF tokenVal=$20 OR tokenVal=$22 OR tokenVal=$3B THEN
            GET #path,intVal
            modCnt:=modCnt+2
            filCnt:=filCnt+2
            IF isRestore AND tokenVal=$3B THEN
              IF intVal<>dataStAdd THEN
                GOSUB 230
                source:=source+linRec.lnNum
                (* PRINT linRec.lnNum;
              ENDIF
            ELSE
              GOSUB 230
              source:=source+linRec.lnNum
              (* PRINT linRec.lnNum;
            ENDIF
          ENDIF
        ENDIF
      ENDIF
    ENDIF
    (* Get File Open/Create Mode *)
    IF tokenVal=$4A AND creop THEN
      GET #path,byteVal
      modCnt:=modCnt+1
      filCnt:=filCnt+1
      RESTORE 280
      REPEAT
        READ tokenCode,tokenName
      UNTIL tokenCode=byteVal OR tokenCode=0
      source:=source+tokenName
      (* PRINT tokenName;
      creop:=FALSE
    ENDIF
  (* End of Instruction Statement *)
  UNTIL tokenVal=$3E OR tokenVal=$3F

  IF forVar THEN
    forVar:=FALSE
  ENDIF
  IF isRestore THEN
    isRestore:=FALSE
  ENDIF
  RUN DRPN(source)
  IF wOpen THEN
    PRINT source
  ENDIF
  IF oOpen THEN
    PRINT #oPath,source
  ENDIF
(* End of Instruction Code Section *)
UNTIL modCnt=dsatOff-execOff
IF wOpen THEN
  wOpen:=FALSE
  PRINT #2  \ PRINT #2, cPrompt;
  GOSUB 140 \ GOSUB 130 \ GOSUB 130 \ GOSUB 130
ENDIF
(* Close Files *)
CLOSE #path
pOpen:=FALSE
CLOSE #vPath
vOpen:=FALSE
CLOSE #lnPath
lnOpen:=FALSE
IF oOpen THEN
  CLOSE #oPath
  oOpen:=FALSE
ENDIF
(* Display Completion Time *)
PRINT #2, "Done!";
col:=0 \row:=19 \ GOSUB 110
GOSUB 150
PRINT "Total Time: ";
IF hour<sHour THEN tHour:=hour+12-sHour
ELSE tHour:=hour-sHour \ ENDIF
IF minute<sMinute THEN tMinute:=minute+60-sMinute
ELSE tMinute:=minute-sMinute \ ENDIF
IF second<sSecond THEN tSecond:=second+60-sSecond
ELSE tSecond:=second-sSecond \ ENDIF
IF second<sSecond AND tSecond<60 THEN tMinute:=tMinute-1 \ ENDIF
IF minute<sMinute AND tMinute<60 THEN tHour:=tHour-1 \ ENDIF
IF tHour<10 THEN PRINT "0"; tHour; ":";
ELSE PRINT tHour; ":";  \ ENDIF
IF tMinute<10 THEN PRINT "0"; tMinute; ":";
ELSE PRINT tMinute; ":";  \ ENDIF
IF tSecond<10 THEN PRINT "0"; tSecond
ELSE PRINT tSecond \ ENDIF
(* End of Program *)
GOSUB 117
GOSUB 135
END
(* ============= *)
(* Subroutines *)

(* == Group 1 == *)
(* Display and Input *)
110 RUN GFX2("CURXY",col,row) \ RETURN
115 RUN GFX2("EREOLINE") \ RETURN
116 RUN GFX2("CUROFF") \ RETURN
117 RUN GFX2("CURON") \ RETURN
130 RUN GFX2("OWEND") \ RETURN
135 RUN GFX2("COLOR",defFcol,defBcol) \ RETURN
(* ============= *)
(* Get Keypress *)
140 key:=""
REPEAT
  RUN Inkey(key)
  IF key>="A" AND key<="Z" THEN
    key:=CHR$(ASC(key)+$20)
  ENDIF
UNTIL key="y" OR key="n" OR key=CHR$(13)
GOSUB 116
col:=0 \row:=23 \ GOSUB 110 \ GOSUB 115
RETURN
(* ============= *)
(* Date Stamp *)
150 dateTime:=DATE$
month:=VAL(MID$(dateTime,4,2))
day:=VAL(MID$(dateTime,7,2))
year:=2000+VAL(LEFT$(dateTime,2))
hour:=VAL(MID$(dateTime,10,2))
minute:=VAL(MID$(dateTime,13,2))
second:=VAL(MID$(dateTime,16,2))
RESTORE 155
REPEAT
  READ number,monthName
UNTIL number=month
RETURN
(* ============= *)
(* Month Names *)
155 DATA 1,"January",2,"February",3,"March"
DATA 4,"April",5,"May",6,"June"
DATA 7,"July",8,"August",9,"September"
DATA 10,"October",11,"November",12,"December"
(* ============= *)

(* == Group 2 == *)
210 varCnt:=0 \found:=FALSE
REPEAT
  IF varRec(varCnt).vTyp=tokenVal AND varRec(varCnt).vOff=intVal THEN
    SEEK #vPath,varCnt*SIZE(varFRec)+2
    GET #vPath,varFRec
    found:=TRUE
    tokenName:=varFRec.vName
    IF SUBSTR(LEFT$(tokenName,1),"birlsc")>0 AND varRec(varCnt).nTyp<3 THEN
      tokenName:="."+tokenName
    ENDIF
  ENDIF
  varCnt:=varCnt+1
UNTIL found OR varCnt=varCount
RETURN
(* ============= *)
220 RETURN
(* ============= *)
230 lrCnt:=0
REPEAT
  SEEK #lnPath,lrCnt*SIZE(linRec)+2
  GET #lnPath,linRec
  lrCnt:=lrCnt+1
UNTIL linRec.lnOff=intVal OR lrCnt=linCount
RETURN
(* ============= *)
(* Read Keyword Tokens *)
270 RESTORE 275
REPEAT
  READ tokenCode,tokenName
UNTIL tokenCode=tokenVal OR tokenCode=0
RETURN
(* ============= *)
(* Keyword/Token Data *)
275 DATA $04,"DATA ",$05,"STOP",$06,"BYE",$07,"TRON",$08,"TROFF",$09,"PAUSE"
DATA $0A,"DEG",$0B,"RAD",$0C,"RETURN",$0D,"LET ",$0F,"POKE ",$10,"IF "
DATA $11,"ELSE ",$12,"ENDIF",$13,"FOR ",$14,"NEXT ",$15,"WHILE ",$16,"ENDWHILE"
DATA $17,"REPEAT",$18,"UNTIL ",$19,"LOOP",$1A,"ENDLOOP",$1B,"EXITIF "
DATA $1C,"ENDEXIT",$1D,"ON ",$1E,"ERROR",$20,"® GOTO ",$22,"® GOSUB ",$23,"RUN "
DATA $24,"KILL ",$25,"INPUT ",$26,"PRINT ",$27,"CHD ",$28,"CHX ",$29,"CREATE "
DATA $2A,"OPEN ",$2B,"SEEK ",$2C,"READ ",$2D,"WRITE ",$2E,"GET ",$2F,"PUT "
DATA $30,"CLOSE ",$31,"RESTORE ",$32,"DELETE ",$33,"CHAIN ",$34,"SHELL "
DATA $35,"BASE 0",$36,"BASE 1",$39,"END",$3E,"® \",$45,"® THEN ",$46,"® TO "
DATA $47,"® STEP ",$48,"® DO",$49,"® USING ",$4A,"®:",$4B,"®,",$4D,"®(",$4E,"®)"
DATA $51,"®; ",$52,"®:=",$53,"®.=",$54,"®#",$90,"®""",$91,"®$",$92,"®ADDR()"
DATA $94,"®SIZE()",$96,"®POS",$97,"®ERR",$98,"®MOD(,)",$99,"®MOD(,)"
DATA $9A,"®RND()",$9B,"®PI",$9C,"®SUBSTR(,)",$9D,"®SGN()",$9E,"®SGN()"
DATA $9F,"®SIN()",$A0,"®COS()",$A1,"®TAN()",$A2,"®ASN()",$A3,"®ACS()"
DATA $A4,"®ATN()",$A5,"®EXP()",$A6,"®ABS()",$A7,"®ABS()",$A8,"®LOG()"
DATA $A9,"®LOG10()",$AA,"®SQRT()",$AC,"®INT()",$AD,"®INT()",$AE,"®FIX()"
DATA $AF,"®FIX()",$B0,"®FLOAT()",$B1,"®FLOAT()",$B2,"®SQ()",$B3,"®SQ()"
DATA $B4,"®PEEK()",$B5,"®LNOT()",$B6,"®VAL()",$B7,"®LEN()",$B8,"®ASC()"
DATA $B9,"®LAND(,)",$BA,"®LOR(,)",$BB,"®LXOR(,)",$BC,"®TRUE",$BD,"®FALSE"
DATA $BE,"®EOF()",$BF,"®TRIM$()",$C0,"®MID$(,,)",$C1,"®LEFT$(,)"
DATA $C2,"®RIGHT$(,)",$C3,"®CHR$()",$C4,"®STR$()",$C5,"®STR$()",$C6,"®DATE$"
DATA $C7,"®TAB()",$CD,"®NOT()",$CE,"® - ",$CF,"® - ",$D0,"® AND ",$D1,"® OR ",$D2,"® XOR "
DATA $D3,"®>",$D4,"®>",$D5,"®>",$D6,"®<",$D7,"®<",$D8,"®<",$D9,"®<>",$DA,"®<>",$DB,"®<>"
DATA $DC,"®<>",$DD,"®=",$DE,"®=",$DF,"®=",$E0,"®=",$E1,"®>=",$E2,"®>=",$E3,"®>=",$E4,"®<="
DATA $E5,"®<=",$E6,"®<=",$E7,"®+",$E8,"®+",$E9,"®+",$EA,"®-",$EB,"®-",$EC,"®*"
DATA $ED,"®*",$EE,"®/",$EF,"®/",$F0,"®^",$F1,"®**",$FF,"""",$00,""
(* ============= *)
(* File Mode Keywords *)
280 DATA $01,"READ",$02,"WRITE",$03,"UPDATE",$05,"READ+EXEC"
DATA $06,"WRITE+EXEC",$07,"UPDATE+EXEC",$80,"DIR",$81,"READ+DIR"
DATA $82,"WRITE+DIR",$83,"UPDATE+DIR",$84,"EXEC+DIR"
DATA $85,"READ+EXEC+DIR",$86,"WRITE+EXEC+DIR",$87,"UPDATE+EXEC+DIR"
DATA $00,""

(* == Group 3 == *)
(* No Group 3 Routines *)
(* ============= *)

(* == Group 4 == *)
(* No Group 4 Routines *)
(* ============= *)

(* == Group 5 == *)
(* Error Trap *)
530 IF er=0 THEN
  er:=ERR
ENDIF
IF pOpen THEN
  CLOSE #path
  pOpen:=FALSE
ENDIF
IF vOpen THEN
  CLOSE #vPath
  vOpen:=FALSE
ENDIF
IF lnOpen THEN
  CLOSE #lnPath
  lnOpen:=FALSE
ENDIF
IF dOpen THEN
  CLOSE #dPath
  dOpen:=FALSE
ENDIF
PRINT #2, er
END
PROCEDURE hex$
(* value = integer value *)
(* hex   = hex string *)
PARAM value:INTEGER; hex:STRING[4]
(* index      = counter *)
(* hex_index  = counter for DATA read *)
(* bit        = mask integer *)
(* bit_result = result of LAND *)
(* hex_result = result of nybble *)
DIM index,hex_index,bit,bit_result,hex_result:INTEGER
(* hex_bit = hex value string character *)
DIM hex_bit:STRING[1]

ON ERROR GOTO 1
hex:=""
bit:=1
hex_result:=0

hex_result =LAND(15,value)
GOSUB 2
hex_result := LAND($F0,value)/16
GOSUB 2
hex_result := LAND($F00,value)/256
GOSUB 2
hex_result = LAND($7000,value)/$1000
IF value<0 THEN
  hex_result:=hex_result+8
ENDIF
GOSUB 2
(* If the first two characters are 0's, remove them *)
IF LEFT$(hex,2)="00" THEN
  hex:=RIGHT$(hex,2)
ENDIF
1 END

(* Read hex value character *)
2 hex_result:=hex_result+48
IF hex_result>57 THEN
  hex_result:=hex_result+7
ENDIF
hex_bit:=CHR$(hex_result)
hex:=hex_bit+hex
hex_result:=0
RETURN
PROCEDURE DRPN
(* templine = work array for line parsing *)
DIM templine(10):STRING[400]
(* ********** *)
(* Parameters *)
(* outpath = output path *)
(* er      = error number variable *)
(* verbose = BOOLEAN for duped output to stdout *)
(* nofile  = BOOLEAN for no output file *)
(* inline  = line to be parsed *)
(* PARAM outpath:BYTE; er:INTEGER; verbose,nofile:BOOLEAN; inline:STRING[512]
PARAM inline:STRING[512]
(* place  = pointer to current character in inline *)
(* length = length of inline *)
(* count  = counter variable *)
(* cntr   = counter variable *)
(* cnt    = counter variable *)
DIM place,place1,length,count,cntr,cnt:INTEGER
(* parse = BOOLEAN for determining need of parsing *)
DIM parse,debug:BOOLEAN
(* char = current character of inline *)
(* key  = keypress from Inkey *)
DIM char,key:STRING[1]
(* outline = output line *)
DIM outline:STRING[512]
(* **************** *)
(* Start of Program *)
(* Error Trap *)
ON ERROR GOTO 9
(* Preliminary Initialization *)
debug:=FALSE
count:=0
REPEAT
  count:=count+1
  templine(count):=""
UNTIL count=10
outline:=""
(* Set line length *)
length:=LEN(inline)
(* Set parsing to none *)
(* IF SUBSTR("PEEK",inline)>0 THEN
  (* debug:=TRUE
  (* TRON
  (* PAUSE
(* ENDIF
parse:=FALSE
(* If no delimiters, just print the line *)
IF SUBSTR("®",inline)=0 THEN
  GOSUB 8
  END
ELSE
  (* Check for operators *)
  IF SUBSTR("®-",inline)>0 OR SUBSTR("+",inline)>0 OR SUBSTR("*",inline)>0 OR SUBSTR("/",inline)>0 THEN
    GOSUB 2
  ENDIF
  IF SUBSTR("()",inline)>0 OR SUBSTR("(,)",inline)>0 OR SUBSTR("(,,)",inline)>0 OR SUBSTR(" - ",inline)>0 THEN
    GOSUB 2
  ENDIF
  IF SUBSTR("**",inline)>0 OR SUBSTR("^",inline)>0 OR SUBSTR("® AND ",inline)>0 OR SUBSTR("® OR ",inline)>0 OR SUBSTR("® XOR ",inline)>0 THEN
    GOSUB 2
  ENDIF
  IF SUBSTR("<",inline)>0 OR SUBSTR(">",inline)>0 OR SUBSTR("<=",inline)>0 THEN
    GOSUB 2
  ENDIF
  IF SUBSTR(">=",inline)>0 OR SUBSTR("®=",inline)>0 OR SUBSTR("<>",inline)>0 THEN
    GOSUB 2
  ENDIF
  (* If no operators, strip the delimiters and print *)
  IF NOT(parse) THEN
    GOSUB 1
  ENDIF
ENDIF
IF debug THEN
  PRINT " "; inline
  PRINT "Paused";
  GOSUB 10
  PRINT
ENDIF
END
(* Strip delimiters *)
1 place:=1
REPEAT
  char:=MID$(inline,place,1)
  IF char<>"®" THEN
    outline:=outline+char
  ENDIF
  place:=place+1
UNTIL place=LEN(inline)+1
inline:=outline
outline:=""
GOSUB 8
(* For self-de-compile *)
REPEAT
  IF SUBSTR("¾",inline)>0 THEN
    place:=SUBSTR("¾",inline)
    inline:=LEFT$(inline,place-1)+"®"+RIGHT$(inline,LEN(inline)-(place-1))
  ENDIF
UNTIL SUBSTR("¾",inline)=0
RETURN
(* Parse line *)
2 parse:=TRUE
count:=1
IF debug THEN
  PRINT " "; inline
ENDIF
(* Fill templine array *)
3 REPEAT
  place:=SUBSTR("®",inline)
  IF place=1 THEN
    inline:=RIGHT$(inline,length-1)
    length:=length-1
  ELSE
    IF place>0 THEN
      templine(count):=LEFT$(inline,place-1)
      inline:=RIGHT$(inline,length-place)
      length:=length-place
    ELSE
      templine(count):=inline
      inline:=""
      length:=0
    ENDIF
    count:=count+1
    IF debug THEN
      PRINT " templine(";count-1; ") "; templine(count-1)
    ENDIF
  ENDIF
UNTIL count=11 OR length=0
(* Parse according to operator *)
cntr:=1
WHILE cntr<=count-1 DO
  (* Math Operators *)
  IF templine(cntr)="+" OR templine(cntr)="-" OR templine(cntr)="*" OR templine(cntr)="/" THEN
    templine(cntr-2):="("+templine(cntr-2)+templine(cntr)+templine(cntr-1)+")"
    IF debug THEN
      PRINT " templine("; cntr-2; ") "; templine(cntr-2)
    ENDIF
    templine(cntr-1):=""
    templine(cntr):=""
    GOSUB 7
    GOSUB 7
    count:=count-2
    cntr:=cntr-2
  ENDIF
  (* Powers Operators *)
  IF templine(cntr)="**" OR templine(cntr)="^" THEN
    templine(cntr-2):="("+templine(cntr-2)+templine(cntr)+templine(cntr-1)+")"
    IF debug THEN
      PRINT " templine("; cntr-2; ") "; templine(cntr-2)
    ENDIF
    templine(cntr-1):=""
    templine(cntr):=""
    GOSUB 7
    GOSUB 7
    count:=count-2
    cntr:=cntr-2
  ENDIF
  (* Equality Operators *)
  IF templine(cntr)=">" OR templine(cntr)="<" OR templine(cntr)="=" THEN
    templine(cntr-2):="("+templine(cntr-2)+templine(cntr)+templine(cntr-1)+")"
    IF debug THEN
      PRINT " templine("; cntr-2; ") "; templine(cntr-2)
    ENDIF
    templine(cntr-1):=""
    templine(cntr):=""
    GOSUB 7
    GOSUB 7
    count:=count-2
    cntr:=cntr-2
  ENDIF
  (* Equality Operators *)
  IF templine(cntr)=">=" OR templine(cntr)="<=" OR templine(cntr)="<>" THEN
    templine(cntr-2):="("+templine(cntr-2)+templine(cntr)+templine(cntr-1)+")"
    IF debug THEN
      PRINT " templine("; cntr-2; ") "; templine(cntr-2)
    ENDIF
    templine(cntr-1):=""
    templine(cntr):=""
    GOSUB 7
    GOSUB 7
    count:=count-2
    cntr:=cntr-2
  ENDIF
  (* Negation Operator *)
  IF templine(cntr)=" - " THEN
    templine(cntr-1):="-("+templine(cntr-1)+")"
    IF debug THEN
      PRINT " templine("; cntr-1; ") "; templine(cntr-1)
    ENDIF
    templine(cntr):=""
    GOSUB 7
    count:=count-1
    cntr:=cntr-1
  ENDIF
  (* Logic Operators *)
  IF templine(cntr)=" OR " OR templine(cntr)=" AND " OR templine(cntr)=" XOR " THEN
    templine(cntr-2):="("+templine(cntr-2)+templine(cntr)+templine(cntr-1)+")"
    IF debug THEN
      PRINT " templine("; cntr-2; ") "; templine(cntr-2)
    ENDIF
    templine(cntr-1):=""
    templine(cntr):=""
    GOSUB 7
    GOSUB 7
    count:=count-2
    cntr:=cntr-2
  ENDIF
  (* If complex "sub-variable", and previous complex, add together *)
  IF cntr>1 THEN
    IF LEFT$(templine(cntr-1),1)="C" OR LEFT$(templine(cntr-1),2)="PC" OR LEFT$(templine(cntr-1),2)=".c" THEN
      IF LEN(templine(cntr))>1 AND SUBSTR(MID$(templine(cntr),2,1),"birlsc")>0 THEN
        templine(cntr-1):=templine(cntr-1)+templine(cntr)
        IF debug THEN
          PRINT " templine("; cntr-1; ") "; templine(cntr-1)
        ENDIF
        templine(cntr):=""
        GOSUB 7
        count:=count-1
        cntr:=cntr-1
      ENDIF
    ENDIF
  ENDIF
  (* Single Dimensional Arrays *)
  IF RIGHT$(templine(cntr),2)="()" THEN
    (* If 'whole' array, just strip parens *)
    IF cntr=10 THEN
      IF templine(cntr-1)="," OR templine(cntr-1)="(" OR templine(cntr-1)=":=" OR templine(cntr-1)=".=" OR RIGHT$(templine(cntr-1),3)="ON " THEN
        templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-2)
        IF debug THEN
          PRINT " templine("; cntr; ") "; templine(cntr)
        ENDIF
      ELSE
        GOTO 4
      ENDIF
    ELSE
      IF cntr>1 THEN
        IF templine(cntr-1)="," OR templine(cntr-1)="(" OR templine(cntr-1)=":=" OR templine(cntr-1)=".=" OR RIGHT$(templine(cntr-1),3)="ON " OR templine(cntr-1)="SIZE()" THEN
          templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-2)
          IF debug THEN
            PRINT " templine("; cntr; ") "; templine(cntr)
          ENDIF
        ELSE
          GOTO 4
        ENDIF
      ELSE
        IF cntr=1 THEN
          templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-2)
          IF debug THEN
            PRINT " templine("; cntr; ") "; templine(cntr)
          ENDIF
        ELSE
          (* If EOF then add # *)
4         IF LEFT$(templine(cntr),3)="EOF" THEN
            templine(cntr-1):=LEFT$(templine(cntr),SUBSTR("(",templine(cntr)))+"#"+templine(cntr-1)+")"
          ELSE
            templine(cntr-1):=LEFT$(templine(cntr),SUBSTR("(",templine(cntr)))+templine(cntr-1)+")"
          ENDIF
          IF debug THEN
            PRINT " templine("; cntr-1; ") "; templine(cntr-1)
          ENDIF
          templine(cntr):=""
          GOSUB 7
          count:=count-1
          cntr:=cntr-1
          IF LEFT$(templine(cntr),1)="." THEN
            templine(cntr-1):=templine(cntr-1)+templine(cntr)
            IF debug THEN
              PRINT " templine("; cntr-1; ") "; templine(cntr-1)
            ENDIF
            templine(cntr):=""
            GOSUB 7
            count:=count-1
            cntr:=cntr-1
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  (* Two-Dimensional Arrays *)
  IF RIGHT$(templine(cntr),3)="(,)" THEN
    (* If 'whole' array, just strip parens *)
    IF cntr=10 THEN
      IF templine(cntr-1)="," OR templine(cntr-1)="(" OR templine(cntr-1)=":=" OR templine(cntr-1)=".=" OR RIGHT$(templine(cntr-1),3)="ON " THEN
        templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-3)
        IF debug THEN
          PRINT " templine("; cntr; ") "; templine(cntr)
        ENDIF
      ELSE
        GOTO 5
      ENDIF
    ELSE
      IF cntr>1 THEN
        IF templine(cntr-1)="," OR templine(cntr-1)="(" OR templine(cntr-1)=":=" OR templine(cntr-1)=".=" OR RIGHT$(templine(cntr-1),3)="ON " OR templine(cntr-1)="SIZE()" THEN
          templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-3)
          IF debug THEN
            PRINT " templine("; cntr; ") "; templine(cntr)
          ENDIF
        ELSE
          GOTO 5
        ENDIF
      ELSE
        IF cntr=1 THEN
          templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-3)
          IF debug THEN
            PRINT " templine("; cntr; ") "; templine(cntr)
          ENDIF
        ELSE
5         templine(cntr-2):=LEFT$(templine(cntr),SUBSTR("(",templine(cntr)))+templine(cntr-2)+","+templine(cntr-1)+")"
          IF debug THEN
            PRINT " templine("; cntr-2; ") "; templine(cntr-2)
          ENDIF
          templine(cntr-1):=""
          templine(cntr):=""
          GOSUB 7
          GOSUB 7
          count:=count-2
          cntr:=cntr-2
          IF LEFT$(templine(cntr),1)="." THEN
            templine(cntr-1):=templine(cntr-1)+templine(cntr)
            IF debug THEN
              PRINT " templine("; cntr-1; ") "; templine(cntr-1)
            ENDIF
            templine(cntr):=""
            GOSUB 7
            count:=count-1
            cntr:=cntr-1
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  (* Three-Dimensional Arrays *)
  IF RIGHT$(templine(cntr),4)="(,,)" THEN
    (* If 'whole' array, just strip parens *)
    IF cntr=10 THEN
      IF templine(cntr-1)="," OR templine(cntr-1)="(" OR templine(cntr-1)=":=" OR templine(cntr-1)=".=" OR RIGHT$(templine(cntr-1),3)="ON " THEN
        templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-4)
        IF debug THEN
          PRINT " templine("; cntr; ") "; templine(cntr)
        ENDIF
      ELSE
        GOTO 6
      ENDIF
    ELSE
      IF cntr>1 THEN
        IF templine(cntr-1)="," OR templine(cntr-1)="(" OR templine(cntr-1)=":=" OR templine(cntr-1)=".=" OR RIGHT$(templine(cntr-1),3)="ON " OR templine(cntr-1)="SIZE()" THEN
          templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-4)
          IF debug THEN
            PRINT " templine("; cntr; ") "; templine(cntr)
          ENDIF
        ELSE
          GOTO 6
        ENDIF
      ELSE
        IF cntr=1 THEN
          templine(cntr):=LEFT$(templine(cntr),LEN(templine(cntr))-4)
          IF debug THEN
            PRINT " templine("; cntr; ") "; templine(cntr)
          ENDIF
        ELSE
6         templine(cntr-3):=LEFT$(templine(cntr),SUBSTR("(",templine(cntr)))+templine(cntr-3)+","+templine(cntr-2)+","+templine(cntr-1)+")"
          IF debug THEN
            PRINT " templine("; cntr-3; ") "; templine(cntr-3)
          ENDIF
          templine(cntr-2):=""
          templine(cntr-1):=""
          templine(cntr):=""
          GOSUB 7
          GOSUB 7
          GOSUB 7
          count:=count-3
          cntr:=cntr-3
          IF LEFT$(templine(cntr),1)="." THEN
            templine(cntr-1):=templine(cntr-1)+templine(cntr)
            IF debug THEN
              PRINT " templine("; cntr-1; ") "; templine(cntr-1)
            ENDIF
            templine(cntr):=""
            GOSUB 7
            count:=count-1
            cntr:=cntr-1
          ENDIF
        ENDIF
      ENDIF
    ENDIF
  ENDIF
  cntr:=cntr+1
ENDWHILE
(* If end of line, add templine array to outline and print *)
IF length=0 THEN
  cntr:=0
  REPEAT
    cntr:=cntr+1
    outline:=outline+templine(cntr)
    templine(cntr):=""
  UNTIL cntr=10
  IF LEN(outline)>256 THEN
    PRINT
    PRINT "(* WARNING! Basic09 has problems with lines greater than 256 characters long!"
    PRINT
  ENDIF
  inline:=outline
  outline:=""
  GOSUB 8
ELSE
  (* If not end of line, and templines empty, go get more *)
  IF count<10 THEN
    IF debug THEN
      PRINT "Paused";
      GOSUB 10
      PRINT
    ENDIF
    GOTO 3
  ELSE
    (* If not end of line, and templines full, add first to *)
    (* outline, move others up one, and go get another *)
    IF templine(10)="" THEN 3
    outline:=outline+templine(1)
    cntr:=0
    REPEAT
      cntr:=cntr+1
      templine(cntr):=templine(cntr+1)
    UNTIL cntr=9
    templine(10):=""
    count:=10
    IF debug THEN
      PRINT "Paused";
      GOSUB 10
      PRINT
    ENDIF
    GOTO 3
  ENDIF
ENDIF
RETURN
(* Adjust templines for gaps created by parsing *)
7 cnt:=0
REPEAT
  cnt:=cnt+1
  IF templine(cnt)="" THEN
    templine(cnt):=templine(cnt+1)
    templine(cnt+1)=""
  ENDIF
UNTIL cnt=9
RETURN
8 IF SUBSTR(".=",inline)>0 THEN
  place:=SUBSTR(".=",inline)
  inline:=LEFT$(inline,place-1)+RIGHT$(inline,LEN(inline)-place)
ENDIF
IF LEFT$(inline,1)=" " THEN
  inline:=RIGHT$(inline,LEN(inline)-1)
ENDIF
IF SUBSTR("  GO",inline)>0 THEN
  place:=SUBSTR("  GO",inline)
  inline:=LEFT$(inline,place)+RIGHT$(inline,LEN(inline)-(place+1))
ENDIF
RETURN
(* Error Trap *)
9 er:=ERR
END
10 key:=""
REPEAT
RUN Inkey(key)
UNTIL key<>""
RETURN
