PROCEDURE ureadVars (* Variable Record *) (* Array *) TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGER DIM varRec(400):VREC (* File Record *) TYPE VFP1=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGER TYPE VFP2=vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGER TYPE VFP3=mTyp,vLnk,fNum:BYTE; pRec,pFld:BOOLEAN TYPE VFRC=vp1:VFP1; vp2:VFP2; vp3:VFP3 DIM varFRec:VFRC (* Colors *) TYPE COLR=white,purple,black,green,yellow,pink,cyan,blue,white2,purple2,black2,green2,yellow2,pink2,cyan2,blue2:BYTE DIM color:COLR DIM vFile,dFile,outFile:STRING[29] DIM vPath,dPath,outPath:BYTE DIM vOpen,dOpen,outOpen,quit,hasRecords:BOOLEAN DIM rNum,recNum,varCount,col,row,tmpTkn,delay:INTEGER DIM key:STRING[1]; numRec:STRING[3]; tmpCmd:STRING[6]; cPrompt1:STRING[23]; cPrompt:STRING[63]  BASE 0  (* Colors *) color.white=0 \color.purple=1 \color.black=2 \color.green=3 \color.yellow=4 color.pink=5 \color.cyan=6 \color.blue=7 \color.white2=8 \color.purple2=9 color.black2=10 \color.green2=11 \color.yellow2=12 \color.pink2=13 color.cyan2=14 \color.blue2=15 cPrompt:="[LEFT]=Previous [RIGHT]=Next [P]rint [G]oto [H]elp [ENTER]=Quit" cPrompt1:="Goto Record # (1-"+STR$(varCount)+"): "  quit:=FALSE recNum:=0  dFile:="/DD/DATA/UNPACK/procData" dOpen:=FALSE OPEN #dPath,dFile:READ dOpen:=TRUE GET #dPath,hasRecords GET #dPath,varRec CLOSE #dPath dOpen:=FALSE  vFile:="/DD/DATA/UNPACK/varDefs" vOpen:=FALSE OPEN #vPath,vFile:UPDATE vOpen:=TRUE GET #vPath,varCount  GOSUB 116 GOSUB 130 GOSUB 200  ON ERROR GOTO 300 REPEAT 10 SEEK #vPath,recNum*SIZE(varFRec)+2   GET #vPath,varFRec   GOSUB 210   col:=8 \row:=23 \ GOSUB 110   PRINT cPrompt;   GOSUB 140 UNTIL quit  CLOSE #vPath vOpen:=FALSE  GOSUB 135 GOSUB 117 END  110 RUN GFX2("CURXY",col,row) \ RETURN 115 RUN GFX2("EREOLINE") \ RETURN 116 RUN GFX2("CUROFF") \ RETURN 117 RUN GFX2("CURON") \ RETURN 120 RUN GFX2("CLEAR") \ RETURN 125 RUN GFX2("OWSET",1,0,1,80,22,color.white2,color.black2) \ RETURN 126 RUN GFX2("OWEND") \ RETURN 130 SHELL "ex tmode -echo" \ RETURN 135 SHELL "ex tmode echo" \ RETURN  140 key:=" " REPEAT   RUN Inkey(key)   IF key="" THEN     key:=" "   ENDIF UNTIL SUBSTR(key,"GgHhPp"+CHR$(8)+CHR$(9)+CHR$(13))>1 IF key=CHR$(9) THEN   recNum:=recNum+1   IF recNum>varCount-1 THEN     recNum:=varCount-1   ENDIF ELSE   IF key=CHR$(8) THEN   recNum:=recNum-1     IF recNum<0 THEN       recNum:=0     ENDIF   ELSE     IF key=CHR$(13) THEN       quit:=TRUE       PRINT     ELSE       IF SUBSTR(key,"Gg")>0 THEN         col:=8 \row:=23 \ GOSUB 110         GOSUB 115         PRINT "                   "; cPrompt1; "                   ";         col:=52 \ GOSUB 110         (* GOSUB 135 *)         GOSUB 117 145     numRec:=""         REPEAT           ! RUN Bnkey(key)           RUN Inkey(key)           IF key>="0" AND key<="9" THEN             PRINT key;             numRec:=numRec+key           ENDIF         UNTIL key=CHR$(13)         IF numRec="" THEN           RETURN         ENDIF         IF VAL(numRec)<1 OR VAL(numRec)>varCount THEN 145         (* GOSUB 130 *)         GOSUB 116         recNum:=VAL(numRec)-1       ELSE         IF SUBSTR(key,"Hh")>0 THEN           GOSUB 125 150       GOSUB 220           GOSUB 160           IF key="5" OR key=CHR$(13) THEN             GOSUB 126           ELSE             ON VAL(key) GOSUB 230,240,250,260             GOTO 150           ENDIF         ELSE           IF SUBSTR(key,"Pp")>0 THEN             GOSUB 110 \ GOSUB 115             PRINT "Writing Records...";             GOSUB 270             PRINT "Done";           ENDIF         ENDIF       ENDIF     ENDIF   ENDIF ENDIF RETURN 160 key:=" " REPEAT   ! RUN Bnkey(key)   RUN Inkey(key)   IF key="" THEN     key:=" "   ENDIF UNTIL SUBSTR(key,"12345"+CHR$(13))>0 RETURN  (* Display *) 200 GOSUB 120 col:=5 \row:=0 \ GOSUB 110 PRINT "Record#:"; col:=25 \row:=0 \ GOSUB 110 PRINT "Name:"; col:=50 \row:=0 \ GOSUB 110 PRINT "Fields:";  col:=3 \row:=1 \ GOSUB 110 PRINT "Offset to:"; col:=25 \row:=1 \ GOSUB 110 PRINT "Type:";  col:=14 \row:=3 \ GOSUB 110 PRINT "Data"; col:=25 \row:=3 \ GOSUB 110 PRINT "Field"; col:=36 \row:=3 \ GOSUB 110 PRINT "PARAM";  col:=6 \row:=4 \ GOSUB 110 PRINT "Offset:";  col:=8 \row:=5 \ GOSUB 110 PRINT "Size:";  col:=14 \row:=7 \ GOSUB 110 PRINT "VDT";  col:=6 \row:=8 \ GOSUB 110 PRINT "Offset:"; col:=46 \row:=8 \ GOSUB 110 PRINT "Entry size:";  col:=7 \row:=9 \ GOSUB 110 PRINT "Token:"; col:=49 \row:=9 \ GOSUB 110 PRINT "Pointer:";  col:=14 \row:=11 \ GOSUB 110 PRINT "DSAT";  col:=8 \row:=12 \ GOSUB 110 PRINT "Type:"; col:=48 \row:=12 \ GOSUB 110 PRINT "Var Size:";  col:=6 \row:=13 \ GOSUB 110 PRINT "Offset:"; col:=22 \row:=13 \ GOSUB 110 PRINT "Pointer:"; col:=44 \row:=13 \ GOSUB 110 PRINT "Str/Rec Size:";  col:=4 \row:=14 \ GOSUB 110 PRINT "Element1:"; col:=21 \row:=14 \ GOSUB 110 PRINT "Element2:"; col:=48 \row:=14 \ GOSUB 110 PRINT "Element3:";  col:=2 \row:=15 \ GOSUB 110 PRINT "Entry size:"; col:=24 \row:=15 \ GOSUB 110 PRINT "Array:"; col:=50 \row:=15 \ GOSUB 110 PRINT "Length:";  col:=2 \row:=17 \ GOSUB 110 PRINT "FOR/NEXT or"; col:=17 \row:=17 \ GOSUB 110 PRINT "Variable Type"; col:=34 \row:=17 \ GOSUB 110 PRINT "Named Variable "; col:=52 \row:=17 \ GOSUB 110 PRINT "INTEGER or REAL";  col:=2 \row:=18 \ GOSUB 110 PRINT "Named Vars:";  col:=2 \row:=20 \ GOSUB 110 PRINT "Record#"; col:=12 \row:=20 \ GOSUB 110 PRINT "Total Refs"; col:=25 \row:=20 \ GOSUB 110 PRINT "Parent Rec"; col:=38 \row:=20 \ GOSUB 110 PRINT "Var Type"; col:=49 \row:=20 \ GOSUB 110 PRINT "ExtCmd"; col:=58 \row:=20 \ GOSUB 110 PRINT "Is Record"; col:=70 \row:=20 \ GOSUB 110 PRINT "Is Field"; RETURN  (* Variable Data *) 210 col:=14 \row:=0 \ GOSUB 110 PRINT USING "i4<",recNum+1; col:=31 \row:=0 \ GOSUB 110 PRINT varFRec.vp2.vName; " "; col:=58 \row:=0 \ GOSUB 110 PRINT USING "i2<",varFRec.vp3.fNum;  col:=14 \row:=1 \ GOSUB 110 PRINT USING "h4",varRec(recNum).vOff; col:=31 \row:=1 \ GOSUB 110 PRINT USING "h2",varRec(recNum).vTyp; IF varRec(recNum).vTyp>=$80 AND varRec(recNum).vTyp<=$83 THEN   IF varRec(recNum).vTyp=$80 THEN     PRINT " BYTE";   ELSE     IF varRec(recNum).vTyp=$81 THEN       PRINT " INTEGER";     ELSE       IF varRec(recNum).vTyp=$82 THEN         PRINT " REAL";       ELSE         IF varRec(recNum).vTyp=$83 THEN           PRINT " BOOLEAN";         ENDIF       ENDIF     ENDIF   ENDIF   PRINT " (Data Memory)   "; ELSE   IF varRec(recNum).vTyp>=$00 AND varRec(recNum).vTyp<=$03 THEN     IF varRec(recNum).vTyp=$00 OR  varRec(recNum).vTyp=$01 THEN       PRINT " INTEGER";     ELSE       IF varRec(recNum).vTyp=$02 OR  varRec(recNum).vTyp=$03 THEN         PRINT " REAL";       ENDIF     ENDIF     PRINT " (Data Memory)   ";   ELSE     IF varRec(recNum).vTyp=$46 OR varRec(recNum).vTyp=$47 THEN       IF varFRec.vp2.intReal=1 THEN         PRINT " INTEGER";       ELSE         IF varFRec.vp2.intReal=2 THEN           PRINT " REAL";         ENDIF       ENDIF       PRINT " (Data Memory)   ";     ELSE       IF varRec(recNum).vTyp=$84 THEN         PRINT " (DSAT)               ";       ELSE         PRINT " (VDT)                ";       ENDIF     ENDIF   ENDIF ENDIF  col:=14 \row:=4 \ GOSUB 110 PRINT USING "h4",varRec(recNum).dmOff; col:=25 \row:=4 \ GOSUB 110 PRINT USING "h4",varRec(recNum).fOff; col:=36 \row:=4 \ GOSUB 110 PRINT USING "h4",varRec(recNum).pOff;  col:=14 \row:=5 \ GOSUB 110 PRINT USING "i5<",varFRec.vp1.dmSiz; col:=25 \row:=5 \ GOSUB 110 PRINT USING "i5<",varFRec.vp1.fSiz; col:=36 \row:=5 \ GOSUB 110 PRINT USING "i5<",varFRec.vp1.pSiz;  col:=14 \row:=8 \ GOSUB 110 PRINT USING "h4",varRec(recNum).vdOff; col:=58 \row:=8 \ GOSUB 110 PRINT USING "i5<",varFRec.vp1.vdSiz;  col:=14 \row:=9 \ GOSUB 110 PRINT USING "h2",varFRec.vp1.vdTkn; col:=16 \row:=9 \ GOSUB 110 PRINT "                      "; col:=16 \row:=9 \ GOSUB 110 IF varFRec.vp1.vdTkn>0 THEN   PRINT " (";   IF varFRec.vp1.vdTkn>=$40 AND varFRec.vp1.vdTkn<=$5F THEN     PRINT "Field ";   ENDIF   IF varFRec.vp1.vdTkn>=$80 AND varFRec.vp1.vdTkn<=$9F THEN     PRINT "PARAM ";   ENDIF   IF varFRec.vp1.vdTkn=$40 OR varFRec.vp1.vdTkn=$60 OR varFRec.vp1.vdTkn=$80 THEN     PRINT "BYTE";   ENDIF   IF varFRec.vp1.vdTkn=$48 OR varFRec.vp1.vdTkn=$68 OR varFRec.vp1.vdTkn=$88 THEN     PRINT "BYTE";   ENDIF   IF varFRec.vp1.vdTkn=$50 OR varFRec.vp1.vdTkn=$70 OR varFRec.vp1.vdTkn=$90 THEN     PRINT "BYTE";   ENDIF   IF varFRec.vp1.vdTkn=$58 OR varFRec.vp1.vdTkn=$78 OR varFRec.vp1.vdTkn=$98 THEN     PRINT "BYTE";   ENDIF   IF varFRec.vp1.vdTkn=$41 OR varFRec.vp1.vdTkn=$61 OR varFRec.vp1.vdTkn=$81 THEN     PRINT "INTEGER";   ENDIF   IF varFRec.vp1.vdTkn=$49 OR varFRec.vp1.vdTkn=$69 OR varFRec.vp1.vdTkn=$89 THEN     PRINT "INTEGER";   ENDIF   IF varFRec.vp1.vdTkn=$51 OR varFRec.vp1.vdTkn=$71 OR varFRec.vp1.vdTkn=$91 THEN     PRINT "INTEGER";   ENDIF   IF varFRec.vp1.vdTkn=$59 OR varFRec.vp1.vdTkn=$79 OR varFRec.vp1.vdTkn=$99 THEN     PRINT "INTEGER";   ENDIF   IF varFRec.vp1.vdTkn=$42 OR varFRec.vp1.vdTkn=$62 OR varFRec.vp1.vdTkn=$82 THEN     PRINT "REAL";   ENDIF   IF varFRec.vp1.vdTkn=$4A OR varFRec.vp1.vdTkn=$6A OR varFRec.vp1.vdTkn=$8A THEN     PRINT "REAL";   ENDIF   IF varFRec.vp1.vdTkn=$52 OR varFRec.vp1.vdTkn=$72 OR varFRec.vp1.vdTkn=$92 THEN     PRINT "REAL";   ENDIF   IF varFRec.vp1.vdTkn=$5A OR varFRec.vp1.vdTkn=$7A OR varFRec.vp1.vdTkn=$9A THEN     PRINT "REAL";   ENDIF   IF varFRec.vp1.vdTkn=$43 OR varFRec.vp1.vdTkn=$63 OR varFRec.vp1.vdTkn=$83 THEN     PRINT "BOOLEAN";   ENDIF   IF varFRec.vp1.vdTkn=$4B OR varFRec.vp1.vdTkn=$6B OR varFRec.vp1.vdTkn=$8B THEN     PRINT "BOOLEAN";   ENDIF   IF varFRec.vp1.vdTkn=$53 OR varFRec.vp1.vdTkn=$73 OR varFRec.vp1.vdTkn=$93 THEN     PRINT "BOOLEAN";   ENDIF   IF varFRec.vp1.vdTkn=$5B OR varFRec.vp1.vdTkn=$7B OR varFRec.vp1.vdTkn=$9B THEN     PRINT "BOOLEAN";   ENDIF   IF varFRec.vp1.vdTkn=$44 OR varFRec.vp1.vdTkn=$64 OR varFRec.vp1.vdTkn=$84 THEN     PRINT "STRING";   ENDIF   IF varFRec.vp1.vdTkn=$4C OR varFRec.vp1.vdTkn=$6C OR varFRec.vp1.vdTkn=$8C THEN     PRINT "STRING";   ENDIF   IF varFRec.vp1.vdTkn=$54 OR varFRec.vp1.vdTkn=$74 OR varFRec.vp1.vdTkn=$94 THEN     PRINT "STRING";   ENDIF   IF varFRec.vp1.vdTkn=$5C OR varFRec.vp1.vdTkn=$7C OR varFRec.vp1.vdTkn=$9C THEN     PRINT "STRING";   ENDIF   IF varFRec.vp1.vdTkn=$45 OR varFRec.vp1.vdTkn=$65 OR varFRec.vp1.vdTkn=$85 THEN     PRINT "Record";   ENDIF   IF varFRec.vp1.vdTkn=$4D OR varFRec.vp1.vdTkn=$6D OR varFRec.vp1.vdTkn=$8D THEN     PRINT "Record";   ENDIF   IF varFRec.vp1.vdTkn=$55 OR varFRec.vp1.vdTkn=$75 OR varFRec.vp1.vdTkn=$95 THEN     PRINT "Record";   ENDIF   IF varFRec.vp1.vdTkn=$5D OR varFRec.vp1.vdTkn=$7D OR varFRec.vp1.vdTkn=$9D THEN     PRINT "Record";   ENDIF   IF varFRec.vp1.vdTkn>=$48 AND varFRec.vp1.vdTkn<=$5F OR varFRec.vp1.vdTkn>=$68 AND varFRec.vp1.vdTkn<=$7F OR varFRec.vp1.vdTkn>=$88 AND varFRec.vp1.vdTkn<=$9F THEN     PRINT " Array";   ENDIF   IF varFRec.vp1.vdTkn=$A0 THEN     PRINT "Subroutine";   ENDIF   PRINT ")"; ENDIF col:=58 \row:=9 \ GOSUB 110 PRINT USING "h4",varFRec.vp1.vdPtr; IF varFRec.vp1.vdTkn>=$40 AND varFRec.vp1.vdTkn<=$43 OR varFRec.vp1.vdTkn>=$60 AND varFRec.vp1.vdTkn<=$63 OR varFRec.vp1.vdTkn>=$80 AND varFRec.vp1.vdTkn<=$83 OR varFRec.vp1.vdTkn=$A0 THEN   PRINT " (Data Memory)"; ELSE   IF varFRec.vp1.vdTkn>0 THEN     PRINT " (DSAT)       ";   ELSE     PRINT "              ";   ENDIF ENDIF  col:=14 \row:=12 \ GOSUB 110 IF varRec(recNum).vTyp=$84 THEN   PRINT "Instruction Entry: STRING"; ELSE   IF varFRec.vp1.vdTkn>=$44 AND varFRec.vp1.vdTkn<=$5F OR varFRec.vp1.vdTkn>=$64 AND varFRec.vp1.vdTkn<=$7F OR varFRec.vp1.vdTkn>=$84 AND varFRec.vp1.vdTkn<=$9F THEN     PRINT "VDT Entry                ";   ELSE     PRINT "                         ";   ENDIF ENDIF col:=58 \row:=12 \ GOSUB 110 PRINT USING "i6<",varFRec.vp1.dsvSiz;  col:=14 \row:=13 \ GOSUB 110 PRINT USING "h4",varRec(recNum).dsOff; col:=31 \row:=13 \ GOSUB 110 PRINT USING "h4",varFRec.vp1.dsPtr; col:=58 \row:=13 \ GOSUB 110 PRINT USING "i6<",varFRec.vp1.vSRLen;  col:=14 \row:=14 \ GOSUB 110 PRINT USING "i6<",varFRec.vp1.elem1; col:=31 \row:=14 \ GOSUB 110 PRINT USING "i6<",varFRec.vp1.elem2; col:=58 \row:=14 \ GOSUB 110 PRINT USING "i6<",varFRec.vp1.elem3;  col:=14 \row:=15 \ GOSUB 110 PRINT USING "i6<",varFRec.vp1.dsSiz; col:=31 \row:=15 \ GOSUB 110 PRINT USING "s19<",varFRec.vp2.vArray; col:=58 \row:=15 \ GOSUB 110 PRINT USING "s7<",varFRec.vp2.vStrLen;  col:=17 \row:=18 \ GOSUB 110 PRINT USING "i2<",varRec(recNum).nTyp; col:=34 \row:=18 \ GOSUB 110 PRINT USING "b5",varRec(recNum).nVar; col:=52 \row:=18 \ GOSUB 110 PRINT USING "i3<",varFRec.vp2.intReal;  col:=2 \row:=21 \ GOSUB 110 PRINT USING "i4<",varFRec.vp2.vRecNum; col:=12 \row:=21 \ GOSUB 110 PRINT USING "i4<",varFRec.vp2.vRefCnt; col:=25 \row:=21 \ GOSUB 110 PRINT USING "i4<",varFRec.vp2.pVar; col:=38 \row:=21 \ GOSUB 110 PRINT USING "i2<",varFRec.vp3.mTyp;  REPEAT   READ tmpTkn,tmpCmd  UNTIL varFRec.vp3.vLnk=tmpTkn col:=49 \row:=21 \ GOSUB 110 PRINT USING "s6",tmpCmd; col:=58 \row:=21 \ GOSUB 110 PRINT USING "b5",varFRec.vp3.pRec; col:=70 \row:=21 \ GOSUB 110 PRINT USING "b5",varFRec.vp3.pFld; RETURN  220 GOSUB 120 col:=5 \row:=3 \ GOSUB 110 PRINT "1 Top Section" col:=5 \row:=4 \ GOSUB 110 PRINT "2 VDT Section" col:=5 \row:=5 \ GOSUB 110 PRINT "3 DSAT Section" col:=5 \row:=6 \ GOSUB 110 PRINT "4 Bottom Section" RETURN 230 GOSUB 120 PRINT "Top Section" PRINT PRINT "  Record#: Current Variable Record #" PRINT "     Name: Current Variable Name" PRINT "Offset to: DSAT or Data Memory Offset Address" PRINT "     Type: Primary Variable Type Token" PRINT "   Offset: Offset Address to Data, Record, Parameter Memory" PRINT "     Size: Data Size in Data, Record, Parameter Memory" PRINT PRINT "Press [ENTER]"; GOSUB 160 RETURN 240 GOSUB 120 PRINT "VDT Section" PRINT PRINT "    Offset: VDT Offset Address" PRINT "Entry size: # of BYTEs used in this VDT entry" PRINT "     Token: Secondary Variable Type Token" PRINT "   Pointer: DSAT or Data Memory Offset Address" PRINT PRINT "Press [ENTER]"; GOSUB 160 RETURN 250 GOSUB 120 PRINT "DSAT Section" PRINT PRINT "        Type: Instruction Entry STRING or VDT Entry" PRINT "    Var Size: Total Variable Size" PRINT "      Offset: DSAT Offset Address" PRINT "     Pointer: Data Memory Offset Address" PRINT "Str/Rec Size: String/Record Size if Array" PRINT "    Element1: # of Array 1 Elements" PRINT "    Element2: # of Array 2 Elements" PRINT "    Element3: # of Array 3 Elements" PRINT "  Entry size: # of BYTEs used in this DSAT entry" PRINT "       Array: Array String used with dimension statements" PRINT "      Length: STRING Length used with dimension statements" PRINT PRINT "Press [ENTER]"; GOSUB 160 RETURN 260 GOSUB 120 PRINT "Bottom Section:" PRINT PRINT "FOR/NEXT or Named Variables" PRINT "  Variable Type: 0=Field Variable" PRINT "                 1=Named Variable" PRINT "                 2=Parameter Variable" PRINT "                 3=Subroutine or Internal Variable" PRINT " Named Variable: TRUE=Named  FALSE=Internal" PRINT "INTEGER or REAL: 0=N/A  1=INTEGER  2=REAL" PRINT PRINT "Miscellaneous Variables" PRINT "   Record#: Parent Record Variable #" PRINT "Total Refs: # of References to this variable" PRINT "Parent Rec: Parent Record # (if a Field Variable)" PRINT "  Var Type: 1=Simple Variable  2=STRING  3=VDT Entry" PRINT "    ExtCmd: $24=KILL    $29=CREATE  $2A=OPEN  $30=CLOSE" PRINT "            $32=DELETE  $33=CHAIN   $34=SHELL" PRINT "   Pot Rec: Is a Potential Record Variable" PRINT "  Is Field: Is a Field Variable" PRINT PRINT "Press [ENTER]"; GOSUB 160 RETURN DATA $00,"",$23,"RUN",$24,"KILL",$29,"CREATE",$2A,"OPEN",$30,"CLOSE",$32,"DELETE",$33,"CHAIN",$34,"SHELL"  270 outFile:="vars.B09" CREATE #outPath,outFile:WRITE outOpen:=TRUE rNum:=0 GOSUB 280 REPEAT   SEEK #vPath,rNum*SIZE(varFRec)+2   GET #vPath,varFRec   GOSUB 290   rNum:=rNum+1 UNTIL rNum=varCount CLOSE #outPath outOpen:=FALSE RETURN 280 IF outOpen THEN PRINT #outPath, "RNum _Instr_ VDT__________VDT_ DSAT___________DSAT Data_Mmry __Field__ Parm Expd" PRINT #outPath USING "i4>,s76",varCount," Tk Pntr Addr Tk Pntr Size Addr Pntr Size Size Addr Size Addr Size Addr Size "; PRINT #outPath, "VES_ TES_ MES_ SRSz Array Size String   Variable/Subroutine Name      StrLen Fields" ENDIF RETURN 290 IF outOpen THEN   (* Print to Output File *)   !"Ref  _Instr_ "   !"Num_ Tk Pntr "   PRINT #outPath USING "i4>,s1",rNum+1," ";   PRINT #outPath USING "h2,s1",varRec(rNum).vTyp," ";   PRINT #outPath USING "h4,s1",varRec(rNum).vOff," ";   IF varFRec.vp1.vdTkn>0 THEN     !"________VDT______ "     !"Addr Tk Pntr Size "     PRINT #outPath USING "h4,s1",varRec(rNum).vdOff," ";     PRINT #outPath USING "h2,s1",varFRec.vp1.vdTkn," ";     PRINT #outPath USING "h4,s1",varFRec.vp1.vdPtr," ";     PRINT #outPath USING "h4,s1",varFRec.vp1.vdSiz," ";   ELSE     PRINT #outPath, "---- -- ---- ---- ";   ENDIF   IF varFRec.vp1.dsSiz>0 THEN     !"DSAT___________DSAT "     !"Addr Pntr Size Size "     PRINT #outPath USING "h4,s1",varRec(rNum).dsOff," ";     PRINT #outPath USING "h4,s1",varFRec.vp1.dsPtr," ";     PRINT #outPath USING "h4,s1",varFRec.vp1.dsvSiz," ";     PRINT #outPath USING "h4,s1",varFRec.vp1.dsSiz," ";   ELSE     PRINT #outPath, "---- ---- ---- ---- ";   ENDIF   IF varFRec.vp1.dmSiz>0 THEN     !"Data_Mmry "     !"Addr Size "     PRINT #outPath USING "h4,s1",varRec(rNum).dmOff," ";     PRINT #outPath USING "h4,s1",varFRec.vp1.dmSiz," ";   ELSE     PRINT #outPath, "---- ---- ";   ENDIF   IF varFRec.vp1.fSiz>0 THEN     !"__Field__ "     !"Addr Size "     PRINT #outPath USING "h4,s1",varRec(rNum).fOff," ";     PRINT #outPath USING "h4,s1",varFRec.vp1.fSiz," ";   ELSE     PRINT #outPath, "---- ---- ";   ENDIF   IF varFRec.vp1.pSiz>0 THEN     !"Parm Expd";     !"Addr Size";     PRINT #outPath USING "h4,s1",varRec(rNum).pOff," ";     PRINT #outPath USING "h4,s1",varFRec.vp1.pSiz," ";   ELSE     PRINT #outPath, "---- ---- ";   ENDIF   IF varFRec.vp1.elem1>0 THEN     !"VES_ "     PRINT #outPath USING "h4,s1",varFRec.vp1.elem1," ";   ELSE     PRINT #outPath, "---- ";   ENDIF   IF varFRec.vp1.elem2>0 THEN     !"TES_ "     PRINT #outPath USING "h4,s1",varFRec.vp1.elem2," ";   ELSE     PRINT #outPath, "---- ";   ENDIF   IF varFRec.vp1.elem3>0 THEN     !"MES_ "     PRINT #outPath USING "h4,s1",varFRec.vp1.elem3," ";   ELSE     PRINT #outPath, "---- ";   ENDIF   IF varFRec.vp1.vSRLen>0 THEN     !"SRSz "     PRINT #outPath USING "h4,s1",varFRec.vp1.vSRLen," ";   ELSE     PRINT #outPath, "---- ";   ENDIF   IF varFRec.vp2.vArray<>"" THEN     !"Array Size String   "     PRINT #outPath USING "s19,s1",varFRec.vp2.vArray," ";   ELSE     PRINT #outPath, "------------------- ";   ENDIF   IF varFRec.vp2.vName<>"" THEN     !"Variable/Subroutine Name      "     PRINT #outPath USING "s29,s1",varFRec.vp2.vName," ";   ELSE     PRINT #outPath, "----------------------------- ";   ENDIF   IF varFRec.vp2.vStrLen<>"" THEN     !"StrLen ";     PRINT #outPath USING "s7",varFRec.vp2.vStrLen;   ELSE     PRINT #outPath, "-------";   ENDIF   PRINT #outPath   IF varFRec.vp3.fNum>0 THEN     !"Fields ";     PRINT #outPath USING "s3,i2>"," ",varFRec.vp3.fNum;   ELSE     PRINT #outPath, " ------";   ENDIF   PRINT #outPath ENDIF RETURN  300 er:=ERR IF er=55 THEN   col:=8 \row:=23 \ GOSUB 110   PRINT "There are no readable records.                                 ";   FOR delay:=1 TO 10000 \NEXT delay   recNum:=0   col:=8 \row:=23 \ GOSUB 110   PRINT "                                                               ";   GOTO 10 ENDIF PRINT er END