PROCEDURE udefVars (* Version 01.00.00 *) (* Variable Array Record *) TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGER DIM varRec(400):VREC (* Variable File Record *) TYPE VFP1=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGER TYPE VFP2=vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGER TYPE VFP3=mTyp,vLnk,fNum:BYTE; pRec,pFld:BOOLEAN TYPE VFRC=vp1:VFP1; vp2:VFP2; vp3:VFP3 DIM varFRec:VFRC (* ==================== *) (* Input Variables *) DIM tokenCode,tokenByte,byteVal:BYTE; intVal:INTEGER (* Various counters *) DIM iToken,vToken:BYTE DIM recNum,fRecs,iPointer,vAddr,vPointer,vSize:INTEGER DIM dsAddr,dsPointer,dSize,dsSize,dmAddr,dmSize,pAddr,pSize,fAddr,fSize,element1:INTEGER DIM element2,element3,strRecLen,recSize,recArraySize:INTEGER (* Flag Variables *) DIM isSimple,isParam,isString,isRecord,isArray,isArray1,isArray2,isArray3:BOOLEAN DIM isField,hasRecords,first:BOOLEAN (* Variable Reference Counters *) DIM varCount,varNum,fldNum:INTEGER (* File filePaths *) DIM vPath,dPath:BYTE (* File status *) DIM vOpen,dOpen:BOOLEAN (* Error Data *) DIM which:INTEGER (* File names *) DIM vFile,dFile:STRING[29] (* Strings *) DIM numStr:STRING[4] DIM strLen:STRING[7] DIM tokenString:STRING[8] DIM arrayStr:STRING[19] DIM subName,tName:STRING[29] (* ==================== *) (* Parameters *) PARAM filePath:BYTE; er,tpVars:INTEGER; verbose:BOOLEAN; modSize,execOff,descOff,symTabOff:REAL; dataDir:STRING[16]  (* **************** *) (* Start of Program *) (* Preliminary initialization of variables *) BASE 0 er:=0 \which:=0 ON ERROR GOTO 500 \REM goto error trap vFile:=dataDir+"varDefs" dFile:=dataDir+"procData" (* Get data *) OPEN #dPath,dFile:READ dOpen:=TRUE (* Procedure has records *) GET #dPath,hasRecords (* Variables lookup table *) GET #dPath,varRec CLOSE #dPath dOpen:=FALSE (* Open Variable Reference File *) OPEN #vPath,vFile:UPDATE vOpen:=TRUE GET #vPath,varCount (* Open File *) SEEK #filePath,descOff  (* Begin Variable Identification *) PRINT #2,"Identifying Variable Records"; IF verbose THEN   PRINT #2 ELSE   PRINT "..."; ENDIF first:=TRUE GOSUB 200 recNum:=0 \hasRecords:=FALSE SEEK #vPath,recNum*SIZE(varFRec)+2 (* Read Data *) REPEAT    iToken:=0 \iPointer:=0   dmAddr:=0 \dmSize:=0   dsAddr:=0 \dsPointer:=0 \dsSize:=0 \dSize:=0   vAddr:=0 \vPointer:=0 \vToken:=0 \vSize:=0   pAddr:=0 \pSize:=0   fAddr:=0 \fSize:=0   element1:=0 \element2:=0 \element3:=0   strRecLen:=0 \recSize:=0 \recArraySize:=0   subName:="" \arrayStr:="" \strLen:=""   isSimple:=FALSE \isParam:=FALSE \isString:=FALSE \isRecord:=FALSE \isField:=FALSE   isArray:=FALSE \isArray1:=FALSE \isArray2:=FALSE \isArray3:=FALSE   (* Next Record *)   GET #vPath,varFRec   iToken:=varRec(recNum).vTyp   iPointer:=varRec(recNum).vOff   RESTORE 430 \REM set to Atomic variable name labels   (* Simple Atomic *)   IF varFRec.vp3.mTyp=1 THEN      (* VDT, Param and Field entry not necessary if type 1 *)     (* Get Name String *)     tokenCode:=varRec(recNum).vTyp     GOSUB 410 \REM get initial variable name identifer     varFRec.vp2.vName:=tokenString     subName:=tokenString     (* Data Memory Address and Variable Size *)     dmAddr:=iPointer     IF varRec(recNum).vTyp=$80 OR varRec(recNum).vTyp=$83 THEN        varRec(recNum).nTyp:=1       varFRec.vp2.intReal:=0       dmSize:=1     ENDIF      IF varRec(recNum).vTyp=$81 OR varRec(recNum).vTyp=$00 OR varRec(recNum).vTyp=$01 THEN        IF NOT(varRec(recNum).nVar) THEN          varRec(recNum).nTyp:=3         varFRec.vp2.intReal:=1       ELSE          varRec(recNum).nTyp:=1         varFRec.vp2.intReal:=0       ENDIF        dmSize:=2     ENDIF      IF varRec(recNum).vTyp=$82 OR varRec(recNum).vTyp=$02 OR varRec(recNum).vTyp=$03 THEN        IF NOT(varRec(recNum).nVar) THEN          varRec(recNum).nTyp:=3         varFRec.vp2.intReal:=2       ELSE          varRec(recNum).nTyp:=1         varFRec.vp2.intReal:=0       ENDIF        dmSize:=5     ENDIF      IF varRec(recNum).vTyp=$46 OR varRec(recNum).vTyp=$47 THEN        varRec(recNum).nTyp:=3       IF varFRec.vp2.intReal=1 THEN          dmSize:=2       ELSE          IF varFRec.vp2.intReal=2 THEN            dmSize:=5         ENDIF        ENDIF      ENDIF      varRec(recNum).dmOff:=dmAddr     varFRec.vp1.dmSiz:=dmSize   ENDIF    (* STRING *)   IF varFRec.vp3.mTyp=2 THEN      (* VDT, Param and Field entry not necessary if type 2 *)     isString:=TRUE     (* Get Name String *)     tokenCode:=varRec(recNum).vTyp     varRec(recNum).nTyp:=1     GOSUB 410 \REM get initial variable name identifer     varFRec.vp2.vName:=tokenString     subName:=tokenString     (* DSAT Address and Entry Size *)     dsAddr:=iPointer     varRec(recNum).dsOff:=dsAddr     dsSize:=4     varFRec.vp1.dsSiz:=dsSize     SEEK #filePath,descOff+dsAddr     GET #filePath,intVal     (* Data Memory Address and Variable Size *)     dmAddr:=intVal     varRec(recNum).dmOff:=dmAddr     dsPointer:=intVal     varFRec.vp1.dsPtr:=dsPointer     GET #filePath,intVal     dmSize:=intVal     varFRec.vp1.dmSiz:=dmSize     dSize:=intVal     varFRec.vp1.dsvSiz:=dSize     strLen:="["+STR$(dmSize)+"]"     varFRec.vp2.vStrLen:=strLen   ENDIF    (* VDT references *)   (* All references include VDT entry, DSAT, Param and Field entries vary *)   IF varFRec.vp3.mTyp=3 THEN      (* Variables *)     (* VDT Address and Entry Size *)     vAddr:=iPointer     varRec(recNum).vdOff:=vAddr     vSize:=3     varFRec.vp1.vdSiz:=vSize     SEEK #filePath,symTabOff+vAddr     (* VDT Token Value *)     GET #filePath,byteVal     vToken:=byteVal     varFRec.vp1.vdTkn:=vToken     (* Get Name String *)     tokenCode:=vToken     RESTORE 420 \REM set to VDT variable name labels     GOSUB 410 \REM get initial variable name identifer     varFRec.vp2.vName:=tokenString     subName:=tokenString     (* VDT Pointer Value *)     (* Points to DSAT, DM or PARAM *)     GET #filePath,intVal     vPointer:=intVal     varFRec.vp1.vdPtr:=vPointer     (* Subroutines *)     IF vToken=$A0 THEN        (* Pointer to Data Memory Offset, DM contains INTEGER *)       varRec(recNum).nTyp:=3       dmAddr:=vPointer       varRec(recNum).dmOff:=dmAddr       dmSize:=2       varFRec.vp1.dmSiz:=dmSize       (* Get Name String *)       REPEAT          GET #filePath,byteVal         subName:=subName+CHR$(LAND(byteVal,$7F))         vSize:=vSize+1       UNTIL byteVal>127       varFRec.vp2.vName:=subName     (* All Other VDT Entries *)     ELSE        IF vToken>=$60 AND vToken<=$63 THEN          isSimple:=TRUE         (* Data Memory Address and Variable Size *)         varRec(recNum).nTyp:=1         dmAddr:=vPointer         varRec(recNum).dmOff:=dmAddr         IF vToken=$60 OR vToken=$63 THEN            dmSize:=1         ENDIF          IF vToken=$61 THEN            dmSize:=2         ENDIF          IF vToken=$62 THEN            dmSize:=5         ENDIF          varFRec.vp1.dmSiz:=dmSize       ENDIF        IF vToken>=$40 AND vToken<=$43 THEN          varRec(recNum).nTyp:=0         isSimple:=TRUE         isField:=TRUE         varRec(recNum).dmOff:=0         varFRec.vp1.dmSiz:=0         (* Field Address and Variable Size *)         fAddr:=vPointer         varRec(recNum).fOff:=fAddr         IF vToken=$40 OR vToken=$43 THEN            fSize:=1         ENDIF          IF vToken=$41 THEN            fSize:=2         ENDIF          IF vToken=$42 THEN            fSize:=5         ENDIF          varFRec.vp1.fSiz:=fSize       ENDIF        IF vToken>=$80 AND vToken<=$83 THEN          varRec(recNum).nTyp:=2         isSimple:=TRUE         isParam:=TRUE         (* Parameter Address and Expected Size *)         pAddr:=vPointer         varRec(recNum).pOff:=pAddr         varRec(recNum).dmOff:=pAddr         IF vToken=$80 OR vToken=$83 THEN            pSize:=1         ENDIF          IF vToken=$81 THEN            pSize:=2         ENDIF          IF vToken=$82 THEN            pSize:=5         ENDIF          varFRec.vp1.pSiz:=pSize         varFRec.vp1.dmSiz:=4       ENDIF        IF NOT(isSimple) THEN          (* Define Types *)         IF vToken>=$44 AND vToken<=$5D THEN            varRec(recNum).nTyp:=0           isField:=TRUE         ENDIF          IF vToken>=$64 AND vToken<=$7D THEN            varRec(recNum).nTyp:=1         ENDIF          IF vToken>=$84 AND vToken<=$9D THEN            varRec(recNum).nTyp:=2           isParam:=TRUE         ENDIF          IF vToken=$44 OR vToken=$4C OR vToken=$54 OR vToken=$5C THEN            isString:=TRUE         ENDIF          IF vToken=$64 OR vToken=$6C OR vToken=$74 OR vToken=$7C THEN            isString:=TRUE         ENDIF          IF vToken=$84 OR vToken=$8C OR vToken=$94 OR vToken=$9C THEN            isString:=TRUE         ENDIF          IF vToken=$45 OR vToken=$4D OR vToken=$55 OR vToken=$5D THEN            isRecord:=TRUE         ENDIF          IF vToken=$65 OR vToken=$6D OR vToken=$75 OR vToken=$7D THEN            isRecord:=TRUE         ENDIF          IF vToken=$85 OR vToken=$8D OR vToken=$95 OR vToken=$9D THEN            isRecord:=TRUE         ENDIF          IF isRecord AND NOT(hasRecords) THEN            hasRecords:=TRUE         ENDIF          IF vToken>=$48 AND vToken<=$4D THEN            isArray:=TRUE \isArray1:=TRUE         ENDIF          IF vToken>=$68 AND vToken<=$6D THEN            isArray:=TRUE \isArray1:=TRUE         ENDIF          IF vToken>=$88 AND vToken<=$8D THEN            isArray:=TRUE \isArray1:=TRUE         ENDIF          IF vToken>=$50 AND vToken<=$55 THEN            isArray:=TRUE \isArray2:=TRUE         ENDIF          IF vToken>=$70 AND vToken<=$75 THEN            isArray:=TRUE \isArray2:=TRUE         ENDIF          IF vToken>=$90 AND vToken<=$95 THEN            isArray:=TRUE \isArray2:=TRUE         ENDIF          IF vToken>=$58 AND vToken<=$5D THEN            isArray:=TRUE \isArray3:=TRUE         ENDIF          IF vToken>=$78 AND vToken<=$7D THEN            isArray:=TRUE \isArray3:=TRUE         ENDIF          IF vToken>=$98 AND vToken<=$9D THEN            isArray:=TRUE \isArray3:=TRUE         ENDIF          (* DSAT Address and Entry Size *)         dsAddr:=vPointer         varRec(recNum).dsOff:=dsAddr         dsSize:=2         (* dsPointer points to DSAT, DM or PARAM *)         SEEK #filePath,descOff+dsAddr         GET #filePath,intVal         dsPointer:=intVal         varFRec.vp1.dsPtr:=dsPointer         (* dSize relative to dsPointer *)         GET #filePath,intVal         dSize:=intVal         varFRec.vp1.dsvSiz:=dSize         dsSize:=dsSize+2         IF isString THEN            IF NOT(isParam) AND NOT(isField) THEN              (* Data Memory Address and Variable Size *)             dmAddr:=dsPointer             varRec(recNum).dmOff:=dmAddr             dmSize:=dSize             varFRec.vp1.dmSiz:=dmSize           ENDIF            IF NOT(isArray) THEN              strLen:="["+STR$(dSize)+"]"             varFRec.vp2.vStrLen:=strLen           ENDIF          ENDIF          IF isRecord THEN            IF NOT(isParam) AND NOT(isField) THEN              (* Data Memory Address and Variable Size *)             dmAddr:=dsPointer             varRec(recNum).dmOff:=dmAddr             dmSize:=dSize             varFRec.vp1.dmSiz:=dmSize           ENDIF            recSize:=dSize         ENDIF          IF isField THEN            (* Field Simple Types *)           (* Pointer to position in a record, size based on type *)           (* Field Address and Variable Size *)           fAddr:=dsPointer           varRec(recNum).fOff:=fAddr           fSize:=dSize           varFRec.vp1.fSiz:=fSize           varRec(recNum).dmOff:=0           varFRec.vp1.dmSiz:=0         ENDIF          IF isParam THEN            (* Parameter Simple Types *)           (* Pointer to Parameter List offset, size is 4 (length of parameter list entry) *)           (* Parameter Address and Expected Size *)           pAddr:=dsPointer           varRec(recNum).pOff:=pAddr           varRec(recNum).dmOff:=pAddr           pSize:=dSize           varFRec.vp1.pSiz:=pSize           varFRec.vp1.dmSiz:=4         ENDIF          IF isArray THEN            IF NOT(isParam) AND NOT(isField) THEN              (* Data Memory Address and Variable Size *)             dmAddr:=dsPointer             varRec(recNum).dmOff:=dmAddr             dmSize:=dSize             varFRec.vp1.dmSiz:=dmSize           ENDIF            arrayStr:=""           GET #filePath,intVal           element1:=intVal           varFRec.vp1.elem1:=element1           arrayStr:=arrayStr+"("+STR$(element1)           dsSize:=dsSize+2           IF isArray2 OR isArray3 THEN              GET #filePath,intVal             element2:=intVal             varFRec.vp1.elem2:=element2             arrayStr:=arrayStr+","+STR$(element2)             dsSize:=dsSize+2           ENDIF            IF isArray3 THEN              GET #filePath,intVal             element3:=intVal             varFRec.vp1.elem3:=element3             arrayStr:=arrayStr+","+STR$(element3)             dsSize:=dsSize+2           ENDIF            arrayStr:=arrayStr+")"           varFRec.vp2.vArray:=arrayStr           (* STRING/Record variable *)           IF isString OR isRecord THEN              GET #filePath,intVal             strRecLen:=intVal             varFRec.vp1.vSRLen:=strRecLen             dsSize:=dsSize+2             IF isString THEN                strLen:="["+STR$(strRecLen)+"]"               varFRec.vp2.vStrLen:=strLen             ENDIF              IF isRecord THEN                recArraySize:=recSize               recSize:=strRecLen             ENDIF            ENDIF          ENDIF          (* Set DSAT Entry Size *)         IF dsSize>0 THEN            varFRec.vp1.dsSiz:=dsSize         ENDIF        ENDIF      ENDIF    ENDIF    (* Resets *)   IF isRecord AND NOT(varFRec.vp3.pRec) THEN      varFRec.vp3.pRec:=TRUE   ENDIF    IF NOT(isRecord) AND varFRec.vp3.pRec THEN      varFRec.vp3.pRec:=FALSE   ENDIF    IF isField AND NOT(varFRec.vp3.pFld) THEN      varFRec.vp3.pFld:=TRUE   ENDIF    IF NOT(isField) AND varFRec.vp3.pFld THEN      varFRec.vp3.pFld:=FALSE   ENDIF    IF NOT(isString) THEN      varFRec.vp2.vStrLen:=""   ENDIF    IF NOT(isArray) THEN      varFRec.vp2.vArray:=""   ENDIF    IF verbose THEN     GOSUB 250 \REM Display Variable References   ENDIF   SEEK #vPath,recNum*SIZE(varFRec)+2   PUT #vPath,varFRec   recNum:=recNum+1 UNTIL recNum=varCount PRINT #2,"Done" (* Sort Variables *) PRINT #2,"Sorting Variable Records ";  SEEK #vPath,0 RUN uvSort(er,which,vPath,0,varCount-1,varRec) IF er>0 THEN 500 \REM goto error trap PRINT #2," Done" (* The bubble sort for sorting the field records *) (* Count field records *) fRecs:=0 REPEAT    SEEK #vPath,fRecs*SIZE(varFRec)+2   GET #vPath,varFRec   fRecs:=fRecs+1 UNTIL varFRec.vp1.vdTkn>$5F OR varFRec.vp1.vdTkn=0 fRecs:=fRecs-1 IF fRecs>0 THEN    PRINT #2,"Sorting "; fRecs; " Field Variable Records ";    RUN uvSort(er,which,vPath,0,fRecs-1,varRec) !  RUN fSort(vPath,0,fRecs,varRec) ENDIF  OPEN #dPath,dFile:UPDATE PUT #dPath,hasRecords PUT #dPath,varRec CLOSE #dPath PRINT #2," Done" (* Display Naming Variables? *) PRINT #2,"Naming Variables "; IF verbose THEN   PRINT #2   PRINT #2," Record# Variable Name" ENDIF (* Name Variables *) recNum:=0 \varNum:=1 \fldNum:=1 \numStr:="" fAddr:=0 \dmAddr:=0 \dsAddr:=0 \tName:="" REPEAT    SEEK #vPath,recNum*SIZE(varFRec)+2   GET #vPath,varFRec   IF varRec(recNum).nVar THEN      IF varRec(recNum).nTyp=0 THEN        IF fldNum<10 THEN          numStr:="00"+STR$(fldNum)       ELSE          numStr:="0"+STR$(fldNum)       ENDIF        IF recNum>0 AND varRec(recNum).dsOff=dsAddr AND varRec(recNum).fOff=fAddr THEN          varFRec.vp2.vName:=tName       ELSE          IF RIGHT$(varFRec.vp2.vName,1)=")" THEN            varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,2)+numStr+RIGHT$(varFRec.vp2.vName,LEN(varFRec.vp2.vName)-2)         ELSE            varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,1)+numStr         ENDIF          fAddr:=varRec(recNum).fOff         dsAddr:=varRec(recNum).dsOff         tName:=varFRec.vp2.vName         fldNum:=fldNum+1       ENDIF      ELSE        IF varRec(recNum).nTyp=1 THEN          IF varNum<10 THEN            numStr:="000"+STR$(varNum)         ELSE            IF varNum<100 THEN              numStr:="00"+STR$(varNum)           ELSE              numStr:="0"+STR$(varNum)           ENDIF          ENDIF          IF dmAddr>0 AND varRec(recNum).dmOff=dmAddr THEN            varFRec.vp2.vName:=tName         ELSE            IF RIGHT$(varFRec.vp2.vName,1)=")" THEN              varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,2)+numStr+RIGHT$(varFRec.vp2.vName,LEN(varFRec.vp2.vName)-2)           ELSE              varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,1)+numStr           ENDIF            dmAddr:=varRec(recNum).dmOff           tName:=varFRec.vp2.vName           varNum:=varNum+1         ENDIF        ELSE          IF varRec(recNum).nTyp=2 THEN            IF varNum<10 THEN              numStr:="000"+STR$(varNum)           ELSE              IF varNum<100 THEN                numStr:="00"+STR$(varNum)             ELSE                numStr:="0"+STR$(varNum)             ENDIF            ENDIF            IF varRec(recNum).dmOff=dmAddr THEN              varFRec.vp2.vName:=tName           ELSE              IF RIGHT$(varFRec.vp2.vName,1)=")" THEN                varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,3)+numStr+RIGHT$(varFRec.vp2.vName,LEN(varFRec.vp2.vName)-3)             ELSE                varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,2)+numStr             ENDIF              dmAddr:=varRec(recNum).dmOff             tName:=varFRec.vp2.vName             varNum:=varNum+1           ENDIF          ENDIF        ENDIF      ENDIF    ENDIF    IF verbose THEN     PRINT #2 USING "i6>,s3,s29",recNum," ",varFRec.vp2.vName   ELSE     PRINT #2, ".";   ENDIF   IF varRec(recNum).nVar THEN      SEEK #vPath,recNum*SIZE(varFRec)+2     PUT #vPath,varFRec   ENDIF    recNum:=recNum+1 UNTIL recNum=varCount IF NOT(verbose) THEN   PRINT #2," "; ENDIF PRINT #2,"Done" (* Display Sorted Variable Records *) IF verbose THEN   PRINT #2,"Displaying Variable Records" ENDIF first:=FALSE GOSUB 200 \REM Display Variable Reference Labels IF NOT(verbose) THEN   PRINT #2," "; ENDIF SEEK #vPath,2 FOR recNum:=0 TO varCount-1   GET #vPath,varFRec   IF verbose THEN     GOSUB 250 \REM Display Variable References   ELSE     PRINT #2,".";   ENDIF NEXT recNum IF NOT(verbose) THEN   PRINT #2," "; ENDIF PRINT #2,"Done" CLOSE #vPath vOpen:=FALSE (* End of Program *) END   (* Display Variable References *) 200 IF verbose AND first THEN    PRINT #2,"Variable References (unsorted)" ELSE    IF verbose AND NOT(first) THEN      PRINT #2,"Variable References (sorted)"   ELSE     IF NOT(first) THEN       PRINT #2,"Variable References";     ENDIF   ENDIF ENDIF  IF verbose THEN   PRINT #2,"RNum _Instr_ VDT__________VDT_ DSAT___________DSAT Data_Mmry __Field__ Parm Expd"   PRINT #2 USING "i4>,s76",varCount," Tk Pntr Addr Tk Pntr Size Addr Pntr Size Size Addr Size Addr Size Addr Size"   PRINT #2," VES_ TES_ MES_ SRSz Array Size String   Variable/Subroutine Name      StrLen  Fields" ENDIF  RETURN   250 IF verbose THEN   REM "Ref  _Instr_ "   REM "Num_ Tk Pntr "   PRINT #2 USING "i4>,s1",recNum+1," ";    PRINT #2 USING "h2,s1",varRec(recNum).vTyp," ";    PRINT #2 USING "h4,s1",varRec(recNum).vOff," ";    IF varFRec.vp1.vdTkn>0 THEN    REM "________VDT______ "   REM "Addr Tk Pntr Size "   PRINT #2 USING "h4,s1",varRec(recNum).vdOff," ";    PRINT #2 USING "h2,s1",varFRec.vp1.vdTkn," ";    PRINT #2 USING "h4,s1",varFRec.vp1.vdPtr," ";    PRINT #2 USING "h4,s1",varFRec.vp1.vdSiz," ";    ELSE    PRINT #2,"---- -- ---- ---- ";    ENDIF    IF varFRec.vp1.dsSiz>0 THEN    REM "DSAT___________DSAT "   REM "Addr Pntr Size Size "   PRINT #2 USING "h4,s1",varRec(recNum).dsOff," ";    PRINT #2 USING "h4,s1",varFRec.vp1.dsPtr," ";    PRINT #2 USING "h4,s1",varFRec.vp1.dsvSiz," ";    PRINT #2 USING "h4,s1",varFRec.vp1.dsSiz," ";    ELSE    PRINT #2,"---- ---- ---- ---- ";    ENDIF    IF varFRec.vp1.dmSiz>0 THEN    REM "Data_Mmry "   REM "Addr Size "   PRINT #2 USING "h4,s1",varRec(recNum).dmOff," ";    PRINT #2 USING "h4,s1",varFRec.vp1.dmSiz," ";    ELSE    PRINT #2,"---- ---- ";    ENDIF    IF varFRec.vp1.fSiz>0 THEN    REM "__Field__ "   REM "Addr Size "   PRINT #2 USING "h4,s1",varRec(recNum).fOff," ";    PRINT #2 USING "h4,s1",varFRec.vp1.fSiz," ";    ELSE    PRINT #2,"---- ---- ";    ENDIF    IF varFRec.vp1.pSiz>0 THEN    REM "Parm Expd";   REM "Addr Size";   PRINT #2 USING "h4,s1",varRec(recNum).pOff," ";    PRINT #2 USING "h4,s1",varFRec.vp1.pSiz," ";    ELSE    PRINT #2,"---- ---- ";    ENDIF    IF varFRec.vp1.elem1>0 THEN    REM "VES_ "   PRINT #2 USING "h4,s1",varFRec.vp1.elem1," ";    ELSE    PRINT #2,"---- ";    ENDIF    IF varFRec.vp1.elem2>0 THEN    REM "TES_ "   PRINT #2 USING "h4,s1",varFRec.vp1.elem2," ";    ELSE    PRINT #2,"---- ";    ENDIF    IF varFRec.vp1.elem3>0 THEN    REM "MES_ "   PRINT #2 USING "h4,s1",varFRec.vp1.elem3," ";    ELSE    PRINT #2,"---- ";    ENDIF    IF varFRec.vp1.vSRLen>0 THEN    REM "SRSz "   PRINT #2 USING "h4,s1",varFRec.vp1.vSRLen," ";    ELSE    PRINT #2,"---- ";    ENDIF    IF varFRec.vp2.vArray<>"" THEN    REM "Array Size String   "   PRINT #2 USING "s19,s1",varFRec.vp2.vArray," ";    ELSE    PRINT #2,"------------------- ";    ENDIF    IF varFRec.vp2.vName<>"" THEN    REM "Variable/Subroutine Name      "   PRINT #2 USING "s29,s1",varFRec.vp2.vName," ";    ELSE    PRINT #2,"----------------------------- ";    ENDIF    IF varFRec.vp2.vStrLen<>"" THEN    REM "StrLen ";   PRINT #2 USING "s7",varFRec.vp2.vStrLen;    ELSE    PRINT #2,"-------";    ENDIF    REM "Fields "   IF LEFT$(varFRec.vp2.vName,1)="C" OR LEFT$(varFRec.vp2.vName,1)="c" THEN   PRINT #2 USING "s3,i2>"," ",varFRec.vp3.fNum;    ELSE    PRINT #2," ------";    ENDIF    PRINT #2 ELSE   PRINT #2, "."; ENDIF RETURN   (* Assign Beginning Variable Label Name *) 410 REPEAT    READ tokenByte,tokenString UNTIL tokenByte=tokenCode OR tokenByte=$A0 RETURN   (* Data for Label Names *) 420 DATA $40,"b",$41,"i",$42,"r",$43,"l",$44,"s",$45,"c" DATA $60,"B",$61,"I",$62,"R",$63,"L",$64,"S",$65,"C" DATA $80,"PB",$81,"PI",$82,"PR",$83,"PL",$84,"PS",$85,"PC" DATA $48,"ba()",$49,"ia()",$4A,"ra()",$4B,"la()",$4C,"sa()",$4D,"ca()" DATA $68,"BA()",$69,"IA()",$6A,"RA()",$6B,"LA()",$6C,"SA()",$6D,"CA()" DATA $88,"PBA()",$89,"PIA()",$8A,"PRA()",$8B,"PLA()",$8C,"PSA()",$8D,"PCA()" DATA $50,"ba(,)",$51,"ia(,)",$52,"ra(,)",$53,"la(,)",$54,"sa(,)",$55,"ca(,)" DATA $70,"BA(,)",$71,"IA(,)",$72,"RA(,)",$73,"LA(,)",$74,"SA(,)",$75,"CA(,)" DATA $90,"PBA(,)",$91,"PIA(,)",$92,"PRA(,)",$93,"PLA(,)",$94,"PSA(,)",$95,"PCA(,)" DATA $58,"ba(,,)",$59,"ia(,,)",$5A,"ra(,,)",$5B,"la(,,)",$5C,"sa(,,)",$5D,"ca(,,)" DATA $78,"BA(,,)",$79,"IA(,,)",$7A,"RA(,,)",$7B,"LA(,,)",$7C,"SA(,,)",$7D,"CA(,,)" DATA $98,"PBA(,,)",$99,"PIA(,,)",$9A,"PRA(,,)",$9B,"PLA(,,)",$9C,"PSA(,,)",$9D,"PCA(,,)" DATA $A0,""  (* Data for Simple Label Names *) 430 DATA $00,"I",$01,"I",$02,"R",$03,"R",$46,"TO",$47,"STEP" DATA $80,"B",$81,"I",$82,"R",$83,"L",$84,"S" DATA $85,"",$86,"",$87,"",$88,"",$89,"",$8A,"",$8B,"",$8C,"" DATA $F2,"",$F3,"",$F4,"",$F5,"",$F6,"",$F7,"",$F8,"",$F9,""  (* Error Trap *) 500 er:=ERR IF vOpen THEN    CLOSE #vPath   vOpen:=FALSE ENDIF  IF dOpen THEN    CLOSE #dPath   dOpen:=FALSE ENDIF  END PROCEDURE uvSort (* based on quicksort, by T.F. Ritter (* Variable Record *) (* Array *) TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGER DIM varRec:VREC (* File Record *) TYPE VFP1=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGER TYPE VFP2=vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGER TYPE VFP3=mTyp,vLnk,fNum:BYTE; pRec,pFld:BOOLEAN TYPE VFRC= vp1:VFP1; vp2:VFP2; vp3:VFP3 DIM varFRec,varFRecs(2):VFRC PARAM er,which:INTEGER; vPath:BYTE; bottom,top:INTEGER; varRecs(400):VREC DIM lower,upper:INTEGER; btemp:BOOLEAN  ON ERROR GOTO 10  which:=which+1 PRINT #2, "."; BASE 0  lower:=bottom upper:=top  LOOP  \REM each element gets the once over    REPEAT  \REM this is a postinc instruction     btemp:=varRecs(lower).dmOff<varRecs(top).dmOff     lower:=lower+1   UNTIL NOT(btemp)   lower:=lower-1 \REM point at the tested element EXITIF lower=upper THEN  ENDEXIT     REPEAT  \REM this is a postdec instruction     upper:=upper-1   UNTIL varRecs(upper).dmOff<=varRecs(top).dmOff OR upper=lower EXITIF lower=upper THEN  ENDEXIT     SEEK #vPath,lower*SIZE(varFRec)+2   GET #vPath,varFRec   varFRecs(0):=varFRec   SEEK #vPath,upper*SIZE(varFRec)+2   GET #vPath,varFRec   varFRecs(1):=varFRec   varRec:=varRecs(lower)   varRecs(lower):=varRecs(upper)   varRecs(upper):=varRec   varFRec:=varFRecs(0)   varFRecs(0):=varFRecs(1)   varFRecs(1):=varFRec   SEEK #vPath,lower*SIZE(varFRec)+2   varFRec:=varFRecs(0)   PUT #vPath,varFRec   SEEK #vPath,upper*SIZE(varFRec)+2   varFRec:=varFRecs(1)   PUT #vPath,varFRec    lower:=lower+1 \REM prepare for postinc EXITIF lower=upper THEN  ENDEXIT   ENDLOOP   IF lower<>top THEN    IF varRecs(lower).dmOff<>varRecs(top).dmOff THEN      SEEK #vPath,lower*SIZE(varFRec)+2     GET #vPath,varFRec     varFRecs(0):=varFRec     SEEK #vPath,top*SIZE(varFRec)+2     GET #vPath,varFRec     varFRecs(1):=varFRec     varRec:=varRecs(lower)     varRecs(lower):=varRecs(top)     varRecs(top):=varRec     varFRec:=varFRecs(0)     varFRecs(0):=varFRecs(1)     varFRecs(1):=varFRec     SEEK #vPath,lower*SIZE(varFRec)+2     varFRec:=varFRecs(0)     PUT #vPath,varFRec     SEEK #vPath,top*SIZE(varFRec)+2     varFRec:=varFRecs(1)     PUT #vPath,varFRec   ENDIF  ENDIF   IF bottom<lower-1 THEN    RUN uvSort(er,which,vPath,bottom,lower-1,varRecs) ENDIF  IF lower+1<top THEN    RUN uvSort(er,which,vPath,lower+1,top,varRecs) ENDIF   END   10 er:=ERR END 