PROCEDURE udefVars(* Version 01.00.00 *)(* Variable Array Record *)TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGERDIM varRec(400):VREC(* Variable File Record *)TYPE VFP1=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGERTYPE VFP2=vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGERTYPE VFP3=mTyp,vLnk,fNum:BYTE; pRec,pFld:BOOLEANTYPE VFRC= vp1:VFP1; vp2:VFP2; vp3:VFP3DIM varFRec:VFRC(* ==================== *)(* Input Variables *)DIM tokenCode,tokenByte,byteVal:BYTE; intVal:INTEGER(* Various counters *)DIM iToken,vToken:BYTEDIM recNum,mCount,VDCount,VDCnt,vdtCnt,fRecs,iPointer,vAddr,vPointer,vSize:INTEGERDIM dsAddr,dsPointer,dSize,dsSize,dmAddr,dmSize,pAddr,pSize,fAddr,fSize,element1:INTEGERDIM element2,element3,strRecLen,recSize,recArraySize:INTEGERDIM mSize:REAL(* Flag Variables *)DIM found,isSimple,isParam,isString,isRecord,isArray,isArray1,isArray2,isArray3:BOOLEANDIM isField,validated,hasRecords,first:BOOLEAN(* Variable Reference Counters *)DIM varRefs,varCount,varNum,fldNum:INTEGER(* File paths *)DIM vPath,dPath,oPath:BYTE(* File status *)DIM vOpen,dOpen,oOpen:BOOLEAN(* Error Data *)DIM which:INTEGER(* File names *)DIM vFile,dFile,oFile:STRING[29](* Command String *)! DIM chainMod:STRING[177](* Strings *)DIM numStr:STRING[4]DIM strLen:STRING[7]DIM tokenString:STRING[8]DIM arrayStr:STRING[19]DIM subName,tName:STRING[29](* ==================== *)(* Parameters *)PARAM path:BYTE; er,tpVars:INTEGER; pOpen,verbose:BOOLEAN; modSize,execOff,descOff,symTabOff:REAL; dataDir:STRING[16](* Initializations *)BASE 0er:=0 \which:=0ON ERROR GOTO 500 \REM goto error trapoOpen:=FALSEvFile:=dataDir+"varDefs"dFile:=dataDir+"procData"(* Chain Module String *)! chainMod:="ex RunB #32K buildSrc ("""+proc+""","""+modName+""","""+dataDir+""")"(* Get data *)OPEN #dPath,dFile:READdOpen:=TRUE(* Procedure has records *)GET #dPath,hasRecords(* Variables lookup table *)GET #dPath,varRecCLOSE #dPathdOpen:=FALSE(* Open Variable Reference File *)OPEN #vPath,vFile:UPDATEvOpen:=TRUEGET #vPath,varCount(* Open File *)SEEK #path,descOff(* Begin Variable Identification *)PRINT #2,"Identifying Variable Records";IF verbose THEN  PRINT #2ELSE  PRINT "...";ENDIFfirst:=TRUEGOSUB 200recNum:=0 \hasRecords:=FALSESEEK #vPath,recNum*SIZE(varFRec)+2(* Read Data *)REPEAT iToken:=0 \iPointer:=0dmAddr:=0 \dmSize:=0dsAddr:=0 \dsPointer:=0 \dsSize:=0 \dSize:=0vAddr:=0 \vPointer:=0 \vToken:=0 \vSize:=0pAddr:=0 \pSize:=0fAddr:=0 \fSize:=0element1:=0 \element2:=0 \element3:=0strRecLen:=0 \recSize:=0 \recArraySize:=0subName:="" \arrayStr:="" \strLen:=""isSimple:=FALSE \isParam:=FALSE \isString:=FALSE \isRecord:=FALSE \isField:=FALSEisArray:=FALSE \isArray1:=FALSE \isArray2:=FALSE \isArray3:=FALSE(* Next Record *)GET #vPath,varFReciToken:=varRec(recNum).vTypiPointer:=varRec(recNum).vOffRESTORE 430 \REM set to Atomic variable name labels(* Simple Atomic *)IF varFRec.vp3.mTyp=1 THEN (* VDT, Param and Field entry not necessary if type 1 *)(* Get Name String *)tokenCode:=varRec(recNum).vTypGOSUB 410 \REM get initial variable name identifervarFRec.vp2.vName:=tokenStringsubName:=tokenString(* Data Memory Address and Variable Size *)dmAddr:=iPointerIF varRec(recNum).vTyp=$80 OR varRec(recNum).vTyp=$83 THEN varRec(recNum).nTyp:=1varFRec.vp2.intReal:=0dmSize:=1ENDIF IF varRec(recNum).vTyp=$81 OR varRec(recNum).vTyp=$00 OR varRec(recNum).vTyp=$01 THEN IF NOT(varRec(recNum).nVar) THEN varRec(recNum).nTyp:=3varFRec.vp2.intReal:=1ELSE varRec(recNum).nTyp:=1varFRec.vp2.intReal:=0ENDIF dmSize:=2ENDIF IF varRec(recNum).vTyp=$82 OR varRec(recNum).vTyp=$02 OR varRec(recNum).vTyp=$03 THEN IF NOT(varRec(recNum).nVar) THEN varRec(recNum).nTyp:=3varFRec.vp2.intReal:=2ELSE varRec(recNum).nTyp:=1varFRec.vp2.intReal:=0ENDIF dmSize:=5ENDIF IF varRec(recNum).vTyp=$46 OR varRec(recNum).vTyp=$47 THEN varRec(recNum).nTyp:=3IF varFRec.vp2.intReal=1 THEN dmSize:=2ELSE IF varFRec.vp2.intReal=2 THEN dmSize:=5ENDIF ENDIF ENDIF varRec(recNum).dmOff:=dmAddrvarFRec.vp1.dmSiz:=dmSizeENDIF (* STRING *)IF varFRec.vp3.mTyp=2 THEN (* VDT, Param and Field entry not necessary if type 2 *)isString:=TRUE(* Get Name String *)tokenCode:=varRec(recNum).vTypvarRec(recNum).nTyp:=1GOSUB 410 \REM get initial variable name identifervarFRec.vp2.vName:=tokenStringsubName:=tokenString(* DSAT Address and Entry Size *)dsAddr:=iPointervarRec(recNum).dsOff:=dsAddrdsSize:=4varFRec.vp1.dsSiz:=dsSizeSEEK #path,descOff+dsAddrGET #path,intVal(* Data Memory Address and Variable Size *)dmAddr:=intValvarRec(recNum).dmOff:=dmAddrdsPointer:=intValvarFRec.vp1.dsPtr:=dsPointerGET #path,intValdmSize:=intValvarFRec.vp1.dmSiz:=dmSizedSize:=intValvarFRec.vp1.dsvSiz:=dSizestrLen:="["+STR$(dmSize)+"]"varFRec.vp2.vStrLen:=strLenENDIF (* VDT references *)(* All references include VDT entry, DSAT, Param and Field entries vary *)IF varFRec.vp3.mTyp=3 THEN (* Variables *)(* VDT Address and Entry Size *)vAddr:=iPointervarRec(recNum).vdOff:=vAddrvSize:=3varFRec.vp1.vdSiz:=vSizeSEEK #path,symTabOff+vAddr(* VDT Token Value *)GET #path,byteValvToken:=byteValvarFRec.vp1.vdTkn:=vToken(* Get Name String *)tokenCode:=vTokenRESTORE 420 \REM set to VDT variable name labelsGOSUB 410 \REM get initial variable name identifervarFRec.vp2.vName:=tokenStringsubName:=tokenString(* VDT Pointer Value *)(* Points to DSAT, DM or PARAM *)GET #path,intValvPointer:=intValvarFRec.vp1.vdPtr:=vPointer(* Subroutines *)IF vToken=$A0 THEN (* Pointer to Data Memory Offset, DM contains INTEGER *)varRec(recNum).nTyp:=3dmAddr:=vPointervarRec(recNum).dmOff:=dmAddrdmSize:=2varFRec.vp1.dmSiz:=dmSize(* Get Name String *)REPEAT GET #path,byteValsubName:=subName+CHR$(LAND(byteVal,$7F))vSize:=vSize+1UNTIL byteVal>127varFRec.vp2.vName:=subName(* All Other VDT Entries *)ELSE IF vToken>=$60 AND vToken<=$63 THEN isSimple:=TRUE(* Data Memory Address and Variable Size *)varRec(recNum).nTyp:=1dmAddr:=vPointervarRec(recNum).dmOff:=dmAddrIF vToken=$60 OR vToken=$63 THEN dmSize:=1ENDIF IF vToken=$61 THEN dmSize:=2ENDIF IF vToken=$62 THEN dmSize:=5ENDIF varFRec.vp1.dmSiz:=dmSizeENDIF IF vToken>=$40 AND vToken<=$43 THEN varRec(recNum).nTyp:=0isSimple:=TRUEisField:=TRUEvarRec(recNum).dmOff:=0varFRec.vp1.dmSiz:=0(* Field Address and Variable Size *)fAddr:=vPointervarRec(recNum).fOff:=fAddrIF vToken=$40 OR vToken=$43 THEN fSize:=1ENDIF IF vToken=$41 THEN fSize:=2ENDIF IF vToken=$42 THEN fSize:=5ENDIF varFRec.vp1.fSiz:=fSizeENDIF IF vToken>=$80 AND vToken<=$83 THEN varRec(recNum).nTyp:=2isSimple:=TRUEisParam:=TRUE(* Parameter Address and Expected Size *)pAddr:=vPointervarRec(recNum).pOff:=pAddrvarRec(recNum).dmOff:=pAddrIF vToken=$80 OR vToken=$83 THEN pSize:=1ENDIF IF vToken=$81 THEN pSize:=2ENDIF IF vToken=$82 THEN pSize:=5ENDIF varFRec.vp1.pSiz:=pSizevarFRec.vp1.dmSiz:=4ENDIF IF NOT(isSimple) THEN (* Define Types *)IF vToken>=$44 AND vToken<=$5D THEN varRec(recNum).nTyp:=0isField:=TRUEENDIF IF vToken>=$64 AND vToken<=$7D THEN varRec(recNum).nTyp:=1ENDIF IF vToken>=$84 AND vToken<=$9D THEN varRec(recNum).nTyp:=2isParam:=TRUEENDIF IF vToken=$44 OR vToken=$4C OR vToken=$54 OR vToken=$5C THEN isString:=TRUEENDIF IF vToken=$64 OR vToken=$6C OR vToken=$74 OR vToken=$7C THEN isString:=TRUEENDIF IF vToken=$84 OR vToken=$8C OR vToken=$94 OR vToken=$9C THEN isString:=TRUEENDIF IF vToken=$45 OR vToken=$4D OR vToken=$55 OR vToken=$5D THEN isRecord:=TRUEENDIF IF vToken=$65 OR vToken=$6D OR vToken=$75 OR vToken=$7D THEN isRecord:=TRUEENDIF IF vToken=$85 OR vToken=$8D OR vToken=$95 OR vToken=$9D THEN isRecord:=TRUEENDIF IF isRecord AND NOT(hasRecords) THEN hasRecords:=TRUEENDIF IF vToken>=$48 AND vToken<=$4D THEN isArray:=TRUE \isArray1:=TRUEENDIF IF vToken>=$68 AND vToken<=$6D THEN isArray:=TRUE \isArray1:=TRUEENDIF IF vToken>=$88 AND vToken<=$8D THEN isArray:=TRUE \isArray1:=TRUEENDIF IF vToken>=$50 AND vToken<=$55 THEN isArray:=TRUE \isArray2:=TRUEENDIF IF vToken>=$70 AND vToken<=$75 THEN isArray:=TRUE \isArray2:=TRUEENDIF IF vToken>=$90 AND vToken<=$95 THEN isArray:=TRUE \isArray2:=TRUEENDIF IF vToken>=$58 AND vToken<=$5D THEN isArray:=TRUE \isArray3:=TRUEENDIF IF vToken>=$78 AND vToken<=$7D THEN isArray:=TRUE \isArray3:=TRUEENDIF IF vToken>=$98 AND vToken<=$9D THEN isArray:=TRUE \isArray3:=TRUEENDIF (* DSAT Address and Entry Size *)dsAddr:=vPointervarRec(recNum).dsOff:=dsAddrdsSize:=2(* dsPointer points to DSAT, DM or PARAM *)SEEK #path,descOff+dsAddrGET #path,intValdsPointer:=intValvarFRec.vp1.dsPtr:=dsPointer(* dSize relative to dsPointer *)GET #path,intValdSize:=intValvarFRec.vp1.dsvSiz:=dSizedsSize:=dsSize+2IF isString THEN IF NOT(isParam) AND NOT(isField) THEN (* Data Memory Address and Variable Size *)dmAddr:=dsPointervarRec(recNum).dmOff:=dmAddrdmSize:=dSizevarFRec.vp1.dmSiz:=dmSizeENDIF IF NOT(isArray) THEN strLen:="["+STR$(dSize)+"]"varFRec.vp2.vStrLen:=strLenENDIF ENDIF IF isRecord THEN IF NOT(isParam) AND NOT(isField) THEN (* Data Memory Address and Variable Size *)dmAddr:=dsPointervarRec(recNum).dmOff:=dmAddrdmSize:=dSizevarFRec.vp1.dmSiz:=dmSizeENDIF recSize:=dSizeENDIF IF isField THEN (* Field Simple Types *)(* Pointer to position in a record, size based on type *)(* Field Address and Variable Size *)fAddr:=dsPointervarRec(recNum).fOff:=fAddrfSize:=dSizevarFRec.vp1.fSiz:=fSizevarRec(recNum).dmOff:=0varFRec.vp1.dmSiz:=0ENDIF IF isParam THEN (* Parameter Simple Types *)(* Pointer to Parameter List offset, size is 4 (length of parameter list entry) *)(* Parameter Address and Expected Size *)pAddr:=dsPointervarRec(recNum).pOff:=pAddrvarRec(recNum).dmOff:=pAddrpSize:=dSizevarFRec.vp1.pSiz:=pSizevarFRec.vp1.dmSiz:=4ENDIF IF isArray THEN IF NOT(isParam) AND NOT(isField) THEN (* Data Memory Address and Variable Size *)dmAddr:=dsPointervarRec(recNum).dmOff:=dmAddrdmSize:=dSizevarFRec.vp1.dmSiz:=dmSizeENDIF arrayStr:=""GET #path,intValelement1:=intValvarFRec.vp1.elem1:=element1arrayStr:=arrayStr+"("+STR$(element1)dsSize:=dsSize+2IF isArray2 OR isArray3 THEN GET #path,intValelement2:=intValvarFRec.vp1.elem2:=element2arrayStr:=arrayStr+","+STR$(element2)dsSize:=dsSize+2ENDIF IF isArray3 THEN GET #path,intValelement3:=intValvarFRec.vp1.elem3:=element3arrayStr:=arrayStr+","+STR$(element3)dsSize:=dsSize+2ENDIF arrayStr:=arrayStr+")"varFRec.vp2.vArray:=arrayStr(* STRING/Record variable *)IF isString OR isRecord THEN GET #path,intValstrRecLen:=intValvarFRec.vp1.vSRLen:=strRecLendsSize:=dsSize+2IF isString THEN strLen:="["+STR$(strRecLen)+"]"varFRec.vp2.vStrLen:=strLenENDIF IF isRecord THEN recArraySize:=recSizerecSize:=strRecLenENDIF ENDIF ENDIF (* Set DSAT Entry Size *)IF dsSize>0 THEN varFRec.vp1.dsSiz:=dsSizeENDIF ENDIF ENDIF ENDIF (* Resets *)IF isRecord AND NOT(varFRec.vp3.pRec) THEN varFRec.vp3.pRec:=TRUEENDIF IF NOT(isRecord) AND varFRec.vp3.pRec THEN varFRec.vp3.pRec:=FALSEENDIF IF isField AND NOT(varFRec.vp3.pFld) THEN varFRec.vp3.pFld:=TRUEENDIF IF NOT(isField) AND varFRec.vp3.pFld THEN varFRec.vp3.pFld:=FALSEENDIF IF NOT(isString) THEN varFRec.vp2.vStrLen:=""ENDIF IF NOT(isArray) THEN varFRec.vp2.vArray:=""ENDIF IF verbose THEN  GOSUB 250 \REM Display Variable ReferencesENDIFSEEK #vPath,recNum*SIZE(varFRec)+2PUT #vPath,varFRecrecNum:=recNum+1UNTIL recNum=varCountPRINT #2,"Done"(* Sort Variables *)PRINT #2,"Sorting Variable Records "; SEEK #vPath,0RUN vSort(er,which,vPath,0,varCount-1,varRec)IF er>0 THEN 500 \REM goto error trapPRINT #2," Done"(* The bubble sort for sorting the field records *)(* Count field records *)fRecs:=0REPEAT SEEK #vPath,fRecs*SIZE(varFRec)+2GET #vPath,varFRecfRecs:=fRecs+1UNTIL varFRec.vp1.vdTkn>$5F OR varFRec.vp1.vdTkn=0fRecs:=fRecs-1IF fRecs>0 THEN PRINT #2,"Sorting "; fRecs; " Field Variable Records "; RUN fSort(vPath,0,fRecs,varRec)ENDIF OPEN #dPath,dFile:UPDATEPUT #dPath,hasRecordsPUT #dPath,varRecCLOSE #dPathPRINT #2," Done"(* Display Naming Variables? *)PRINT #2,"Naming Variables ";IF verbose THEN  PRINT #2  PRINT #2,"  Variable Record Name"ENDIF(* Name Variables *)recNum:=0 \varNum:=1 \fldNum:=1 \numStr:=""fAddr:=0 \dmAddr:=0 \dsAddr:=0 \tName:=""REPEAT SEEK #vPath,recNum*SIZE(varFRec)+2GET #vPath,varFRecIF varRec(recNum).nVar THEN IF varRec(recNum).nTyp=0 THEN IF fldNum<10 THEN numStr:="00"+STR$(fldNum)ELSE numStr:="0"+STR$(fldNum)ENDIF IF recNum>0 AND varRec(recNum).dsOff=dsAddr AND varRec(recNum).fOff=fAddr THEN varFRec.vp2.vName:=tNameELSE IF RIGHT$(varFRec.vp2.vName,1)=")" THEN varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,2)+numStr+RIGHT$(varFRec.vp2.vName,LEN(varFRec.vp2.vName)-2)ELSE varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,1)+numStrENDIF fAddr:=varRec(recNum).fOffdsAddr:=varRec(recNum).dsOfftName:=varFRec.vp2.vNamefldNum:=fldNum+1ENDIF ELSE IF varRec(recNum).nTyp=1 THEN IF varNum<10 THEN numStr:="000"+STR$(varNum)ELSE IF varNum<100 THEN numStr:="00"+STR$(varNum)ELSE numStr:="0"+STR$(varNum)ENDIF ENDIF IF dmAddr>0 AND varRec(recNum).dmOff=dmAddr THEN varFRec.vp2.vName:=tNameELSE IF RIGHT$(varFRec.vp2.vName,1)=")" THEN varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,2)+numStr+RIGHT$(varFRec.vp2.vName,LEN(varFRec.vp2.vName)-2)ELSE varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,1)+numStrENDIF dmAddr:=varRec(recNum).dmOfftName:=varFRec.vp2.vNamevarNum:=varNum+1ENDIF ELSE IF varRec(recNum).nTyp=2 THEN IF varNum<10 THEN numStr:="000"+STR$(varNum)ELSE IF varNum<100 THEN numStr:="00"+STR$(varNum)ELSE numStr:="0"+STR$(varNum)ENDIF ENDIF IF varRec(recNum).dmOff=dmAddr THEN varFRec.vp2.vName:=tNameELSE IF RIGHT$(varFRec.vp2.vName,1)=")" THEN varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,3)+numStr+RIGHT$(varFRec.vp2.vName,LEN(varFRec.vp2.vName)-3)ELSE varFRec.vp2.vName:=LEFT$(varFRec.vp2.vName,2)+numStrENDIF dmAddr:=varRec(recNum).dmOfftName:=varFRec.vp2.vNamevarNum:=varNum+1ENDIF ENDIF ENDIF ENDIF ENDIF IF verbose THEN  PRINT #2 USING "i6>,s11,s29",recNum," ",varFRec.vp2.vNameELSE  PRINT #2, ".";ENDIFIF varRec(recNum).nVar THEN SEEK #vPath,recNum*SIZE(varFRec)+2PUT #vPath,varFRecENDIF recNum:=recNum+1UNTIL recNum=varCountIF NOT(verbose) THEN  PRINT #2," ";ENDIFPRINT #2,"Done"(* Display Sorted Variable Records *)IF verbose THEN  PRINT #2,"Displaying Variable Records"ENDIFfirst:=FALSEGOSUB 200 \REM Display Variable Reference LabelsIF NOT(verbose) THEN  PRINT #2," ";ENDIFSEEK #vPath,2FOR recNum:=0 TO varCount-1GET #vPath,varFRecIF verbose THEN  GOSUB 250 \REM Display Variable ReferencesELSE  PRINT #2,".";ENDIFNEXT recNumIF NOT(verbose) THEN  PRINT #2," ";ENDIFPRINT #2,"Done"(* Validate VDT *)mSize:=modSize-3-symTabOffIF mSize>0 THEN PRINT #2,"Validating Symbol Table ";IF verbose THEN  PRINT #2  PRINT #2,"  VDT   Variable Name/"  PRINT #2,"Tk Ptr  Subroutine"ENDIFVDCount:=0 \vdtCnt:=0 \VDCnt:=0 \mCount:=0 \validated:=TRUESEEK #path,symTabOffREPEAT GET #path,vTokenGET #path,vPointermCount:=mCount+3IF verbose THEN  PRINT #2 USING "h2,x1,h4",vToken,vPointer; ELSE  PRINT #2, ".";ENDIFIF vToken=$A0 THEN subName:=""REPEAT GET #path,byteValsubName:=subName+CHR$(LAND(byteVal,$7F))mCount:=mCount+1UNTIL byteVal>127IF verbose THEN  PRINT #2," "; subName; ENDIF ENDIF found:=FALSE10 SEEK #vPath,VDCount*SIZE(varFRec)+2REPEAT GET #vPath,varFRecIF varFRec.vp1.vdTkn=vToken AND varFRec.vp1.vdPtr=vPointer THEN found:=TRUEENDIF VDCount:=VDCount+1UNTIL found OR VDCount=varCountIF NOT(found) THEN IF VDCnt=0 THEN VDCnt:=1 \VDCount:=0GOTO 10ENDIF ENDIF VDCount:=VDCount-1IF found THEN IF verbose THEN  PRINT #2," "; varFRec.vp2.vName; " Validated"; ENDIFELSE IF verbose THEN  PRINT #2," Unidentified"; ENDIFvalidated:=FALSEENDIF vdtCnt:=vdtCnt+1GOSUB 267 \REM display countsVDCnt:=0UNTIL mCount=mSizeIF NOT(verbose) THEN  PRINT #2, " ";ENDIFPRINT #2,"Done"ELSE PRINT #2,"No VDT Entries"ENDIF IF NOT(validated) THEN PRINT #2,"Symbol Table Not Validated"ELSE PRINT #2,"Symbol Table Validated"ENDIF (* End of Program *)END (* ============= *)(* == Group 2 == *)(* Display Variable References *)200 IF verbose AND first THEN   PRINT #2,"Variable References (unsorted)"ELSE   IF verbose AND NOT(first) THEN     PRINT #2,"Variable References (sorted)"  ELSE    IF NOT(first) THEN      PRINT #2,"Variable References";    ENDIF  ENDIFENDIF IF verbose THEN  PRINT #2,"RNum _Instr_ VDT__________VDT_ DSAT___________DSAT Data_Mmry __Field__ Parm Expd"  PRINT #2 USING "i4>,s76",varCount," Tk Pntr Addr Tk Pntr Size Addr Pntr Size Size Addr Size Addr Size Addr Size"  PRINT #2," VES_ TES_ MES_ SRSz Array Size String   Variable/Subroutine Name      StrLen  Fields"ENDIF RETURN (* ============= *)250 IF verbose THEN  REM "Ref  _Instr_ "  REM "Num_ Tk Pntr "  PRINT #2 USING "i4>,s1",recNum+1," ";   PRINT #2 USING "h2,s1",varRec(recNum).vTyp," ";   PRINT #2 USING "h4,s1",varRec(recNum).vOff," ";   IF varFRec.vp1.vdTkn>0 THEN   REM "________VDT______ "  REM "Addr Tk Pntr Size "  PRINT #2 USING "h4,s1",varRec(recNum).vdOff," ";   PRINT #2 USING "h2,s1",varFRec.vp1.vdTkn," ";   PRINT #2 USING "h4,s1",varFRec.vp1.vdPtr," ";   PRINT #2 USING "h4,s1",varFRec.vp1.vdSiz," ";   ELSE   PRINT #2,"---- -- ---- ---- ";   ENDIF   IF varFRec.vp1.dsSiz>0 THEN   REM "DSAT___________DSAT "  REM "Addr Pntr Size Size "  PRINT #2 USING "h4,s1",varRec(recNum).dsOff," ";   PRINT #2 USING "h4,s1",varFRec.vp1.dsPtr," ";   PRINT #2 USING "h4,s1",varFRec.vp1.dsvSiz," ";   PRINT #2 USING "h4,s1",varFRec.vp1.dsSiz," ";   ELSE   PRINT #2,"---- ---- ---- ---- ";   ENDIF   IF varFRec.vp1.dmSiz>0 THEN   REM "Data_Mmry "  REM "Addr Size "  PRINT #2 USING "h4,s1",varRec(recNum).dmOff," ";   PRINT #2 USING "h4,s1",varFRec.vp1.dmSiz," ";   ELSE   PRINT #2,"---- ---- ";   ENDIF   IF varFRec.vp1.fSiz>0 THEN   REM "__Field__ "  REM "Addr Size "  PRINT #2 USING "h4,s1",varRec(recNum).fOff," ";   PRINT #2 USING "h4,s1",varFRec.vp1.fSiz," ";   ELSE   PRINT #2,"---- ---- ";   ENDIF   IF varFRec.vp1.pSiz>0 THEN   REM "Parm Expd";  REM "Addr Size";  PRINT #2 USING "h4,s1",varRec(recNum).pOff," ";   PRINT #2 USING "h4,s1",varFRec.vp1.pSiz," ";   ELSE   PRINT #2,"---- ---- ";   ENDIF   IF varFRec.vp1.elem1>0 THEN   REM "VES_ "  PRINT #2 USING "h4,s1",varFRec.vp1.elem1," ";   ELSE   PRINT #2,"---- ";   ENDIF   IF varFRec.vp1.elem2>0 THEN   REM "TES_ "  PRINT #2 USING "h4,s1",varFRec.vp1.elem2," ";   ELSE   PRINT #2,"---- ";   ENDIF   IF varFRec.vp1.elem3>0 THEN   REM "MES_ "  PRINT #2 USING "h4,s1",varFRec.vp1.elem3," ";   ELSE   PRINT #2,"---- ";   ENDIF   IF varFRec.vp1.vSRLen>0 THEN   REM "SRSz "  PRINT #2 USING "h4,s1",varFRec.vp1.vSRLen," ";   ELSE   PRINT #2,"---- ";   ENDIF   IF varFRec.vp2.vArray<>"" THEN   REM "Array Size String   "  PRINT #2 USING "s19,s1",varFRec.vp2.vArray," ";   ELSE   PRINT #2,"------------------- ";   ENDIF   IF varFRec.vp2.vName<>"" THEN   REM "Variable/Subroutine Name      "  PRINT #2 USING "s29,s1",varFRec.vp2.vName," ";   ELSE   PRINT #2,"----------------------------- ";   ENDIF   IF varFRec.vp2.vStrLen<>"" THEN   REM "StrLen ";  PRINT #2 USING "s7",varFRec.vp2.vStrLen;   ELSE   PRINT #2,"-------";   ENDIF   REM "Fields "  IF LEFT$(varFRec.vp2.vName,1)="C" OR LEFT$(varFRec.vp2.vName,1)="c" THEN  PRINT #2 USING "s3,i2>"," ",varFRec.vp3.fNum;   ELSE   PRINT #2," ------";   ENDIF   PRINT #2ELSE  PRINT #2, ".";ENDIFRETURN (* ============= *)(* Display Counts *)267 IF verbose THEN  PRINT  " "; vdtCntENDIFRETURN (* ============= *)(* == Group 4 == *)(* Assign Beginning Variable Label Name *)410 REPEAT READ tokenByte,tokenStringUNTIL tokenByte=tokenCode OR tokenByte=$A0RETURN (* ============= *)(* Data for Label Names *)420 DATA $40,"b",$41,"i",$42,"r",$43,"l",$44,"s",$45,"c"DATA $60,"B",$61,"I",$62,"R",$63,"L",$64,"S",$65,"C"DATA $80,"PB",$81,"PI",$82,"PR",$83,"PL",$84,"PS",$85,"PC"DATA $48,"ba()",$49,"ia()",$4A,"ra()",$4B,"la()",$4C,"sa()",$4D,"ca()"DATA $68,"BA()",$69,"IA()",$6A,"RA()",$6B,"LA()",$6C,"SA()",$6D,"CA()"DATA $88,"PBA()",$89,"PIA()",$8A,"PRA()",$8B,"PLA()",$8C,"PSA()",$8D,"PCA()"DATA $50,"ba(,)",$51,"ia(,)",$52,"ra(,)",$53,"la(,)",$54,"sa(,)",$55,"ca(,)"DATA $70,"BA(,)",$71,"IA(,)",$72,"RA(,)",$73,"LA(,)",$74,"SA(,)",$75,"CA(,)"DATA $90,"PBA(,)",$91,"PIA(,)",$92,"PRA(,)",$93,"PLA(,)",$94,"PSA(,)",$95,"PCA(,)"DATA $58,"ba(,,)",$59,"ia(,,)",$5A,"ra(,,)",$5B,"la(,,)",$5C,"sa(,,)",$5D,"ca(,,)"DATA $78,"BA(,,)",$79,"IA(,,)",$7A,"RA(,,)",$7B,"LA(,,)",$7C,"SA(,,)",$7D,"CA(,,)"DATA $98,"PBA(,,)",$99,"PIA(,,)",$9A,"PRA(,,)",$9B,"PLA(,,)",$9C,"PSA(,,)",$9D,"PCA(,,)"DATA $A0,""(* ============= *)(* Data for Simple Label Names *)430 DATA $00,"I",$01,"I",$02,"R",$03,"R",$46,"TO",$47,"STEP"DATA $80,"B",$81,"I",$82,"R",$83,"L",$84,"S"DATA $85,"",$86,"",$87,"",$88,"",$89,"",$8A,"",$8B,"",$8C,""DATA $F2,"",$F3,"",$F4,"",$F5,"",$F6,"",$F7,"",$F8,"",$F9,""(* == Group 5 == *)(* Error Trap *)500 IF er=0 THEN er:=ERRENDIF IF vOpen THEN CLOSE #vPathvOpen:=FALSEENDIF IF dOpen THEN CLOSE #dPathdOpen:=FALSEENDIF END (* ============= *)PROCEDURE vSort(* based on quicksort, by T.F. Ritter(* Variable Record *)(* Array *)TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGERDIM varRec:VREC(* File Record *)TYPE VFP1=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGERTYPE VFP2=vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGERTYPE VFP3=mTyp,vLnk,fNum:BYTE; pRec,pFld:BOOLEANTYPE VFRC= vp1:VFP1; vp2:VFP2; vp3:VFP3DIM varFRec,varFRecs(2):VFRCPARAM er,which:INTEGER; vPath:BYTE; bottom,top:INTEGER; varRecs(400):VRECDIM lower,upper:INTEGER; btemp:BOOLEANON ERROR GOTO 10which:=which+1PRINT #2, ".";BASE 0lower:=bottomupper:=topLOOP  \REM each element gets the once overREPEAT  \REM this is a postinc instructionbtemp:=varRecs(lower).dmOff<varRecs(top).dmOfflower:=lower+1UNTIL NOT(btemp)lower:=lower-1 \REM point at the tested elementEXITIF lower=upper THEN ENDEXIT REPEAT  \REM this is a postdec instructionupper:=upper-1UNTIL varRecs(upper).dmOff<=varRecs(top).dmOff OR upper=lowerEXITIF lower=upper THEN ENDEXIT SEEK #vPath,lower*SIZE(varFRec)+2GET #vPath,varFRecvarFRecs(0):=varFRecSEEK #vPath,upper*SIZE(varFRec)+2GET #vPath,varFRecvarFRecs(1):=varFRecvarRec:=varRecs(lower)varRecs(lower):=varRecs(upper)varRecs(upper):=varRecvarFRec:=varFRecs(0)varFRecs(0):=varFRecs(1)varFRecs(1):=varFRecSEEK #vPath,lower*SIZE(varFRec)+2varFRec:=varFRecs(0)PUT #vPath,varFRecSEEK #vPath,upper*SIZE(varFRec)+2varFRec:=varFRecs(1)PUT #vPath,varFReclower:=lower+1 \REM prepare for postincEXITIF lower=upper THEN ENDEXIT ENDLOOP IF lower<>top THEN IF varRecs(lower).dmOff<>varRecs(top).dmOff THEN SEEK #vPath,lower*SIZE(varFRec)+2GET #vPath,varFRecvarFRecs(0):=varFRecSEEK #vPath,top*SIZE(varFRec)+2GET #vPath,varFRecvarFRecs(1):=varFRecvarRec:=varRecs(lower)varRecs(lower):=varRecs(top)varRecs(top):=varRecvarFRec:=varFRecs(0)varFRecs(0):=varFRecs(1)varFRecs(1):=varFRecSEEK #vPath,lower*SIZE(varFRec)+2varFRec:=varFRecs(0)PUT #vPath,varFRecSEEK #vPath,top*SIZE(varFRec)+2varFRec:=varFRecs(1)PUT #vPath,varFRecENDIF ENDIF IF bottom<lower-1 THEN RUN vSort(er,which,vPath,bottom,lower-1,varRecs)ENDIF IF lower+1<top THEN RUN vSort(er,which,vPath,lower+1,top,varRecs)ENDIF END 10 er:=ERREND (* ============= *)PROCEDURE fSort(* Field Sort *)(* Variable Record *)(* Array *)TYPE VREC=vTyp,nTyp:BYTE; nVar:BOOLEAN; vOff,vdOff,dsOff,dmOff,fOff,pOff:INTEGERDIM varRec:VREC(* File Record *)TYPE VFP1=vdTkn:BYTE; vdPtr,vdSiz,dsPtr,dsvSiz,dsSiz,dmSiz,fSiz,pSiz,elem1,elem2,elem3,vSRLen:INTEGERTYPE VFP2=vArray:STRING[19]; vName:STRING[29]; vStrLen:STRING[7]; vRecNum,vRefCnt,intReal,pVar:INTEGERTYPE VFP3=mTyp,vLnk,fNum:BYTE; pRec,pFld:BOOLEANTYPE VFRC= vp1:VFP1; vp2:VFP2; vp3:VFP3DIM varFRec,varFRecs(2):VFRCDIM sortedInt:INTEGERPARAM vPath:BYTE; recCount,varCount:INTEGER; varRecs(400):VRECBASE 0(* new variable, this tells us where in the array to jump to when a sorted pair is found *)sortedInt:=0REPEAT SEEK #vPath,recCount*SIZE(varFRec)+2GET #vPath,varFRecIF varFRec.vp1.vdTkn>$3F AND varFRec.vp1.vdTkn<$60 THEN (* compare current element to next element *)IF varRecs(recCount).vOff>varRecs(recCount+1).vOff THEN PRINT #2, ".";(* current element is larger than following, swap them *)varRec:=varRecs(recCount)varRecs(recCount):=varRecs(recCount+1)varRecs(recCount+1):=varRecSEEK #vPath,recCount*SIZE(varFRec)+2GET #vPath,varFRecsvarFRec:=varFRecs(0)varFRecs(0):=varFRecs(1)varFRecs(1):=varFRecSEEK #vPath,recCount*SIZE(varFRec)+2PUT #vPath,varFRecs(* decrement position if > 0 (this is the "bubble" effect) *)recCount:=ABS(recCount-1)ELSE (* these elements are sorted or equal, move to next comparison *)recCount:=sortedInt(* increment our jump pointer to next pair of records *)sortedInt:=sortedInt+1(* recCount:=recCount+1 *)ENDIF ENDIF (* if our position is the last element, our array is sorted *)UNTIL recCount=varCount-1END 